# Лекция 4. Циклы в C#

**Цель лекции:** Изучить концепцию циклов, освоить синтаксис всех видов циклов в C#, понять их различия и области применения, а также научиться избегать типичных ошибок.

---

### **План лекции:**

1.  **Введение.** Что такое циклы? Зачем они нужны?
2.  **Цикл `for`.** Синтаксис, классическое использование, примеры.
3.  **Цикл `while`.** Синтаксис, использование, когда применять.
4.  **Цикл `do...while`.** Отличие от `while`, синтаксис, примеры.
5.  **Цикл `foreach`.** Специализированный цикл для перебора коллекций.
6.  **Операторы управления циклом:** `break`, `continue`.
7.  **Бесконечные циклы:** как избежать и как использовать правильно.
8.  **Резюме.** Сравнительная таблица и общие рекомендации.
9.  **Контрольные вопросы.**

---

### **1. Введение. Что такое циклы?**

**Цикл** — это конструкция языка программирования, которая позволяет выполнить определенный блок кода **многократно**, пока выполняется заданное условие.

**Зачем они нужны?**
*   **Устранение повторяемости кода (DRY - Don't Repeat Yourself).** Вместо того чтобы писать один и тот же оператор много раз, мы помещаем его в тело цикла.
*   **Обработка коллекций данных.** Перебор массивов, списков, строк и других структур данных.
*   **Реализация алгоритмов.** Многие алгоритмы (сортировка, поиск, вычисления) итеративны по своей природе.
*   **Ожидание события.** Создание программ, которые работают до тех пор, пока пользователь не решит их закрыть (игровые циклы, серверные приложения).

**Представьте себе задачу:** Вывести на экран числа от 1 до 100.
Без цикла это 100 строк кода `Console.WriteLine(...)`. С циклом — 3-5 строк.

### **2. Цикл `for`**

**Синтаксис:**
```csharp
for (инициализация; условие; итератор)
{
    // Тело цикла (выполняемый код)
}
```
*   **Инициализация:** Выполняется один раз перед входом в цикл. Обычно здесь объявляется и инициализируется **счетчик** цикла.
*   **Условие:** Вычисляется *перед каждой* итерацией. Если условие равно `true`, выполняется тело цикла. Если `false` — цикл завершается.
*   **Итератор:** Выполняется *после каждой* итерации цикла. Обычно здесь происходит изменение счетчика (инкремент/декремент).

**Классический пример:**
```csharp
// Вывод чисел от 0 до 9
for (int i = 0; i < 10; i++)
{
    Console.WriteLine(i);
}
```
*   `int i = 0;` — Создается переменная `i` (счетчик) со значением 0.
*   `i < 10;` — Условие: "i меньше 10?". Да? Выполняем тело.
*   `Console.WriteLine(i);` — Выводится текущее значение `i`.
*   `i++` — Значение `i` увеличивается на 1. Теперь `i = 1`.
*   Возврат к проверке условия `i < 10?` (1 < 10 -> `true`). И так далее, пока `i` не станет равным 10. Условие `10 < 10` ложно -> цикл завершается.

**Другие примеры `for`:**
```csharp
// Обратный отсчет
for (int countdown = 10; countdown > 0; countdown--)
{
    Console.WriteLine($"До старта: {countdown}");
}
Console.WriteLine("Поехали!");

// Цикл с шагом 2
for (int i = 0; i <= 20; i += 2)
{
    Console.WriteLine(i); // Выведет 0, 2, 4, ... 20
}

// Вычисление суммы чисел от 1 до N
int sum = 0;
int n = 100;
for (int i = 1; i <= n; i++)
{
    sum += i;
}
Console.WriteLine($"Сумма чисел от 1 до {n} равна {sum}");
```

### **3. Цикл `while`**

**Синтаксис:**
```csharp
while (условие)
{
    // Тело цикла
}
```
*   Цикл `while` проверяет условие *перед* каждой итерацией. Если условие изначально ложно, тело цикла не выполнится ни разу.

**Когда использовать?**
Когда количество итераций **заранее неизвестно** и зависит от какого-то динамического условия.

**Примеры:**
```csharp
// Чтение входных данных до тех пор, пока пользователь не введет "exit"
string userInput = "";
while (userInput != "exit")
{
    Console.Write("Введите команду (или 'exit' для выхода): ");
    userInput = Console.ReadLine();
    Console.WriteLine($"Вы ввели: {userInput}");
}

// Ожидание подключения к базе данных
bool isConnected = false;
int attempts = 0;
while (!isConnected && attempts < 5)
{
    attempts++;
    Console.WriteLine($"Попытка подключения #{attempts}");
    // ... код попытки подключения ...
    // isConnected = TryConnectToDatabase(); // предположим, что этот метод возвращает bool
    isConnected = true; // для примера пусть всегда успешно
    System.Threading.Thread.Sleep(1000); // Пауза 1 секунда
}
```

### **4. Цикл `do...while`**

**Синтаксис:**
```csharp
do
{
    // Тело цикла
} while (условие);
```
*   Ключевое отличие от `while`: условие проверяется **после** выполнения тела цикла. Это гарантирует, что тело цикла выполнится **как минимум один раз**.

**Пример:**
```csharp
// Запрос у пользователя до тех пор, пока не будет введено корректное число
int number;
do
{
    Console.Write("Введите положительное число: ");
} while (!int.TryParse(Console.ReadLine(), out number) || number <= 0);
// Тело цикла (запрос) выполнится хотя бы один раз, а затем будет проверка.
Console.WriteLine($"Вы ввели: {number}");
```

### **5. Цикл `foreach`**

**Синтаксис:**
```csharp
foreach (тип элемент in коллекция)
{
    // Тело цикла
}
```
*   Этот цикл предназначен **исключительно** для перебора элементов любой коллекции, реализующей интерфейс `IEnumerable` (массивы, списки `List<T>`, словари и т.д.).
*   Он **избавляет** программиста от необходимости manually управлять индексом, что делает код чище и менее подверженным ошибкам.

**Примеры:**
```csharp
// Перебор массива
string[] fruits = { "apple", "banana", "orange" };
foreach (string fruit in fruits)
{
    Console.WriteLine(fruit);
}
// На каждой итерации в переменную `fruit` будет помещен следующий элемент массива.

// Перебор списка
List<int> numbers = new List<int> { 1, 1, 2, 3, 5, 8 };
foreach (int digit in numbers)
{
    Console.Write($"{digit} "); // Выведет: 1 1 2 3 5 8
}

// Важно: внутри foreach нельзя изменять саму коллекцию (добавлять/удалять элементы),
// иначе будет выброшено исключение InvalidOperationException.
```

### **6. Операторы управления циклом: `break` и `continue`**

*   **`break`** — **немедленно завершает** выполнение цикла (выйдя из него), передавая управление следующему за циклом оператору.
    ```csharp
    // Поиск первого четного числа в массиве и выход из цикла
    int[] numbers = { 1, 3, 5, 8, 10, 12 };
    foreach (int num in numbers)
    {
        if (num % 2 == 0)
        {
            Console.WriteLine($"Первое четное число: {num}");
            break; // Цикл прервется здесь, число 10 не будет обработано в этой итерации.
        }
    }
    ```

*   **`continue`** — **прерывает текущую итерацию** цикла и переходит к **следующей** итерации.
    ```csharp
    // Вывод только нечетных чисел от 1 до 10
    for (int i = 1; i <= 10; i++)
    {
        if (i % 2 == 0) // если число четное
        {
            continue; // пропускаем оставшееся тело цикла и переходим к i++
        }
        Console.WriteLine(i); // Эта строка выполнится только для нечетных i
    }
    ```

### **7. Бесконечные циклы**

Это циклы, условие выхода из которых никогда не становится ложным.

*   **Как случайно создать?**
    ```csharp
    // Классическая ошибка: забыли инкрементировать счетчик
    int i = 0;
    while (i < 10)
    {
        Console.WriteLine("Застрял здесь навсегда!");
        // i++; <- забытая строка
    }

    // Условие всегда true
    while (true)
    {
        // ... код без break ...
    }
    ```

*   **Как использовать правильно?** С помощью `break` для выхода.
    ```csharp
    // Игровой цикл
    while (true)
    {
        // Обновление состояния игры
        // Отрисовка кадра
        // Обработка ввода

        if (/* условие выхода из игры (например, нажата клавиша Esc) */)
        {
            break;
        }
    }

    // Ожидание корректного ввода
    while (true)
    {
        Console.Write("Введите 'yes' или 'no': ");
        string input = Console.ReadLine();
        if (input == "yes" || input == "no")
        {
            break;
        }
        Console.WriteLine("Неверный ввод!");
    }
    ```

### **8. Резюме**

| Цикл | Когда использовать? | Преимущества | Недостатки |
| :--- | :--- | :--- | :--- |
| **`for`** | Когда известно **количество итераций**. | Полный контроль над счетчиком. Компактный синтаксис. | Более сложный синтаксис для простых задач перебора. |
| **`while`** | Когда количество итераций **неизвестно**, и зависит от условия. Проверка условия **до** итерации. | Гибкость. Условие может быть очень сложным. | Риск бесконечного цикла, если условие никогда не станет ложным. |
| **`do...while`** | Когда количество итераций **неизвестно**, но тело цикла **должно выполниться хотя бы раз**. | Гарантия однократного выполнения. | Используется реже, чем `while`. |
| **`foreach`** | Для **перебора всех элементов коллекции** (массивы, списки и т.д.). | Простота и безопасность. Не нужно управлять индексами. | Нельзя изменить саму коллекцию во время обхода. Меньше контроля над порядком (только прямой перебор). |

**Общие рекомендации:**
1.  **Выбор цикла:** Выбирайте цикл в зависимости от задачи, а не от привычки.
2.  `foreach` — ваш лучший друг для перебора коллекций.
3.  **Избегайте бесконечных циклов:** Всегда убеждайтесь, что условие выхода рано или поздно станет ложным или что есть оператор `break`.
4.  **Именование счетчиков:** Используйте понятные имена для счетчиков (не только `i`, `j`), если это улучшает читаемость (например, `index`, `row`, `column`).

### **9. Контрольные вопросы**

1.  В чем основное различие между циклом `while` и `do...while`? В какой ситуации вы предпочтете один другому?
2.  Объясните назначение каждой из трех частей в заголовке цикла `for`.
3.  Почему цикл `foreach` считается более безопасным для перебора коллекций по сравнению с `for`?
4.  Что произойдет, если в теле цикла `while` с условием `(x < 5)` не изменять переменную `x`?
5.  Чем оператор `break` отличается от `continue`? Приведите практические примеры для каждого.
6.  Можно ли использовать цикл `foreach` для перебора коллекции и одновременного удаления из нее элементов? Почему?
7.  Какой цикл вы бы использовали для реализации меню, которое отображается пользователю до тех пор, пока он не выберет пункт "Выход"? Обоснуйте свой выбор.
8.  Напишите код, который с помощью цикла вычислит факториал числа N.
9.  В чем опасность и каково практическое применение бесконечных циклов?
10. Как с помощью цикла `for` вывести все элементы массива строк в обратном порядке?