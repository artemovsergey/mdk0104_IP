# Лекция 10. Интерфейсы и абстрактные классы

**Цель:** Студенты смогут различать интерфейсы и абстрактные классы, понимать их назначение и применять их в правильных сценариях для создания гибкого, поддерживаемого и расширяемого кода.

---

### **План лекции:**

1.  **Введение в полиморфизм.** Краткое повторение.
2.  **Абстрактные классы.**
    *   Что такое абстрактный класс?
    *   Абстрактные методы и свойства.
    *   Когда использовать абстрактные классы?
    *   Пример: Модель транспортных средств.
3.  **Интерфейсы.**
    *   Что такое интерфейс?
    *   Реализация интерфейсов.
    *   Когда использовать интерфейсы?
    *   Пример: Модель "Летающих" и "Плавающих" объектов.
4.  **Сравнительный анализ: Интерфейсы vs. Абстрактные классы.**
    *   Ключевые различия (наследование vs. реализация, состояние/поля, конструкторы, модификаторы доступа).
    *   Практическое правило: "is-a" vs "can-do".
5.  **Продвинутые концепции интерфейсов (C# 8.0 и новее).**
    *   Методы по умолчанию в интерфейсах.
    *   Статические методы и поля.
6.  **Резюме.**
7.  **Контрольные вопросы.**

---

### **Подробное рассмотрение пунктов плана:**

#### **1. Введение в полиморфизм**

**Повторение:** Полиморфизм — это один из столпов ООП, позволяющий работать с объектами разных типов через единый интерфейс (в общем смысле). Это означает, что один и тот же код может выполнять разные операции в зависимости от типа объекта, с которым он работает.

**Пример:**
```csharp
// Базовый класс
public class Shape
{
    public virtual void Draw()
    {
        Console.WriteLine("Рисую фигуру...");
    }
}

// Производные классы
public class Circle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Рисую круг.");
    }
}

public class Rectangle : Shape
{
    public override void Draw()
    {
        Console.WriteLine("Рисую прямоугольник.");
    }
}

// Использование полиморфизма
List<Shape> shapes = new List<Shape> { new Circle(), new Rectangle() };
foreach (Shape shape in shapes)
{
    shape.Draw(); // Вызовется правильная версия метода Draw
}
// Вывод:
// Рисую круг.
// Рисую прямоугольник.
```
Абстрактные классы и интерфейсы — это два основных механизма для достижения полиморфизма на более строгом и гибком уровне.

---

#### **2. Абстрактные классы**

**Что это?** Абстрактный класс — это класс, помеченный ключевым словом `abstract`. Его главная особенность в том, что **нельзя создать экземпляр (объект) абстрактного класса**. Он существует только для того, чтобы быть базовым классом для других.

**Абстрактные методы и свойства:** Это методы/свойства без реализации (тела), также помеченные `abstract`. Они *обязывают* производные классы предоставить свою собственную реализацию с помощью `override`.

**Когда использовать?**
*   Когда у вас есть тесно связанные классы, которые имеют **общую, базовую логику** (поля, методы с реализацией), но также требуют **специфического поведения**, которое можно только описать, но не реализовать на базовом уровне.
*   Когда вы хотите обеспечить общий **инвариант** (состояние), который будет общим для всех наследников.

**Пример: Модель транспортных средств**

```csharp
// Абстрактный класс
public abstract class Vehicle
{
    // Обычное свойство с реализацией - общее для всех транспортных средств
    public string Model { get; set; }
    public int Year { get; set; }

    // Конструктор - может быть только в абстрактном классе
    public Vehicle(string model, int year)
    {
        Model = model;
        Year = year;
    }

    // Обычный метод с реализацией
    public void StartEngine()
    {
        Console.WriteLine($"{Model}: Двигатель запущен.");
    }

    // Абстрактный метод - без реализации. Обязателен для переопределения.
    public abstract void Move();

    // Абстрактное свойство
    public abstract int MaxSpeed { get; }
}

// Производные классы
public class Car : Vehicle
{
    public Car(string model, int year) : base(model, year) { }

    // Реализация абстрактного метода
    public override void Move()
    {
        Console.WriteLine($"{Model} едет по дороге.");
    }

    // Реализация абстрактного свойства
    public override int MaxSpeed => 250;
}

public class Bicycle : Vehicle
{
    public Bicycle(string model, int year) : base(model, year) { }

    public override void Move()
    {
        Console.WriteLine($"{Model} едет по велодорожке.");
    }

    public override int MaxSpeed => 50;
}

// Использование
Vehicle myCar = new Car("Tesla Model 3", 2023);
Vehicle myBike = new Bicycle("Stels", 2022);

myCar.StartEngine(); // Общий метод
myCar.Move();        // Уникальная реализация

myBike.StartEngine(); // Общий метод
myBike.Move();        // Уникальная реализация

// Vehicle vehicle = new Vehicle(); // ОШИБКА: нельзя создать экземпляр абстрактного класса
```

---

#### **3. Интерфейсы**

**Что это?** Интерфейс — это контракт. Он определяет **"что"** должен делать класс (какие методы, свойства, события, индексаторы он должен иметь), но **не определяет "как"** (у него нет реализации). Ключевое слово — `interface`.

**Реализация интерфейсов:** Класс "реализует" интерфейс, используя двоеточие (`:`). Класс обязан предоставить реализацию *всех* членов интерфейса.

**Когда использовать?**
*   Когда вам нужно определить общее поведение для **несвязанных классов**.
*   Когда важна **множественная "наследоваемость"** (класс может реализовать много интерфейсов, но унаследоваться только от одного класса).
*   Когда вы хотите отделить контракт (что должно делать) от реализации (как это делается). Это основа многих принципов проектирования (Dependency Injection, SOLID).

**Пример: Модель "Летающих" и "Плавающих" объектов**

```csharp
// Интерфейсы
public interface IFlyable
{
    void Fly(); // Только сигнатура, нет тела метода.
    int MaxAltitude { get; } // Только сигнатура свойства.
}

public interface ISwimmable
{
    void Swim();
}

// Классы, реализующие интерфейсы
public class Airplane : IFlyable
{
    public string CallSign { get; set; }

    public void Fly()
    {
        Console.WriteLine($"{CallSign}: Самолет летит по воздуху.");
    }

    public int MaxAltitude => 12000;
}

public class Duck : IFlyable, ISwimmable // Множественная реализация!
{
    public string Name { get; set; }

    public void Fly()
    {
        Console.WriteLine($"{Name}: Утка летит, махая крыльями.");
    }

    public void Swim()
    {
        Console.WriteLine($"{Name}: Утка плавает в пруду.");
    }

    public int MaxAltitude => 1000;
}

public class Submarine : ISwimmable
{
    public void Swim()
    {
        Console.WriteLine("Подлодка плывет под водой.");
    }
}

// Использование
List<IFlyable> flyingObjects = new List<IFlyable> { new Airplane { CallSign = "AF123" }, new Duck { Name = "Дональд" } };
List<ISwimmable> swimmingObjects = new List<ISwimmable> { new Duck { Name = "Дональд" }, new Submarine() };

foreach (var flyer in flyingObjects)
{
    flyer.Fly(); // Мы знаем, что все они умеют летать, но делают это по-разному.
    Console.WriteLine($"Макс. высота: {flyer.MaxAltitude}");
}

foreach (var swimmer in swimmingObjects)
{
    swimmer.Swim(); // Все они умеют плавать, но по-разному.
}
```

---

#### **4. Сравнительный анализ: Интерфейсы vs. Абстрактные классы**

| Критерий | Абстрактный класс | Интерфейс |
| :--- | :--- | :--- |
| **Ключевое слово** | `abstract class` | `interface` |
| **Наследование** | Одиночное. Класс может наследоваться только от **одного** абстрактного класса. | Множественное. Класс может реализовать **много** интерфейсов. |
| **Реализация** | Может содержать как абстрактные члены (без реализации), так и полностью реализованные. | До C# 8.0 — только объявления членов (контракт). С C# 8.0 — возможны реализации по умолчанию. |
| **Поля (состояние)** | Может содержать поля (переменные экземпляра). | Не может содержать полей экземпляра (только статические, начиная с C# 8.0). |
| **Конструкторы** | Может иметь конструкторы (вызываются при создании производного класса). | Не может иметь конструкторов. |
| **Модификаторы доступа** | Члены могут иметь модификаторы (`public`, `protected`, `internal`, `private`). | Члены по умолчанию `public` (и не могут быть другими, кроме `public`). |

**Практическое правило: "is-a" vs "can-do"**

*   Используйте **абстрактный класс**, когда отношение с производным классом описывается как **"is-a"** (является). `Car` **is a** `Vehicle`. `Bicycle` **is a** `Vehicle`. Они являются разновидностями транспорта и разделяют общее состояние (модель, год) и поведение (запуск двигателя).
*   Используйте **интерфейс**, когда отношение описывается как **"can-do"** (может). `Airplane` **can** `IFlyable`. `Duck` **can** `IFlyable` и **can** `ISwimmable`. Это способности, которые могут быть у несвязанных объектов.

---

#### **5. Продвинутые концепции интерфейсов (C# 8.0+)**

Начиная с C# 8.0, интерфейсы эволюционировали, чтобы включать реализации по умолчанию.

**Методы по умолчанию:**
Позволяют добавлять новые методы в интерфейс, не ломая существующие классы-реализации.

```csharp
public interface ILogger
{
    // Абстрактный метод (обязательный для реализации)
    void Log(string message);

    // Метод по умолчанию (необязательный для переопределения)
    void LogError(string errorMessage)
    {
        Console.WriteLine($"ERROR: {errorMessage} [Timestamp: {DateTime.Now}]");
        // Этот метод уже имеет реализацию по умолчанию.
    }
}

public class FileLogger : ILogger
{
    // Обязаны реализовать только Log
    public void Log(string message)
    {
        File.WriteAllText("log.txt", message);
    }
    // Метод LogError не переопределен, используется версия по умолчанию.
}

public class ConsoleLogger : ILogger
{
    public void Log(string message)
    {
        Console.WriteLine(message);
    }

    // Можем переопределить метод по умолчанию, если хотим.
    public void LogError(string errorMessage)
    {
        Console.BackgroundColor = ConsoleColor.Red;
        Console.WriteLine($"ОШИБКА: {errorMessage}");
        Console.ResetColor();
    }
}
```

---

### **6. Резюме**

*   **Абстрактные классы** — это "недостроенные" классы, определяющие общую структуру и частичную реализацию для семейства тесно связанных объектов (**"is-a"**). Они поддерживают состояние (поля) и конструкторы.
*   **Интерфейсы** — это контракты, определяющие только обязанности (**"can-do"**). Они идеальны для определения поведения, которое могут разделять несвязанные классы, и поддерживают множественное наследование.
*   **Выбор:** Спросите себя: "Я хочу описать, чем объект *является* (абстрактный класс), или что он *может* делать (интерфейс)?".
*   **Современный C#:** Интерфейсы с методами по умолчанию становятся все более мощными, но это не отменяет фундаментальных различий в их назначении.

---

### **7. Контрольные вопросы**

1.  Можно ли создать экземпляр абстрактного класса или интерфейса? Объясните, почему.
2.  В чем основное семантическое различие между наследованием от абстрактного класса и реализацией интерфейса ("is-a" vs "can-do")? Приведите свои примеры.
3.  Какой механизм позволяет классу иметь несколько "родителей" в C#? Интерфейсы или абстрактные классы?
4.  Что произойдет, если класс унаследует от абстрактного класса, но не реализует все его абстрактные методы?
5.  Может ли абстрактный класс реализовывать интерфейс? Если да, должен ли он предоставлять реализацию всех методов интерфейса?
6.  **Задача на подумать:** Вы проектируете систему для зоопарка. У вас есть классы `Lion`, `Eagle`, `Shark`, `Penguin`. Создайте иерархию, используя абстрактные классы и интерфейсы, чтобы корректно отразить способности этих животных (например, летать, плавать, рычать). Обоснуйте свой выбор.