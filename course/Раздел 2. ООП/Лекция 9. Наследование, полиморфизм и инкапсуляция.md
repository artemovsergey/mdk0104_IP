# Лекция. Наследование, полиморфизм и инкапсуляция

**Цель лекции:** Понять три столпа объектно-ориентированного программирования (ООП): наследование, полиморфизм и инкапсуляцию. Научиться применять эти принципы для создания гибкой, расширяемой и поддерживаемой архитектуры приложений.

---

### **План лекции:**

1.  **Введение.** Три кита ООП.
2.  **Наследование (Inheritance).**
    *   Что такое наследование? Базовый и производный классы.
    *   Синтаксис наследования в C#. Ключевое слово `:`.
    *   Конструкторы и наследование. Ключевое слово `base`.
    *   Преимущества и недостатки наследования.
3.  **Полиморфизм (Polymorphism).**
    *   Что такое полиморфизм?
    *   Полиморфизм во время выполнения (переопределение методов).
    *   Ключевые слова `virtual` и `override`.
    *   Абстрактные классы и методы (`abstract`).
    *   Полиморфизм во время компиляции (перегрузка методов).
4.  **Инкапсуляция (Encapsulation).**
    *   Что такое инкапсуляция?
    *   Модификаторы доступа (`public`, `private`, `protected`, `internal`).
    *   Механизмы инкапсуляции: свойства, аксессоры `get`/`set`.
    *   "Умные" свойства с валидацией.
5.  **Взаимосвязь трех принципов.** Пример единой системы.
6.  **Резюме.**
7.  **Контрольные вопросы.**

---

### **1. Введение**

Объектно-ориентированное программирование стоит на трех основных принципах, которые делают код структурированным и управляемым:

*   **Наследование:** Механизм, позволяющий создавать новый класс на основе существующего, заимствуя его функциональность и расширяя ее.
*   **Полиморфизм:** Возможность объектов с одинаковой спецификацией иметь различную реализацию.
*   **Инкапсуляция:** Сокрытие внутреннего состояния объекта и деталей реализации от внешнего мира, предоставление строго определенного интерфейса для взаимодействия.

Представьте себе автомобиль:
*   **Наследование:** `Грузовик` и `ЛегковойАвтомобиль` наследуются от базового класса `Автомобиль`.
*   **Полиморфизм:** У всех `Автомобилей` есть метод `ЗавестиДвигатель()`, но для электромобиля и бензинового автомобиля он реализован по-разному.
*   **Инкапсуляция:** Вам не нужно знать, как именно работает система впрыска топлива, чтобы нажать на педаль газа. Вы используете предоставленный интерфейс (педаль).

### **2. Наследование (Inheritance)**

**Наследование** — это механизм, при котором один класс (производный, дочерний) может наследовать поля, свойства и методы другого класса (базового, родительского). Это позволяет создавать иерархии классов и повторно использовать код.

#### **Синтаксис и пример**

```csharp
// Базовый (родительский) класс
public class Transport
{
    public string Name { get; set; }
    public int MaxSpeed { get; set; }

    public void Move()
    {
        Console.WriteLine($"{Name} движется со скоростью до {MaxSpeed} км/ч.");
    }
}

// Производный (дочерний) класс
public class Car : Transport // Наследование обозначается через :
{
    public int NumberOfDoors { get; set; }

    public void Honk()
    {
        Console.WriteLine("Би-бип!");
    }
}

// Другой производный класс
public class Bicycle : Transport
{
    public bool HasGears { get; set; }
}

// Использование:
Car myCar = new Car();
myCar.Name = "Toyota";      // Свойство унаследовано от Transport
myCar.MaxSpeed = 180;       // Свойство унаследовано от Transport
myCar.NumberOfDoors = 4;    // Свое собственное свойство
myCar.Move();               // Метод унаследован от Transport -> "Toyota движется..."
myCar.Honk();               // Свой собственный метод

Bicycle myBike = new Bicycle();
myBike.Name = "Stels";
myBike.Move();              // Тот же метод, но для другого объекта -> "Stels движется..."
```

#### **Конструкторы и наследование. Ключевое слово `base`**

При создании объекта производного класса сначала вызывается конструктор базового класса. Для явного вызова конкретного конструктора базового класса используется ключевое слово `base`.

```csharp
public class Transport
{
    public string Name { get; set; }
    public int MaxSpeed { get; set; }

    // Конструктор базового класса
    public Transport(string name, int maxSpeed)
    {
        Name = name;
        MaxSpeed = maxSpeed;
        Console.WriteLine("Вызван конструктор Transport.");
    }
}

public class Car : Transport
{
    public int NumberOfDoors { get; set; }

    // Конструктор производного класса вызывает конструктор базового класса
    public Car(string name, int maxSpeed, int doors) : base(name, maxSpeed) // Вызов base(...)
    {
        NumberOfDoors = doors;
        Console.WriteLine("Вызван конструктор Car.");
    }
}

// Использование:
Car myCar = new Car("Ford", 200, 5);
// Вывод в консоли:
// Вызван конструктор Transport.
// Вызван конструктор Car.
```

#### **Преимущества и недостатки**

*   **Преимущества:**
    *   Повторное использование кода (DRY - Don't Repeat Yourself).
    *   Создание иерархий (логическая организация кода).
    *   Легкость в добавлении нового функционала в иерархию.

*   **Недостатки:**
    *   Сильная связность между классами (изменение в базовом классе может сломать все производные).
    *   Наследование может быть избыточным. Часто композиция (включение одного объекта в другой) предпочтительнее.

### **3. Полиморфизм (Polymorphism)**

**Полиморфизм** — это возможность объектов одного типа вести себя по-разному в зависимости от контекста. В C# есть два основных типа: полиморфизм во время выполнения (переопределение) и во время компиляции (перегрузка).

#### **Полиморфизм во время выполнения (Переопределение методов)**

Это возможность дочернего класса предоставить свою собственную реализацию метода, уже определенного в базовом классе.

**Ключевые слова `virtual` и `override`:**

```csharp
public class Transport
{
    public string Name { get; set; }

    // Виртуальный метод - может быть переопределен в производных классах
    public virtual void Move()
    {
        Console.WriteLine("Транспорт движется как-то.");
    }
}

public class Car : Transport
{
    // Переопределенный метод - предоставляет свою реализацию
    public override void Move()
    {
        Console.WriteLine($"{Name} едет по дороге.");
    }
}

public class Aircraft : Transport
{
    public override void Move()
    {
        Console.WriteLine($"{Name} летит в небе.");
    }
}

// Использование (самая мощная часть):
List<Transport> transports = new List<Transport>
{
    new Car { Name = "Audi" },
    new Aircraft { Name = "Boeing" },
    new Car { Name = "BMW" }
};

foreach (Transport t in transports)
{
    t.Move(); // Вызовется ПЕРЕОПРЕДЕЛЕННЫЙ метод для каждого конкретного типа
}
// Вывод:
// Audi едет по дороге.
// Boeing летит в небе.
// BMW едет по дороге.
```
**Вот это и есть полиморфизм:** Мы работаем с объектами как с базовым типом `Transport`, но вызывается реализация, характерная для их реального (дочернего) типа.

#### **Абстрактные классы и методы (`abstract`)**

Абстрактный класс — это класс, который не может быть инстанциирован (создан напрямую). Он существует только для того, чтобы быть базовым для других классов.

*   **Абстрактный метод** не имеет реализации в базовом классе и **обязан** быть переопределен в производном классе.

```csharp
public abstract class Shape // Абстрактный класс
{
    public string Name { get; set; }

    // Абстрактный метод (не имеет тела)
    public abstract double CalculateArea();

    // Обычный метод с реализацией
    public void PrintInfo()
    {
        Console.WriteLine($"Фигура: {Name}, Площадь: {CalculateArea()}");
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }

    // Реализация абстрактного метода ОБЯЗАТЕЛЬНА
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }

    public override double CalculateArea()
    {
        return Width * Height;
    }
}

// Использование:
// Shape shape = new Shape(); // ОШИБКА! Нельзя создать экземпляр абстрактного класса.

Shape circle = new Circle { Name = "Круг", Radius = 5 };
Shape rectangle = new Rectangle { Name = "Прямоугольник", Width = 4, Height = 6 };

circle.PrintInfo();    // Вызовет Circle.CalculateArea()
rectangle.PrintInfo(); // Вызовет Rectangle.CalculateArea()
```

#### **Полиморфизм во время компиляции (Перегрузка методов)**

Это возможность создать несколько методов с **одинаковым именем**, но **разными параметрами** (типом, количеством, порядком) в одном классе.

```csharp
public class Calculator
{
    // Перегрузка метода Add
    public int Add(int a, int b)
    {
        return a + b;
    }

    public double Add(double a, double b)
    {
        return a + b;
    }

    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }
}

// Использование:
Calculator calc = new Calculator();
int result1 = calc.Add(5, 10);        // Вызовется Add(int, int)
double result2 = calc.Add(3.14, 2.71); // Вызовется Add(double, double)
int result3 = calc.Add(1, 2, 3);      // Вызовется Add(int, int, int)
```

Компилятор на этапе компиляции определяет, какой именно метод нужно вызвать, основываясь на переданных аргументах.

### **4. Инкапсуляция (Encapsulation)**

**Инкапсуляция** — это принцип, согласно которому внутреннее состояние объекта скрыто от внешнего мира, и доступ к нему возможен только через строго определенный набор методов или свойств.

#### **Модификаторы доступа**

*   `private`: Доступ разрешен только внутри того же класса.
*   `protected`: Доступ разрешен внутри того же класса и в производных классах.
*   `internal`: Доступ разрешен внутри той же сборки (проекта).
*   `public`: Доступ разрешен из любого места в программе.

#### **Свойства и аксессоры**

Свойства — это основной механизм инкапсуляции в C#.

```csharp
public class BankAccount
{
    // Приватное поле (внутреннее состояние, скрытое от всех)
    private decimal _balance;
    private string _owner;

    // Публичное свойство для доступа к владельцу с валидацией в set
    public string Owner
    {
        get { return _owner; }
        set
        {
            if (string.IsNullOrWhiteSpace(value))
                throw new ArgumentException("Имя владельца не может быть пустым.");
            _owner = value;
        }
    }

    // Публичное свойство для доступа к балансу.
    // Баланс можно только читать (только get), изменить его можно только через методы.
    public decimal Balance
    {
        get { return _balance; }
        private set { _balance = value; } // set является приватным!
    }

    // Методы для управления балансом. Они инкапсулируют логику изменения.
    public void Deposit(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("Сумма депозита должна быть положительной.");

        _balance += amount;
        Console.WriteLine($"Внесено: {amount}. Новый баланс: {Balance}");
    }

    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("Сумма снятия должна быть положительной.");
        if (amount > _balance)
            throw new InvalidOperationException("Недостаточно средств на счете.");

        _balance -= amount;
        Console.WriteLine($"Снято: {amount}. Новый баланс: {Balance}");
    }

    public BankAccount(string owner, decimal initialBalance = 0)
    {
        Owner = owner; // Используем свойство для валидации
        _balance = initialBalance;
    }
}

// Использование:
BankAccount account = new BankAccount("Иван Иванов", 1000);

// account.Balance = 5000; // ОШИБКА! set является private.
Console.WriteLine(account.Balance); // Можно только читать

account.Deposit(500);  // Корректное изменение баланса через метод
// account.Withdraw(5000); // Выбросит исключение - недостаточно средств
```
**Что мы получили?**
*   Данные (`_balance`) защищены от прямого неконтролируемого изменения.
*   Вся логика (валидация, проверки) сосредоточена в одном месте.
*   Внешний код использует простой и понятный интерфейс (`Deposit`, `Withdraw`), не задумываясь о внутренней кухне.

### **5. Взаимосвязь трех принципов**

Рассмотрим пример, где все три принципа работают вместе.

```csharp
// ИНКАПСУЛЯЦИЯ: _name и _speed приватные. Работа через конструктор и метод.
// НАСЛЕДОВАНИЕ: Dog и Cat наследуются от Animal.
// ПОЛИМОРФИЗМ: метод MakeSound() - виртуальный и переопределяется.

public abstract class Animal
{
    private string _name; // Инкапсуляция
    protected int _speed; // protected для использования в наследниках

    public string Name => _name; // Только для чтения

    public Animal(string name, int speed)
    {
        _name = name;
        _speed = speed;
    }

    public virtual void MakeSound() // Полиморфизм: виртуальный метод
    {
        Console.WriteLine("Животное издает звук.");
    }

    public abstract void Move(); // Полиморфизм: абстрактный метод
}

public class Dog : Animal // Наследование
{
    public Dog(string name) : base(name, 10) { }

    public override void MakeSound() // Полиморфизм: переопределение
    {
        Console.WriteLine($"{Name} гавкает!");
    }

    public override void Move()
    {
        Console.WriteLine($"{Name} бежит со скоростью {_speed} км/ч.");
    }
}

public class Cat : Animal
{
    public Cat(string name) : base(name, 7) { }

    public override void MakeSound()
    {
        Console.WriteLine($"{Name} мяукает!");
    }

    public override void Move()
    {
        Console.WriteLine($"{Name} крадется со скоростью {_speed} км/ч.");
    }
}

// Использование:
List<Animal> zoo = new List<Animal> { new Dog("Барсик"), new Cat("Мурзик") };

foreach (var animal in zoo)
{
    animal.MakeSound(); // Полиморфизм: вызовется реализация для Dog или Cat
    animal.Move();
}
// Вывод:
// Барсик гавкает!
// Барсик бежит со скоростью 10 км/ч.
// Мурзик мяукает!
// Мурзик крадется со скоростью 7 км/ч.
```

### **6. Резюме**

*   **Наследование** позволяет создавать иерархии классов, способствуя повторному использованию кода.
*   **Полиморфизм** позволяет объектам одного типа иметь разное поведение, что делает код гибким и расширяемым. Используйте `virtual`/`override` для переопределения и создавайте методы с разными параметрами для перегрузки.
*   **Инкапсуляция** защищает внутреннее состояние объекта и обеспечивает контролируемый доступ к данным через свойства и методы. Это основа надежности и безопасности ваших классов.

Правильное сочетание этих трех принципов — залог создания качественного объектно-ориентированного ПО.

---

### **7. Контрольные вопросы**

1.  Объясните, что такое наследование, своими словами. Приведите пример из реальной жизни, не связанный с программированием.
2.  В чем разница между `virtual` и `abstract` методом? Можно ли создать экземпляр класса, содержащего абстрактный метод?
3.  Что произойдет, если в производном классе не переопределить абстрактный метод базового класса?
4.  Для чего нужно ключевое слово `base`? В каком еще контексте оно может использоваться?
5.  Объясните разницу между перегрузкой (overloading) и переопределением (overriding) методов.
6.  Какие преимущества дает использование свойств (properties) вместо публичных полей (public fields) с точки зрения инкапсуляции?
7.  Как модификатор доступа `protected` отличается от `private` и `public`?
8.  Может ли статический метод (`static`) быть виртуальным или абстрактным? Почему?
9.  Создайте иерархию классов "Сотрудник". Базовый класс `Employee` (с полями `Name`, `BaseSalary`). Производные классы `Manager` (должен иметь поле `Bonus`) и `Developer` (поле `LinesOfCode`). Реализуйте метод `CalculateSalary()`, который для менеджера будет возвращать `BaseSalary + Bonus`, а для разработчика — `BaseSalary`. Используйте полиморфизм.