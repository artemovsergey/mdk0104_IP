# Лекция 11. Основы многопоточности в .NET

**Основы многопоточности в .NET:** понимание потоков, их создание, синхронизация, проблемы параллельного программирования и практические примеры реализации многопоточных приложений.

Многопоточность — одна из ключевых концепций современного программирования. Она позволяет создавать приложения, способные одновременно выполнять несколько операций, что значительно повышает производительность и отзывчивость программ.

---

## План лекции

1. Введение в многопоточность
2. Потоки в .NET
3. Пул потоков
4. Асинхронное программирование и `Task`
5. Синхронизация потоков
6. Проблемы многопоточности
7. Практические примеры
8. Резюме
9. Контрольные вопросы

---

## 1. Введение в многопоточность

### 1.1. Понятие потока выполнения

Поток (thread) — это наименьшая единица исполнения в программе. Любое приложение в .NET всегда имеет как минимум один поток — главный, который запускает метод `Main()`.

Поток содержит следующие ключевые элементы:

* **Стек вызовов:** хранит вызовы функций и локальные переменные.
* **Регистры процессора:** хранят текущие состояния выполнения.
* **Контекст выполнения:** идентификаторы и приоритет потока.

### 1.2. Отличие процесса от потока

* **Процесс** — это экземпляр выполняемой программы, обладающий собственным адресным пространством и ресурсами.
* **Поток** — это часть процесса, которая разделяет ресурсы процесса (память, файлы) с другими потоками того же процесса.

**Пример:**

```csharp
Process.Start("notepad.exe"); // создаем новый процесс
```

Внутри процесса Notepad может выполняться несколько потоков — главный поток GUI и дополнительные для фоновых задач.

### 1.3. Преимущества многопоточности

* **Повышение производительности** за счет параллельного выполнения задач.
* **Отзывчивость интерфейса**: UI-поток не блокируется длительными операциями.
* **Эффективное использование ресурсов** современных многоядерных процессоров.

### 1.4. Примеры использования многопоточности

* Серверы обрабатывают множество запросов одновременно.
* Программы с графическим интерфейсом не «замораживаются» при долгих вычислениях.
* Научные расчеты и обработка больших массивов данных.

---

## 2. Потоки в .NET

### 2.1. Класс `Thread` и его методы

.NET предоставляет класс `Thread` для создания потоков. Основные методы:

* `Start()` — запуск потока.
* `Join()` — ожидание завершения потока.
* `Abort()` — завершение потока (устаревший, использовать не рекомендуется).

### 2.2. Создание и запуск потоков

```csharp
using System;
using System.Threading;

class Program
{
    static void Main()
    {
        Thread t = new Thread(PrintNumbers);
        t.Start(); // запускаем поток
        t.Join();  // ждем завершения
        Console.WriteLine("Главный поток завершен");
    }

    static void PrintNumbers()
    {
        for (int i = 1; i <= 5; i++)
        {
            Console.WriteLine(i);
            Thread.Sleep(500); // имитация работы
        }
    }
}
```

В этом примере поток `t` выполняет метод `PrintNumbers`, параллельно с главным потоком.

### 2.3. Потоки с параметрами

Можно передавать данные в поток через делегат `ParameterizedThreadStart`.

```csharp
Thread t = new Thread(PrintMessage);
t.Start("Привет из потока");

void PrintMessage(object message)
{
    Console.WriteLine(message);
}
```

### 2.4. Управление потоками

* **Приоритет потока**: `ThreadPriority.Lowest` … `ThreadPriority.Highest`.
* **Состояние потока**: `ThreadState.Running`, `ThreadState.WaitSleepJoin`.

```csharp
t.Priority = ThreadPriority.AboveNormal;
```

---

## 3. Пул потоков

### 3.1. Понятие пула потоков

Пул потоков — это коллекция потоков, управляемая системой. Пулы позволяют повторно использовать существующие потоки, что экономит ресурсы на создание/удаление потоков.

### 3.2. Преимущества использования пула потоков

* Экономия времени на создание потоков.
* Автоматическое управление количеством активных потоков.
* Упрощение многопоточной архитектуры.

### 3.3. Класс `ThreadPool`

```csharp
ThreadPool.QueueUserWorkItem(state =>
{
    Console.WriteLine("Выполняется в пуле потоков");
});
```

Поток автоматически выделяется из пула и выполняет задачу.

### 3.4. Примеры использования

* Обработка запросов в серверных приложениях.
* Асинхронная загрузка данных.
* Параллельные вычисления с большим количеством коротких задач.

---

## 4. Асинхронное программирование и `Task`

### 4.1. Класс `Task`

Класс `Task` позволяет описывать асинхронные операции, отличающиеся от потоков:

* `Task` может возвращать результат.
* Поддерживает цепочки задач.
* Интегрирован с `async/await`.

### 4.2. Создание задач

```csharp
Task t = Task.Run(() =>
{
    for (int i = 0; i < 5; i++)
    {
        Console.WriteLine(i);
        Thread.Sleep(300);
    }
});
t.Wait(); // ожидание завершения
```

### 4.3. Продвинутая работа с задачами

```csharp
Task<int> t1 = Task.Run(() => 10);
Task<int> t2 = Task.Run(() => 20);

Task<int[]> allTasks = Task.WhenAll(t1, t2);
int[] results = allTasks.Result; // [10, 20]

Task<Task<int>> firstTask = Task.WhenAny(t1, t2);
```

### 4.4. Асинхронные методы (`async/await`)

```csharp
async Task<int> GetDataAsync()
{
    await Task.Delay(1000);
    return 42;
}

int result = await GetDataAsync();
```

`async/await` позволяет писать асинхронный код почти как синхронный, улучшая читаемость.

---

## 5. Синхронизация потоков

### 5.1. Проблема состояния гонки

Когда несколько потоков одновременно изменяют общий ресурс, может возникнуть **race condition**:

```csharp
int counter = 0;
Thread t1 = new Thread(() => counter++);
Thread t2 = new Thread(() => counter++);
t1.Start(); t2.Start();
```

Результат может быть непредсказуемым.

### 5.2. Критические секции и блокировки

Критическая секция — участок кода, который должен выполняться только одним потоком.

### 5.3. Класс `lock`

```csharp
object locker = new object();
lock(locker)
{
    counter++;
}
```

### 5.4. `Monitor`, `Mutex`, `Semaphore`, `ReaderWriterLock`

* **Monitor**: аналог `lock` с дополнительными возможностями `Wait` и `Pulse`.
* **Mutex**: межпроцессная блокировка.
* **Semaphore**: ограничение количества потоков, которые могут одновременно выполнять код.
* **ReaderWriterLock**: оптимизация для большого числа чтений и редких записей.

---

## 6. Проблемы многопоточности

### 6.1. Deadlock

Deadlock возникает, когда два потока ждут друг друга навечно:

```csharp
lock(obj1)
{
    lock(obj2)
    {
        // работа
    }
}
```

Если другой поток делает `lock(obj2)` затем `lock(obj1)`, возникает взаимная блокировка.

### 6.2. Livelock и Starvation

* **Livelock** — потоки активно работают, но не могут завершить задачу.
* **Starvation** — поток не получает процессорное время из-за низкого приоритета.

### 6.3. Примеры предотвращения

* Избегать вложенных блокировок.
* Использовать тайм-ауты (`Monitor.TryEnter`).
* Использовать корректное проектирование очередей задач.

---

## 7. Практические примеры

### 7.1. Многопоточная обработка коллекций

```csharp
Parallel.For(0, 10, i =>
{
    Console.WriteLine($"Элемент {i} обработан потоком {Thread.CurrentThread.ManagedThreadId}");
});
```

### 7.2. Асинхронная работа с файлами

```csharp
async Task ReadFileAsync(string path)
{
    string content = await File.ReadAllTextAsync(path);
    Console.WriteLine(content);
}
```

### 7.3. Параллельные вычисления

```csharp
int[] numbers = Enumerable.Range(1, 1000).ToArray();
long sum = 0;
Parallel.ForEach(numbers, num =>
{
    Interlocked.Add(ref sum, num);
});
Console.WriteLine(sum);
```

Использование `Interlocked` предотвращает race condition при суммировании.

---

## 8. Резюме

* **Поток** — единица выполнения программы; процесс может содержать несколько потоков.
* В .NET потоки создаются через `Thread` или `Task`, либо через пул потоков (`ThreadPool`).
* Асинхронное программирование (`async/await`) упрощает работу с долгими операциями.
* Синхронизация критически важна для предотвращения конфликтов доступа к ресурсам.
* Многопоточность повышает производительность, но требует внимательного проектирования кода, чтобы избежать deadlock, race condition и других проблем.

---

## 9. Контрольные вопросы

1. Чем отличается поток от процесса?
2. Какие методы класса `Thread` позволяют управлять его выполнением?
3. В чем преимущества использования пула потоков?
4. Чем `Task` отличается от обычного потока?
5. Какие механизмы синхронизации потоков существуют в .NET?
6. Что такое race condition и как его избежать?
7. Объясните понятие deadlock и приведите пример.
8. Как асинхронные методы (`async/await`) упрощают многопоточное программирование?
