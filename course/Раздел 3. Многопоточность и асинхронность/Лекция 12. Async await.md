# Лекция 12. Async/Await в .NET

**Асинхронное программирование в .NET с использованием `async` и `await`.**

В этой лекции рассматриваются базовые и продвинутые аспекты работы с асинхронными методами в C#. Мы разберем, зачем нужен асинхронный код, как он работает «под капотом», и как эффективно использовать `Task`, `async/await` и сопутствующие конструкции для повышения отзывчивости приложений и производительности.

---

## План лекции

1. Введение в асинхронное программирование
2. Класс `Task` и его возможности
3. Основы `async/await`
4. Асинхронные методы с возвращаемым значением
5. Обработка исключений в асинхронном коде
6. Параллельное выполнение задач
7. Асинхронные потоки и `IAsyncEnumerable`
8. Лучшая практика и подводные камни
9. Практические примеры
10. Резюме
11. Контрольные вопросы

---

## 1. Введение в асинхронное программирование

Асинхронное программирование позволяет выполнять длительные операции **не блокируя основной поток выполнения программы**. Это особенно важно для:

* Графического интерфейса (UI) — чтобы окно программы оставалось отзывчивым.
* Веб-приложений — чтобы сервер мог одновременно обслуживать несколько запросов.
* Операций ввода-вывода (I/O) — файловые операции, сетевые запросы.

Традиционно, если выполнять длительные операции синхронно, программа «замораживается», что ухудшает пользовательский опыт и снижает производительность.

Пример блокирующей операции:

```csharp
string content = File.ReadAllText("data.txt");
Console.WriteLine(content);
```

Здесь главный поток будет заблокирован до окончания чтения файла.

Асинхронный подход позволяет писать код, который **ожидает результат, не блокируя поток**:

```csharp
string content = await File.ReadAllTextAsync("data.txt");
Console.WriteLine(content);
```

---

## 2. Класс `Task` и его возможности

`Task` — это объект, который представляет **асинхронную операцию**, которая может выполняться в будущем и вернуть результат.

Основные свойства и методы `Task`:

* `Task.Run` — запускает задачу в пуле потоков.
* `Task.Wait` — ожидание завершения задачи.
* `Task.Result` — получение результата задачи.
* `Task.WhenAll` и `Task.WhenAny` — работа с множеством задач.

Пример запуска задачи:

```csharp
Task t = Task.Run(() =>
{
    Thread.Sleep(1000);
    Console.WriteLine("Задача выполнена");
});
t.Wait();
```

Ключевой момент: задача может **выполняться параллельно** с другими потоками, но управлять ее завершением проще, чем с обычными потоками `Thread`.

---

## 3. Основы `async/await`

### 3.1. Синтаксис

* `async` — модификатор метода, который сообщает компилятору, что метод может содержать `await`.
* `await` — ключевое слово, которое приостанавливает выполнение метода до завершения асинхронной задачи, **не блокируя поток**.

Пример:

```csharp
async Task ExampleAsync()
{
    Console.WriteLine("Начало метода");
    await Task.Delay(1000); // имитация длительной операции
    Console.WriteLine("Конец метода");
}
```

### 3.2. Принцип работы

1. Метод запускается и выполняется синхронно до первого `await`.
2. При `await` метод приостанавливается и возвращает управление вызывающему потоку.
3. После завершения задачи метод продолжает выполнение с точки `await`.

Это позволяет, например, UI-приложениям оставаться отзывчивыми, а серверным приложениям обрабатывать множество запросов одновременно.

---

## 4. Асинхронные методы с возвращаемым значением

Метод `async` может возвращать:

* `Task` — для методов без значения.
* `Task<T>` — для методов с результатом типа `T`.

Пример:

```csharp
async Task<int> GetNumberAsync()
{
    await Task.Delay(500);
    return 42;
}

int result = await GetNumberAsync();
Console.WriteLine(result);
```

Особенность: **возврат значения происходит через `Task<T>`**, а не напрямую.

---

## 5. Обработка исключений в асинхронном коде

Асинхронные методы могут выбрасывать исключения, которые необходимо обрабатывать.

```csharp
async Task<int> DivideAsync(int a, int b)
{
    await Task.Delay(100);
    return a / b; // может выбросить DivideByZeroException
}

try
{
    int result = await DivideAsync(10, 0);
}
catch (DivideByZeroException ex)
{
    Console.WriteLine($"Ошибка: {ex.Message}");
}
```

Ключевой момент: исключения, возникшие внутри асинхронного метода, **не теряются**, их нужно перехватывать через `try/catch` при `await`.

---

## 6. Параллельное выполнение задач

Можно запускать несколько асинхронных задач одновременно и ожидать их завершения:

### 6.1. `Task.WhenAll`

```csharp
Task<int> t1 = Task.Run(() => 10);
Task<int> t2 = Task.Run(() => 20);
int[] results = await Task.WhenAll(t1, t2);
Console.WriteLine(results.Sum()); // 30
```

Все задачи запускаются параллельно, результат собирается после завершения всех.

### 6.2. `Task.WhenAny`

```csharp
Task<int> t1 = Task.Run(async () => { await Task.Delay(1000); return 1; });
Task<int> t2 = Task.Run(async () => { await Task.Delay(500); return 2; });

Task<int> first = await Task.WhenAny(t1, t2);
Console.WriteLine(first.Result); // 2, так как t2 завершилась быстрее
```

---

## 7. Асинхронные потоки и `IAsyncEnumerable`

.NET позволяет работать с асинхронными потоками данных. Ключевой интерфейс: `IAsyncEnumerable<T>`.

Пример:

```csharp
async IAsyncEnumerable<int> GetNumbersAsync()
{
    for (int i = 0; i < 5; i++)
    {
        await Task.Delay(200);
        yield return i;
    }
}

await foreach (var number in GetNumbersAsync())
{
    Console.WriteLine(number);
}
```

Преимущество: можно **обрабатывать элементы по мере готовности**, а не ждать полной загрузки всех данных.

---

## 8. Лучшая практика и подводные камни

### 8.1. Не блокировать асинхронный код

* Избегать `Task.Wait()` и `Task.Result` в асинхронных методах — это может привести к deadlock.

### 8.2. Использовать `ConfigureAwait(false)` для библиотек

```csharp
await Task.Delay(500).ConfigureAwait(false);
```

Позволяет **не возвращаться в исходный контекст** (например, UI), что повышает производительность в библиотечных методах.

### 8.3. Минимизировать накладные расходы

* Асинхронные методы имеют небольшую накладную стоимость.
* Не использовать `async/await` для очень быстрых операций без I/O.

---

## 9. Практические примеры

### 9.1. Асинхронная загрузка веб-страницы

```csharp
using HttpClient client = new HttpClient();
async Task<string> DownloadPageAsync(string url)
{
    string content = await client.GetStringAsync(url);
    return content;
}

string page = await DownloadPageAsync("https://example.com");
Console.WriteLine(page.Substring(0, 100));
```

### 9.2. Асинхронная обработка файлов

```csharp
string[] files = Directory.GetFiles("data");
Task[] tasks = files.Select(async file =>
{
    string content = await File.ReadAllTextAsync(file);
    Console.WriteLine($"{file}: {content.Length} символов");
}).ToArray();

await Task.WhenAll(tasks);
```

### 9.3. Параллельные вычисления

```csharp
async Task<long> SumArrayAsync(int[] numbers)
{
    long sum = 0;
    await Task.Run(() =>
    {
        foreach (int n in numbers)
        {
            sum += n;
        }
    });
    return sum;
}

int[] nums = Enumerable.Range(1, 1000).ToArray();
long result = await SumArrayAsync(nums);
Console.WriteLine(result);
```

---

## 10. Резюме

* `async/await` позволяет писать асинхронный код **как синхронный**, без блокировки потоков.
* Асинхронные методы могут возвращать `Task` или `Task<T>`.
* Исключения внутри асинхронных методов обрабатываются через `try/catch` при `await`.
* `Task.WhenAll` и `Task.WhenAny` позволяют работать с множеством задач параллельно.
* `IAsyncEnumerable<T>` поддерживает асинхронные потоки данных.
* Правильная практика: не блокировать асинхронный код, использовать `ConfigureAwait(false)` в библиотеках, минимизировать накладные расходы.

---

## 11. Контрольные вопросы

1. В чем основное отличие асинхронного метода от обычного?
2. Какие типы значений может возвращать метод `async`?
3. Как работает ключевое слово `await`?
4. Что такое `Task.WhenAll` и `Task.WhenAny`?
5. Как обрабатывать исключения в асинхронных методах?
6. В чем преимущества использования `IAsyncEnumerable`?
7. Почему не рекомендуется использовать `Task.Wait()` внутри асинхронных методов?
8. Что делает `ConfigureAwait(false)` и когда его использовать?
