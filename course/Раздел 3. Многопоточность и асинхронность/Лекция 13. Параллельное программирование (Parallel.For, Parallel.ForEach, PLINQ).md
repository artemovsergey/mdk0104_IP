# Лекция 13. Параллельное программирование в .NET с использованием Parallel.For, Parallel.ForEach и PLINQ.

Параллельное программирование позволяет одновременно выполнять несколько операций, эффективно используя многоядерные процессоры. В .NET существуют встроенные средства для параллельного выполнения вычислений и обработки коллекций. В этой лекции рассматриваются базовые и продвинутые возможности `Parallel` и PLINQ.

---

## План лекции

1. Введение в параллельное программирование
2. Класс `Parallel`

   * `Parallel.For`
   * `Parallel.ForEach`
   * Управление параллельными задачами
3. Сравнение `for`/`foreach` и параллельных версий
4. PLINQ (Parallel LINQ)

   * Основы PLINQ
   * Преимущества и ограничения
   * Управление уровнем параллелизма
5. Синхронизация и безопасная работа с общими ресурсами
6. Обработка ошибок в параллельных вычислениях
7. Практические примеры

   * Параллельная обработка массивов и коллекций
   * Параллельные вычисления и агрегации
   * PLINQ для фильтрации и трансформации данных
8. Лучшая практика и подводные камни
9. Резюме
10. Контрольные вопросы

---

## 1. Введение в параллельное программирование

Параллельное программирование — это стиль программирования, при котором **несколько задач выполняются одновременно**, используя несколько процессорных ядер.

Цели параллельного программирования:

* Повышение производительности CPU-интенсивных задач.
* Быстрая обработка больших коллекций данных.
* Эффективное использование ресурсов современных многоядерных систем.

Классический пример: подсчет суммы элементов массива. Синхронный код выполняет вычисления последовательно, тогда как параллельный может распределить работу между ядрами.

---

## 2. Класс `Parallel`

В .NET Framework и .NET Core существует статический класс `Parallel`, который предоставляет методы для параллельного выполнения циклов и операций.

### 2.1. `Parallel.For`

`Parallel.For` позволяет выполнять **цикл с индексами в параллельных потоках**.

**Синтаксис:**

```csharp
Parallel.For(int fromInclusive, int toExclusive, Action<int> body);
```

**Пример:**

```csharp
Parallel.For(0, 10, i =>
{
    Console.WriteLine($"Элемент {i} обработан потоком {Thread.CurrentThread.ManagedThreadId}");
});
```

Особенности:

* Цикл может выполняться на нескольких потоках одновременно.
* Порядок выполнения не гарантируется.
* Использует пул потоков `ThreadPool`, автоматически управляя количеством параллельных задач.

---

### 2.2. `Parallel.ForEach`

`Parallel.ForEach` предназначен для параллельной обработки коллекций.

**Синтаксис:**

```csharp
Parallel.ForEach(IEnumerable<T> source, Action<T> body);
```

**Пример:**

```csharp
string[] names = { "Alice", "Bob", "Charlie" };
Parallel.ForEach(names, name =>
{
    Console.WriteLine($"{name} обработан потоком {Thread.CurrentThread.ManagedThreadId}");
});
```

Особенности:

* Подходит для массивов, списков, словарей и других коллекций.
* Потоки выполняются параллельно и могут завершиться в произвольном порядке.

---

### 2.3. Управление параллельными задачами

Методы `Parallel` поддерживают дополнительный параметр `ParallelOptions`:

```csharp
ParallelOptions options = new ParallelOptions
{
    MaxDegreeOfParallelism = 4 // максимальное количество одновременно выполняемых потоков
};

Parallel.For(0, 100, options, i =>
{
    Console.WriteLine(i);
});
```

**Преимущества:**

* Контроль числа потоков.
* Возможность отмены с помощью `CancellationToken`.

---

## 3. Сравнение `for`/`foreach` и параллельных версий

| Классический `for`/`foreach` | `Parallel.For`/`Parallel.ForEach`                            |
| ---------------------------- | ------------------------------------------------------------ |
| Последовательное выполнение  | Параллельное выполнение                                      |
| Простая реализация           | Возможность ускорения на многоядерных CPU                    |
| Простая отладка              | Отладка сложнее, так как порядок выполнения не гарантируется |
| Подходит для небольших задач | Эффективно для больших объемов данных                        |

Важно: **параллельный цикл не всегда быстрее**. Если тело цикла быстрое или данные маленькие, накладные расходы на создание потоков могут превысить выигрыш.

---

## 4. PLINQ (Parallel LINQ)

PLINQ — расширение LINQ, которое позволяет **параллельно обрабатывать коллекции с использованием LINQ-запросов**.

### 4.1. Основы PLINQ

Простое преобразование LINQ в PLINQ:

```csharp
int[] numbers = Enumerable.Range(1, 1000).ToArray();
var evenNumbers = numbers.AsParallel()
                         .Where(n => n % 2 == 0)
                         .ToArray();
```

Особенности:

* `AsParallel()` превращает последовательную коллекцию в параллельную.
* Операции фильтрации, проекции и агрегации выполняются на нескольких ядрах.

---

### 4.2. Преимущества и ограничения

**Преимущества:**

* Простая интеграция с существующими LINQ-запросами.
* Автоматическое использование всех ядер процессора.
* Поддержка операций агрегации и трансформации больших массивов данных.

**Ограничения:**

* Порядок выполнения элементов не гарантируется (можно использовать `AsOrdered()`).
* PLINQ не эффективен для небольших коллекций.
* Возможны проблемы с побочными эффектами, если тело запроса модифицирует внешние ресурсы.

---

### 4.3. Управление уровнем параллелизма

```csharp
var results = numbers.AsParallel()
                     .WithDegreeOfParallelism(4)
                     .Where(n => n % 2 == 0)
                     .ToArray();
```

**Параметры:**

* `WithDegreeOfParallelism(int)` — ограничение числа одновременно выполняемых потоков.
* `WithExecutionMode(ParallelExecutionMode.ForceParallelism)` — принудительное использование параллелизма.

---

## 5. Синхронизация и безопасная работа с общими ресурсами

Параллельные операции могут обращаться к общим данным, что создаёт риск **состояний гонки (race condition)**.

Пример опасного кода:

```csharp
int sum = 0;
Parallel.For(1, 100, i =>
{
    sum += i; // race condition
});
```

Правильный способ:

```csharp
int sum = 0;
Parallel.For(1, 100, i =>
{
    Interlocked.Add(ref sum, i);
});
```

Используются следующие инструменты:

* `lock` — критическая секция.
* `Interlocked` — атомарные операции.
* `Concurrent` коллекции (`ConcurrentBag`, `ConcurrentDictionary`) для многопоточной обработки.

---

## 6. Обработка ошибок в параллельных вычислениях

Ошибки в параллельных циклах могут возникать в любом потоке. Для их обработки используется `AggregateException`:

```csharp
try
{
    Parallel.For(0, 10, i =>
    {
        if (i == 5) throw new Exception("Ошибка на 5 итерации");
    });
}
catch (AggregateException ex)
{
    foreach (var inner in ex.InnerExceptions)
    {
        Console.WriteLine(inner.Message);
    }
}
```

Особенности:

* `AggregateException` собирает все ошибки, произошедшие в потоках.
* Для каждой итерации можно перехватывать ошибки локально или глобально.

---

## 7. Практические примеры

### 7.1. Параллельная обработка массивов

```csharp
int[] numbers = Enumerable.Range(1, 20).ToArray();
Parallel.For(0, numbers.Length, i =>
{
    numbers[i] *= 2;
});
Console.WriteLine(string.Join(", ", numbers));
```

### 7.2. Параллельная агрегация с безопасной суммой

```csharp
int sum = 0;
Parallel.For(1, 1001, i =>
{
    Interlocked.Add(ref sum, i);
});
Console.WriteLine(sum);
```

### 7.3. Параллельная фильтрация с PLINQ

```csharp
int[] numbers = Enumerable.Range(1, 1000).ToArray();
var primes = numbers.AsParallel()
                    .Where(IsPrime)
                    .ToArray();

bool IsPrime(int n)
{
    if (n < 2) return false;
    for (int i = 2; i <= Math.Sqrt(n); i++)
        if (n % i == 0) return false;
    return true;
}
```

### 7.4. Обработка коллекций с `Parallel.ForEach`

```csharp
var urls = new List<string> { "https://example.com", "https://dotnet.microsoft.com" };
Parallel.ForEach(urls, url =>
{
    using var client = new HttpClient();
    var content = client.GetStringAsync(url).Result;
    Console.WriteLine($"{url}: {content.Length} символов");
});
```

---

## 8. Лучшая практика и подводные камни

* **Не использовать параллелизм для коротких задач** — накладные расходы могут превышать выгоду.
* **Использовать безопасные структуры данных** (`ConcurrentBag`, `ConcurrentDictionary`) при модификации общих ресурсов.
* **Ограничивать уровень параллелизма** через `ParallelOptions` или `WithDegreeOfParallelism`.
* **Обрабатывать исключения через `AggregateException`**.
* **Сохранять порядок элементов**, если это важно (`AsOrdered` в PLINQ).

---

## 9. Резюме

* `Parallel.For` и `Parallel.ForEach` позволяют распараллеливать циклы и коллекции.
* PLINQ интегрируется с LINQ и автоматически использует многоядерность.
* Важно контролировать доступ к общим ресурсам, чтобы избежать race condition.
* Обработка ошибок требует использования `AggregateException`.
* Параллельное программирование эффективно для **CPU-интенсивных задач**, но может быть неэффективным для небольших операций.

---

## 10. Контрольные вопросы

1. В чем отличие `Parallel.For` от обычного `for`?
2. Для чего используется `Parallel.ForEach`?
3. Как ограничить количество одновременно выполняемых потоков?
4. Что такое PLINQ и чем он полезен?
5. Как в PLINQ сохранить порядок элементов?
6. Какие структуры данных безопасны для параллельного доступа?
7. Что такое `AggregateException` и как с ним работать?
8. В каких случаях параллельное программирование может быть неэффективным?
