# Практическая работа 10. Синхронизация потоков (lock, Monitor, Mutex)

## Цель работы

* Научиться синхронизировать доступ нескольких потоков к общим ресурсам.
* Изучить три способа синхронизации: `lock`, `Monitor`, `Mutex`.
* Научиться предотвращать гонки данных (race conditions) в многопоточных приложениях.

---

## Теоретическая часть

### 1. Проблема синхронизации

Когда несколько потоков одновременно обращаются к одному ресурсу (например, к переменной или файлу), может возникнуть **гонка данных** — некорректное или непредсказуемое поведение программы.

### 2. Способы синхронизации

1. **lock**

   * Простейший способ синхронизации.
   * Блокирует кодовый участок, чтобы его одновременно выполнял только один поток.

   ```csharp
   lock(someObject)
   {
       // критическая секция
   }
   ```

2. **Monitor**

   * Более гибкий механизм, позволяет ожидать (`Wait`) и уведомлять (`Pulse`).

   ```csharp
   Monitor.Enter(someObject);
   try
   {
       // критическая секция
   }
   finally
   {
       Monitor.Exit(someObject);
   }
   ```

3. **Mutex**

   * Межпроцессная блокировка (может использоваться между разными приложениями).

   ```csharp
   Mutex mutex = new Mutex();
   mutex.WaitOne(); // захват
   // критическая секция
   mutex.ReleaseMutex(); // освобождение
   ```

---

## Практический пример

Создадим программу, где несколько потоков увеличивают общий счётчик с использованием `lock`:

```csharp
using System;
using System.Threading;

class Program
{
    static int counter = 0;
    static object lockObj = new object();

    static void IncreaseCounter()
    {
        for (int i = 0; i < 10; i++)
        {
            lock (lockObj)
            {
                counter++;
                Console.WriteLine($"{Thread.CurrentThread.Name} увеличил счётчик: {counter}");
            }
            Thread.Sleep(100);
        }
    }

    static void Main()
    {
        Thread t1 = new Thread(IncreaseCounter) { Name = "Поток 1" };
        Thread t2 = new Thread(IncreaseCounter) { Name = "Поток 2" };

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine($"Итоговый счётчик: {counter}");
    }
}
```

---

## Ход работы

1. Изучите примеры синхронизации (`lock`, `Monitor`, `Mutex`).
2. Создайте новый проект Console App (.NET).
3. Реализуйте один из вариантов задания (по номеру в журнале).
4. Сделайте скриншоты работы программы и поместите их в папку `images`.
5. Создайте `readme.md` с номером работы, вариантом и текстом задания.

---

## Варианты заданий (15 вариантов)

1. Использовать `lock` для безопасного увеличения счётчика в 2 потоках.
2. Использовать `Monitor` для увеличения счётчика в 2 потоках.
3. Использовать `Mutex` для увеличения счётчика в 2 потоках.
4. Несколько потоков выводят элементы массива, синхронизируя доступ через `lock`.
5. Два потока пишут в один файл, используя `Mutex`.
6. Реализовать очередь сообщений с синхронизацией через `Monitor`.
7. Поток считает сумму массива, другой — произведение, синхронизируя вывод через `lock`.
8. Несколько потоков добавляют элементы в список с использованием `lock`.
9. Поток 1 добавляет числа в список, поток 2 их выводит, используя `Monitor`.
10. Реализовать счетчик посещений с использованием `Mutex`.
11. Потоки выводят символы алфавита, синхронизируя через `lock`.
12. Поток записывает в файл лог событий, другой поток читает файл, используя `Mutex`.
13. Поток увеличивает баланс счета, второй уменьшает, синхронизация через `Monitor`.
14. Несколько потоков выводят числа Фибоначчи поочередно, синхронизация через `lock`.
15. Поток имитирует загрузку прогресса, другой поток выводит статус, синхронизируя через `Monitor`.

---

## Критерии оценки

| Оценка | Критерии                                                                                       |
| ------ | ---------------------------------------------------------------------------------------------- |
| 2      | Программа не запускается или нет синхронизации.                                                |
| 3      | Программа запускается, частичная синхронизация, ошибки в оформлении.                           |
| 4      | Программа корректно синхронизирована, есть скриншоты, readme оформлен.                         |
| 5      | Полная работа, корректная синхронизация, структурированный код, подсветка в readme, скриншоты. |

---

## Контрольные вопросы

1. Что такое гонка данных?
2. Как `lock` предотвращает гонки данных?
3. Чем `Monitor` отличается от `lock`?
4. Для чего нужен `Mutex`?
5. Когда предпочтительно использовать `Monitor` вместо `lock`?

---

## Структура репозитория

```
Практическая_работа_10/
│
├─ Program.cs
├─ images/
│   └─ screenshot1.png
├─ readme.md
└─ Практическая_работа_10.csproj
```

### Пример readme.md

````markdown
# Практическая работа №10
**Тема:** Синхронизация потоков (lock, Monitor, Mutex)  
**Вариант:** 3

**Задание:** Использовать `Mutex` для безопасного увеличения счётчика в 2 потоках.

```csharp
using System;
using System.Threading;

class Program
{
    static int counter = 0;
    static Mutex mutex = new Mutex();

    static void IncreaseCounter()
    {
        for (int i = 0; i < 10; i++)
        {
            mutex.WaitOne();
            counter++;
            Console.WriteLine($"{Thread.CurrentThread.Name} увеличил счётчик: {counter}");
            mutex.ReleaseMutex();
            Thread.Sleep(100);
        }
    }

    static void Main()
    {
        Thread t1 = new Thread(IncreaseCounter) { Name = "Поток 1" };
        Thread t2 = new Thread(IncreaseCounter) { Name = "Поток 2" };

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine($"Итоговый счётчик: {counter}");
    }
}
````

```