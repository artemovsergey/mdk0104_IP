# Самостоятельная работа 3. Разрешение проблем гонки данных

## Цель работы

* Научиться выявлять и предотвращать гонки данных (race conditions) в многопоточных приложениях.
* Освоить механизмы синхронизации потоков: `lock`, `Monitor`, `Mutex`.
* Понять, как обеспечить корректность данных при параллельной обработке.

---

## Теоретическая часть

### 1. Гонка данных (Race Condition)

**Гонка данных** возникает, когда два или более потоков одновременно обращаются к общему ресурсу (например, переменной, массиву, файлу) и хотя бы один поток изменяет данные. Это может привести к некорректным или непредсказуемым результатам.

### 2. Способы разрешения гонки данных

1. **lock** — блокирует кодовую секцию для одного потока:

```csharp
lock(someObject)
{
    // критическая секция
}
```

2. **Monitor** — предоставляет методы `Enter`, `Exit`, `Wait` и `Pulse`:

```csharp
Monitor.Enter(someObject);
try
{
    // критическая секция
}
finally
{
    Monitor.Exit(someObject);
}
```

3. **Mutex** — межпроцессный объект синхронизации:

```csharp
Mutex mutex = new Mutex();
mutex.WaitOne(); // захват
// критическая секция
mutex.ReleaseMutex(); // освобождение
```

4. **Interlocked** — атомарные операции с переменными:

```csharp
Interlocked.Increment(ref counter);
Interlocked.Add(ref sum, value);
```

---

## Практический пример

Программа демонстрирует гонку данных и способы её разрешения с использованием `lock`:

```csharp
using System;
using System.Threading;

class Program
{
    static int counter = 0;
    static object lockObj = new object();

    static void IncreaseCounterUnsafe()
    {
        for (int i = 0; i < 10000; i++)
        {
            counter++; // потенциальная гонка данных
        }
    }

    static void IncreaseCounterSafe()
    {
        for (int i = 0; i < 10000; i++)
        {
            lock (lockObj)
            {
                counter++; // безопасно
            }
        }
    }

    static void Main()
    {
        // Демонстрация гонки данных
        counter = 0;
        Thread t1 = new Thread(IncreaseCounterUnsafe);
        Thread t2 = new Thread(IncreaseCounterUnsafe);

        t1.Start(); t2.Start();
        t1.Join(); t2.Join();
        Console.WriteLine("Без синхронизации: " + counter);

        // Решение гонки данных
        counter = 0;
        Thread t3 = new Thread(IncreaseCounterSafe);
        Thread t4 = new Thread(IncreaseCounterSafe);

        t3.Start(); t4.Start();
        t3.Join(); t4.Join();
        Console.WriteLine("С использованием lock: " + counter);
    }
}
```

---

## Ход работы

1. Изучите теоретические материалы о гонках данных и механизмах синхронизации.
2. Создайте проект Console App (.NET).
3. Реализуйте программу, демонстрирующую гонку данных и способы её предотвращения (lock, Monitor, Mutex или Interlocked).
4. Сделайте скриншоты работы программы и поместите их в папку `images`.
5. Создайте `readme.md`, где опишите тему работы, ход выполнения и вставьте код с подсветкой.

---

## Критерии оценки

| Оценка | Критерии                                                                                                                           |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------- |
| 2      | Программа не запускается или гонка данных не продемонстрирована.                                                                   |
| 3      | Программа выполняется, но исправление гонки данных реализовано частично.                                                           |
| 4      | Программа корректно демонстрирует гонку данных и её решение, есть скриншоты, readme оформлен.                                      |
| 5      | Полная работа: гонка данных продемонстрирована и решена различными методами, структурированный код, подсветка в readme, скриншоты. |

---

## Контрольные вопросы

1. Что такое гонка данных?
2. Почему гонка данных может приводить к некорректным результатам?
3. Как работает `lock` и в чём его преимущество?
4. Чем отличается `Monitor` от `lock`?
5. Для чего используется `Mutex` и когда он предпочтителен?
6. Какие атомарные операции предоставляет `Interlocked` и как они помогают избежать гонок данных?

---

## Структура репозитория

```
Самостоятельная_работа_3/
│
├─ Program.cs
├─ images/
│   └─ screenshot1.png
├─ readme.md
└─ Самостоятельная_работа_3.csproj
```

### Пример readme.md

````markdown
# Самостоятельная работа №3
**Тема:** Разрешение проблем гонки данных

**Описание:**  
В данной работе демонстрируется гонка данных при увеличении общего счётчика несколькими потоками, а также методы её решения с использованием `lock`.

```csharp
// вставляется код программы с подсветкой
````

**Скриншоты:**
![Скриншот 1](images/screenshot1.png)

```
