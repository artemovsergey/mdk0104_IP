# Лекция 16. Конфигурирование базы данных в EF Core

### Цель лекции:

Научить студентов правильно настраивать подключение к базе данных, выбирать подходящие провайдеры, конфигурировать параметры соединения, управлять поведением контекста и оптимизировать работу EF Core с базой данных.

---

## План лекции:

1. Основные принципы конфигурирования базы данных в EF Core
2. Провайдеры баз данных и их выбор
3. Настройка строки подключения
4. Конфигурирование DbContext
5. Параметры поведения EF Core при подключении к базе данных
6. Конфигурация через Dependency Injection в ASP.NET Core
7. Логирование и диагностика запросов
8. Оптимизация работы с базой данных на уровне конфигурации
9. Практические примеры конфигурации
10. Резюме
11. Контрольные вопросы

---

## 1. Основные принципы конфигурирования базы данных в EF Core

Entity Framework Core использует **контекст базы данных (DbContext)** для взаимодействия с СУБД. Конфигурация базы данных включает:

* выбор **провайдера базы данных**;
* указание **строки подключения**;
* настройку **поведения контекста**, включая отслеживание изменений, кеширование, транзакции;
* подключение **логирования и диагностики** для отладки.

Правильная конфигурация позволяет:

* повысить производительность;
* обеспечить совместимость с конкретной СУБД;
* управлять миграциями и схемой базы данных.

---

## 2. Провайдеры баз данных и их выбор

EF Core работает с различными провайдерами, каждый из которых адаптирован под конкретную СУБД.

**Популярные провайдеры EF Core:**

| Провайдер                               | СУБД            | NuGet-пакет                             |
| --------------------------------------- | --------------- | --------------------------------------- |
| Microsoft.EntityFrameworkCore.SqlServer | SQL Server      | Microsoft.EntityFrameworkCore.SqlServer |
| Microsoft.EntityFrameworkCore.Sqlite    | SQLite          | Microsoft.EntityFrameworkCore.Sqlite    |
| Npgsql.EntityFrameworkCore.PostgreSQL   | PostgreSQL      | Npgsql.EntityFrameworkCore.PostgreSQL   |
| Pomelo.EntityFrameworkCore.MySql        | MySQL / MariaDB | Pomelo.EntityFrameworkCore.MySql        |

Выбор провайдера зависит от:

* требований проекта;
* платформы развертывания;
* возможностей СУБД.

**Пример подключения к SQL Server:**

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
{
    optionsBuilder.UseSqlServer("Server=.;Database=ShopDb;Trusted_Connection=True;");
}
```

---

## 3. Настройка строки подключения

Строка подключения содержит все параметры для подключения к базе данных: сервер, база данных, аутентификация, таймаут.

**Пример для SQL Server:**

```csharp
"Server=localhost;Database=ShopDb;User Id=sa;Password=YourPassword;TrustServerCertificate=True;"
```

**Пример для SQLite:**

```csharp
"Data Source=shop.db"
```

### Основные параметры строки подключения:

* `Server` или `Data Source` — адрес сервера или файл базы данных;
* `Database` — имя базы данных;
* `User Id` и `Password` — учетные данные для подключения;
* `Integrated Security` или `Trusted_Connection` — использовать учетную запись Windows;
* `Timeout` — максимальное время ожидания соединения;
* `Pooling` — включение или отключение пула соединений.

---

## 4. Конфигурирование DbContext

DbContext можно конфигурировать двумя способами:

### 4.1. Через метод OnConfiguring

```csharp
public class AppDbContext : DbContext
{
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("Server=.;Database=ShopDb;Trusted_Connection=True;");
        optionsBuilder.EnableSensitiveDataLogging();
    }
}
```

### 4.2. Через Dependency Injection (рекомендуемый способ в ASP.NET Core)

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<AppDbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection")));
}
```

---

## 5. Параметры поведения EF Core при подключении к базе данных

### 5.1. Отслеживание изменений (Change Tracking)

По умолчанию EF Core отслеживает все изменения объектов. Можно отключить это для повышения производительности:

```csharp
context.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
```

### 5.2. Кеширование соединений (Connection Pooling)

Для SQL Server и PostgreSQL поддерживается пул соединений. Параметры пула можно задавать в строке подключения:

```csharp
Pooling=true;Min Pool Size=5;Max Pool Size=50;
```

### 5.3. Таймаут запросов

```csharp
optionsBuilder.UseSqlServer(
    connectionString,
    sqlOptions => sqlOptions.CommandTimeout(60)
);
```

### 5.4. Работа с транзакциями

```csharp
using var transaction = context.Database.BeginTransaction();
try
{
    // операции с базой данных
    context.SaveChanges();
    transaction.Commit();
}
catch
{
    transaction.Rollback();
}
```

---

## 6. Конфигурация через Dependency Injection в ASP.NET Core

ASP.NET Core использует встроенный **DI контейнер**, что позволяет внедрять DbContext в сервисы и контроллеры.

**Пример:**

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddDbContext<AppDbContext>(options =>
        options.UseSqlServer(Configuration.GetConnectionString("DefaultConnection"))
               .EnableDetailedErrors()
               .EnableSensitiveDataLogging());
}
```

**Применение в контроллере:**

```csharp
public class ProductsController : Controller
{
    private readonly AppDbContext _context;

    public ProductsController(AppDbContext context)
    {
        _context = context;
    }

    public IActionResult Index()
    {
        var products = _context.Products.ToList();
        return View(products);
    }
}
```

---

## 7. Логирование и диагностика запросов

EF Core позволяет отслеживать выполнение SQL-запросов через встроенное логирование:

```csharp
optionsBuilder
    .UseSqlServer(connectionString)
    .LogTo(Console.WriteLine, LogLevel.Information);
```

Параметры логирования:

* `LogLevel.Information` — показывает все SQL-запросы;
* `EnableSensitiveDataLogging()` — выводит значения параметров (использовать осторожно в продакшн);
* Логирование можно интегрировать с **Serilog**, **NLog** или **Microsoft.Extensions.Logging**.

---

## 8. Оптимизация работы с базой данных на уровне конфигурации

### 8.1. Выбор подходящего провайдера

Например, для мобильных приложений лучше использовать SQLite, для высоконагруженных сервисов — SQL Server или PostgreSQL.

### 8.2. Отслеживание изменений

Использовать `AsNoTracking()` для операций только чтения.

```csharp
var products = context.Products.AsNoTracking().ToList();
```

### 8.3. Жадная загрузка (Eager Loading)

Использовать `Include()` для связанных сущностей, чтобы избежать N+1 проблем:

```csharp
var orders = context.Orders.Include(o => o.Customer).ToList();
```

### 8.4. Таймауты и пул соединений

Настраивать CommandTimeout и параметры пула для крупных проектов.

---

## 9. Практические примеры конфигурации

**Пример 1: Конфигурация для локальной SQL Server базы данных**

```csharp
services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(
        "Server=localhost;Database=ShopDb;Trusted_Connection=True;",
        sqlOptions => sqlOptions.CommandTimeout(30))
           .EnableDetailedErrors()
           .EnableSensitiveDataLogging()
           .UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking));
```

**Пример 2: Конфигурация SQLite для тестового приложения**

```csharp
services.AddDbContext<AppDbContext>(options =>
    options.UseSqlite("Data Source=shop.db")
           .EnableDetailedErrors()
           .EnableSensitiveDataLogging());
```

**Пример 3: Логирование запросов в консоль**

```csharp
optionsBuilder
    .UseSqlServer(connectionString)
    .LogTo(Console.WriteLine, LogLevel.Information)
    .EnableSensitiveDataLogging();
```

---

## 10. Резюме

Конфигурирование базы данных в EF Core — это ключевой этап, который влияет на производительность, стабильность и удобство работы с данными. Основные аспекты:

* Выбор подходящего **провайдера** базы данных;
* Настройка **строки подключения** с учетом пула соединений и таймаутов;
* Конфигурирование **DbContext**, включая отслеживание изменений и транзакции;
* Использование **Dependency Injection** для интеграции с ASP.NET Core;
* Настройка **логирования** и диагностики запросов;
* Оптимизация работы с базой данных через `AsNoTracking()`, `Include()` и другие методы.

Правильная конфигурация позволяет писать эффективный код и минимизировать ошибки при взаимодействии с СУБД.

---

## 11. Контрольные вопросы

1. Какие основные компоненты конфигурации базы данных в EF Core вы знаете?
2. Чем отличается провайдер SQL Server от SQLite в EF Core?
3. Какие параметры строки подключения наиболее важны?
4. Как отключить отслеживание изменений для повышения производительности?
5. Как настроить пул соединений и таймауты команд?
6. Чем отличается конфигурация DbContext через `OnConfiguring` и через Dependency Injection?
7. Как включить логирование SQL-запросов в EF Core?
8. В каких случаях следует использовать `AsNoTracking()`?
9. Как избежать проблемы N+1 запросов при работе с отношениями между сущностями?
10. Какие методы EF Core позволяют управлять транзакциями вручную?