# Практическая работа 23. Join, группировка, оптимизация запросов, IAsyncEnumerable и сырые SQL-запросы в EF Core

Использование **Join, группировки, оптимизации запросов, IAsyncEnumerable и сырых SQL-запросов** в **Entity Framework Core** для эффективного извлечения данных.

### Цель:

* Научиться объединять таблицы с помощью Join.
* Освоить группировку данных и агрегационные функции.
* Изучить оптимизацию запросов и асинхронное извлечение данных с IAsyncEnumerable.
* Познакомиться с выполнением **сырых SQL-запросов** через EF Core.

---

## Теоретическая часть

### 1. Join в EF Core

Join позволяет объединять данные из двух и более таблиц на основе общих ключей.

**Пример соединения один-ко-многим:**

```csharp
var query = from order in context.Orders
            join customer in context.Customers
            on order.CustomerId equals customer.Id
            select new
            {
                OrderId = order.Id,
                CustomerName = customer.FullName,
                OrderDate = order.OrderDate
            };

var result = query.ToList();
```

### 2. Группировка и агрегация

Группировка используется для объединения данных по ключу с последующим применением агрегатных функций (`Count`, `Sum`, `Average`, `Min`, `Max`).

```csharp
var query = context.Orders
                   .GroupBy(o => o.CustomerId)
                   .Select(g => new
                   {
                       CustomerId = g.Key,
                       TotalOrders = g.Count(),
                       TotalAmount = g.Sum(o => o.TotalAmount)
                   })
                   .ToList();
```

### 3. Оптимизация запросов

* Использовать **`AsNoTracking()`**, если объекты не нужно изменять.
* Выбирать только нужные колонки (`Select`).
* Использовать фильтры (`Where`) до выборки.
* Использовать `Include` для загрузки связанных данных (Eager Loading)

```csharp
var customers = context.Customers
                       .Include(c => c.Orders)
                       .Where(c => c.Orders.Any())
                       .AsNoTracking()
                       .ToList();
```

### 4. IAsyncEnumerable для потоковой выдачи

Асинхронное перечисление позволяет обрабатывать большие наборы данных по мере поступления, не загружая всё в память сразу.

```csharp
await foreach (var order in context.Orders.AsAsyncEnumerable())
{
    Console.WriteLine($"{order.Id} - {order.OrderDate}");
}
```

### 5. Сырые SQL-запросы

Можно выполнять прямые SQL-запросы, используя EF Core, что полезно для сложных операций или оптимизации.

```csharp
var products = context.Products
                      .FromSqlRaw("SELECT * FROM Products WHERE Price > {0}", 1000)
                      .ToList();
```

* **FromSqlRaw** — принимает SQL с параметрами.
* **ExecuteSqlRaw** — используется для команд INSERT/UPDATE/DELETE.

---

## Ход работы

1. Выбрать вариант задания по номеру в журнале.
2. Создать проект .NET (консольный или ASP.NET Core).
3. Создать модели данных и DbContext.
4. Реализовать Join между таблицами.
5. Использовать группировку и агрегатные функции для анализа данных.
6. Применить оптимизацию запросов через `AsNoTracking`, `Select` и `Include`.
7. Использовать IAsyncEnumerable для асинхронного перебора данных.
8. Выполнить один или несколько сырых SQL-запросов через EF Core.
9. Сделать скриншоты работы программы и поместить их в папку `images`.
10. Создать файл `readme.md` с номером работы, вариантом, текстом задания и примерами кода.
11. Сохранить проект в репозиторий.

---

## Практический пример

**Модели данных:**

```csharp
public class Customer
{
    public int Id { get; set; }
    public string FullName { get; set; }
    public ICollection<Order> Orders { get; set; }
}

public class Order
{
    public int Id { get; set; }
    public int CustomerId { get; set; }
    public Customer Customer { get; set; }
    public decimal TotalAmount { get; set; }
    public DateTime OrderDate { get; set; }
}
```

**DbContext:**

```csharp
public class ShopContext : DbContext
{
    public DbSet<Customer> Customers { get; set; }
    public DbSet<Order> Orders { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("Server=.;Database=ShopDb;Trusted_Connection=True;");
    }
}
```

**Join и группировка:**

```csharp
var customerOrders = from order in context.Orders
                     join customer in context.Customers
                     on order.CustomerId equals customer.Id
                     group order by customer.FullName into g
                     select new
                     {
                         CustomerName = g.Key,
                         TotalOrders = g.Count(),
                         TotalAmount = g.Sum(o => o.TotalAmount)
                     };

foreach (var item in customerOrders)
{
    Console.WriteLine($"{item.CustomerName}: Orders={item.TotalOrders}, Total={item.TotalAmount}");
}
```

**IAsyncEnumerable:**

```csharp
await foreach (var order in context.Orders.AsAsyncEnumerable())
{
    Console.WriteLine($"{order.Id} - {order.TotalAmount}");
}
```

**Сырый SQL-запрос:**

```csharp
var expensiveProducts = context.Products
    .FromSqlRaw("SELECT * FROM Products WHERE Price > {0}", 1000)
    .ToList();
```

---

## 15 вариантов заданий

1. Join `Customer` и `Order`, посчитать сумму заказов для каждого клиента.
2. Группировка заказов по дате с подсчетом количества заказов в день.
3. Join `Product` и `Order`, найти топ-5 дорогих товаров.
4. Использовать `AsNoTracking` для чтения всех клиентов.
5. Выбрать только Name и Email клиентов через `Select`.
6. Eager Loading: получить клиентов с их заказами.
7. IAsyncEnumerable: асинхронно вывести все заказы.
8. Сырый SQL: выбрать продукты с ценой > 500.
9. Сырый SQL: обновить цену продукта.
10. Группировка студентов по возрасту и подсчет количества.
11. Join студентов и курсов, вывести список студентов на каждом курсе.
12. Join сотрудников и проектов, вывести количество проектов на сотрудника.
13. Сырый SQL: удалить продукты с ценой < 10.
14. IAsyncEnumerable: асинхронно вывести топ заказов по сумме.
15. Оптимизация запроса: выбрать только нужные колонки с фильтром и AsNoTracking.

---

## Критерии оценки

| Оценка | Критерий                                                                                                                                 |
| ------ | ---------------------------------------------------------------------------------------------------------------------------------------- |
| 5      | Все операции выполнены корректно, Join, группировка, оптимизация, IAsyncEnumerable и сырые SQL-запросы работают, есть скриншоты и readme |
| 4      | Большинство операций выполнены, есть небольшие недочеты, есть скриншоты/readme                                                           |
| 3      | Частично выполнено, есть ошибки или отсутствуют скриншоты/readme                                                                         |
| 2      | Работа выполнена частично, основные операции не работают, нет скриншотов/readme                                                          |
| 1      | Работа не сдана или проект не запускается                                                                                                |

---

## Контрольные вопросы

1. Как реализовать Join между двумя таблицами в EF Core?
2. Какие агрегатные функции можно использовать при группировке?
3. Для чего нужен `AsNoTracking()`?
4. Как использовать `Include` для подгрузки связанных данных?
5. Чем полезен IAsyncEnumerable для больших наборов данных?
6. Как выполнять сырые SQL-запросы через EF Core?
7. Чем `FromSqlRaw` отличается от `ExecuteSqlRaw`?
8. Какие способы оптимизации запросов можно использовать в EF Core?
9. Как выбрать только нужные колонки из таблицы?
10. Какие файлы должны быть включены в репозиторий при сдаче работы?

---

## Структура репозитория

```
ПрактическаяРабота23/
│
├─ Project/                  # Проект приложения (ConsoleApp, ASP.NET Core)
│
├─ images/                   # Скриншоты работы программы и результатов запросов
│
└─ readme.md                 # Номер работы, вариант, текст задания, пример кода
```

**Пример readme.md:**

````markdown
# Практическая работа №23
## Тема: Join, группировка, оптимизация запросов, IAsyncEnumerable и сырые SQL-запросы
### Вариант 4

**Задание:** Объединить таблицы Customer и Order, посчитать сумму заказов каждого клиента, вывести асинхронно все заказы, выполнить сырый SQL-запрос для выборки дорогих продуктов.

```csharp
var customerOrders = from order in context.Orders
                     join customer in context.Customers
                     on order.CustomerId equals customer.Id
                     group order by customer.FullName into g
                     select new
                     {
                         CustomerName = g.Key,
                         TotalOrders = g.Count(),
                         TotalAmount = g.Sum(o => o.TotalAmount)
                     };

await foreach (var order in context.Orders.AsAsyncEnumerable())
{
    Console.WriteLine($"{order.Id} - {order.TotalAmount}");
}

var expensiveProducts = context.Products
    .FromSqlRaw("SELECT * FROM Products WHERE Price > {0}", 1000)
    .ToList();
````

```
