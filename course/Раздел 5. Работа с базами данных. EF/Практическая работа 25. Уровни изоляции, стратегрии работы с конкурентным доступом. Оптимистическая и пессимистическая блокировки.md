# Практическая работа 25. Уровни изоляции и стратегии работы с конкурентным доступом в EF Core

Изучение **уровней изоляции транзакций**, стратегий работы с **конкурентным доступом**, **оптимистической и пессимистической блокировки** при работе с базой данных через **Entity Framework Core**.

### Цель:

* Понять концепцию уровней изоляции транзакций.
* Освоить стратегию управления конкурентным доступом к данным.
* Научиться использовать оптимистическую и пессимистическую блокировки в EF Core.
* Практически применять транзакции и обработку конфликтов параллельного доступа.

---

## Теоретическая часть

### 1. Уровни изоляции транзакций

Уровни изоляции определяют, как параллельные транзакции видят данные и взаимодействуют друг с другом. Основные уровни:

| Уровень          | Описание                                                                      |
| ---------------- | ----------------------------------------------------------------------------- |
| Read Uncommitted | Чтение незакоммиченных данных («грязное чтение»).                             |
| Read Committed   | Чтение только закоммиченных данных. Предотвращает грязное чтение.             |
| Repeatable Read  | Запрещает другим транзакциям изменять прочитанные данные до конца транзакции. |
| Serializable     | Полная изоляция. Эмулирует последовательное выполнение транзакций.            |
| Snapshot         | Использует снимок данных на момент начала транзакции.                         |

В EF Core уровень изоляции можно установить через `TransactionScope` или метод `BeginTransaction`:

```csharp
using var transaction = await context.Database.BeginTransactionAsync(System.Data.IsolationLevel.RepeatableRead);
```

---

### 2. Конкурентный доступ к данным

Конкурентный доступ возникает, когда несколько пользователей или процессов пытаются изменить одни и те же данные одновременно. Основные проблемы:

* **Грязное чтение** (Dirty Read)
* **Неповторяющееся чтение** (Non-Repeatable Read)
* **Фантомное чтение** (Phantom Read)

---

### 3. Оптимистическая блокировка

* Предполагает, что конфликты редки.
* Проверка изменений выполняется перед коммитом.
* Используется поле версии (RowVersion/Timestamp).

Пример модели с RowVersion:

```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }

    [Timestamp]
    public byte[] RowVersion { get; set; }
}
```

Обновление с проверкой версии:

```csharp
try
{
    product.Price = 2000;
    context.SaveChanges();
}
catch (DbUpdateConcurrencyException)
{
    Console.WriteLine("Конфликт обнаружен, повторите операцию.");
}
```

---

### 4. Пессимистическая блокировка

* Предполагает, что конфликты вероятны.
* Блокирует записи на время транзакции.
* В EF Core можно использовать метод `ForUpdate` при работе с SQL Server через `FromSqlRaw` или специальные транзакции с блокировками.

Пример:

```csharp
using var transaction = await context.Database.BeginTransactionAsync();
var product = await context.Products
                           .FromSqlRaw("SELECT * FROM Products WITH (UPDLOCK) WHERE Id = {0}", 1)
                           .FirstOrDefaultAsync();
product.Price = 2500;
await context.SaveChangesAsync();
await transaction.CommitAsync();
```

---

## Ход работы

1. Выбрать вариант задания по номеру в журнале.
2. Создать проект .NET (консольный или ASP.NET Core).
3. Создать модели данных с поддержкой оптимистической блокировки (`RowVersion`).
4. Реализовать несколько параллельных транзакций, чтобы продемонстрировать конфликт.
5. Настроить уровень изоляции транзакции (`ReadCommitted`, `RepeatableRead` и т.д.).
6. Реализовать пример пессимистической блокировки через `UPDLOCK` или SQL-запрос.
7. Сделать скриншоты работы программы, фиксации конфликтов и результатов транзакций, положить их в папку `images`.
8. Создать файл `readme.md` с номером работы, вариантом, текстом задания и примерами кода.
9. Сохранить проект в репозиторий.

---

## Практический пример

**Модель Product с RowVersion:**

```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }

    [Timestamp]
    public byte[] RowVersion { get; set; }
}
```

**Оптимистическая блокировка:**

```csharp
using var context = new ShopContext();

var product = await context.Products.FirstAsync(p => p.Id == 1);
product.Price = 1800;

try
{
    await context.SaveChangesAsync();
}
catch (DbUpdateConcurrencyException)
{
    Console.WriteLine("Обнаружен конфликт обновления. Повторите операцию.");
}
```

**Пессимистическая блокировка:**

```csharp
using var transaction = await context.Database.BeginTransactionAsync();

var product = await context.Products
                           .FromSqlRaw("SELECT * FROM Products WITH (UPDLOCK) WHERE Id = {0}", 1)
                           .FirstOrDefaultAsync();

product.Price = 2000;
await context.SaveChangesAsync();
await transaction.CommitAsync();
```

---

## 15 вариантов заданий

1. Реализовать оптимистическую блокировку для сущности `Product`.
2. Демонстрация конфликта при параллельных обновлениях `Product`.
3. Использовать уровень изоляции `ReadCommitted` для транзакции.
4. Использовать уровень изоляции `RepeatableRead`.
5. Использовать уровень изоляции `Serializable`.
6. Реализовать пессимистическую блокировку для `Product` через `UPDLOCK`.
7. Создать сущность `Order` с RowVersion и оптимистической блокировкой.
8. Демонстрация конфликтов при параллельном создании заказов.
9. Реализовать транзакцию с откатом при конфликте обновления.
10. Обновить цену продукта через оптимистическую блокировку и повторить при конфликте.
11. Пессимистическая блокировка с выборкой нескольких записей.
12. Параллельная транзакция, демонстрирующая фантомное чтение при `ReadCommitted`.
13. Использовать Snapshot isolation для параллельных транзакций.
14. Обработка `DbUpdateConcurrencyException` с повторной попыткой.
15. Сравнить время выполнения оптимистической и пессимистической блокировок для нескольких записей.

---

## Критерии оценки

| Оценка | Критерий                                                                                                                                          |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------- |
| 5      | Все задания выполнены, оптимистическая и пессимистическая блокировки корректно работают, демонстрация конфликтов проведена, есть скриншоты/readme |
| 4      | Все задания выполнены с незначительными недочетами, скриншоты/readme присутствуют                                                                 |
| 3      | Работа выполнена частично, демонстрация конфликтов не полностью корректна, нет некоторых скриншотов/readme                                        |
| 2      | Работа выполнена частично, блокировки не работают, отсутствуют скриншоты/readme                                                                   |
| 1      | Работа не сдана или проект не запускается                                                                                                         |

---

## Контрольные вопросы

1. Что такое уровень изоляции транзакции и какие уровни существуют?
2. В чем разница между оптимистической и пессимистической блокировкой?
3. Как реализовать оптимистическую блокировку через EF Core?
4. Что такое RowVersion и зачем он нужен?
5. Как реализовать пессимистическую блокировку через SQL-запрос?
6. Какие проблемы решает использование транзакций при конкурентном доступе?
7. Чем отличается уровень `RepeatableRead` от `Serializable`?
8. Что такое конфликт обновления и как его обрабатывать?
9. Как использовать транзакции для нескольких операций с сохранением консистентности данных?
10. Какие файлы должны быть включены в репозиторий при сдаче работы?

---

## Структура репозитория

```
ПрактическаяРабота25/
│
├─ Project/                  # Проект приложения (ConsoleApp, ASP.NET Core)
│
├─ images/                   # Скриншоты работы программы и демонстрации блокировок
│
└─ readme.md                 # Номер работы, вариант, текст задания, пример кода
```

**Пример readme.md:**

````markdown
# Практическая работа №25
## Тема: Уровни изоляции, конкурентный доступ, оптимистическая и пессимистическая блокировки
### Вариант 2

**Задание:** Реализовать оптимистическую и пессимистическую блокировки для сущности Product. Демонстрировать конфликт при параллельных обновлениях.

```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }

    [Timestamp]
    public byte[] RowVersion { get; set; }
}
````

```csharp
// Оптимистическая блокировка
var product = await context.Products.FirstAsync(p => p.Id == 1);
product.Price = 1800;
try
{
    await context.SaveChangesAsync();
}
catch (DbUpdateConcurrencyException)
{
    Console.WriteLine("Конфликт обновления. Повторите операцию.");
}

// Пессимистическая блокировка
using var transaction = await context.Database.BeginTransactionAsync();
var productLocked = await context.Products
                                 .FromSqlRaw("SELECT * FROM Products WITH (UPDLOCK) WHERE Id = {0}", 1)
                                 .FirstOrDefaultAsync();
productLocked.Price = 2000;
await context.SaveChangesAsync();
await transaction.CommitAsync();
```

```