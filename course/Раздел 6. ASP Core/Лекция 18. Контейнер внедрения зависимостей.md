# Лекция 18. Контейнер внедрения зависимостей в ASP.NET Core

## Тема лекции

**Контейнер внедрения зависимостей (Dependency Injection, DI) в ASP.NET Core: принципы, архитектура, регистрация и использование сервисов.**

---

## План лекции

1. **Введение в Dependency Injection (DI)**

   * Определение DI
   * Проблемы без DI
   * Преимущества использования DI

2. **Принципы работы контейнера DI в ASP.NET Core**

   * IServiceCollection и IServiceProvider
   * Жизненные циклы сервисов
   * Разница между Scoped, Transient и Singleton

3. **Регистрация сервисов**

   * Регистрация интерфейсов и классов
   * Регистрация через фабрики
   * Примеры регистрации разных типов сервисов

4. **Внедрение зависимостей**

   * Конструкторное внедрение
   * Внедрение через свойства и методы
   * Примеры использования DI в контроллерах и сервисах

5. **Работа с конфигурацией и Options через DI**

   * Использование IOptions и IOptionsMonitor
   * Примеры конфигурации через appsettings.json

6. **Внедрение зависимостей в Middleware и другие компоненты**

   * Использование DI в Middleware
   * DI в Razor Pages, Tag Helpers и View Components

7. **Расширенные возможности DI**

   * Scoped сервисы и работа с HttpContext
   * Сервис-локаторы и анти-паттерны
   * Фабрики и динамическое создание сервисов

8. **Тестирование с использованием DI**

   * Подмена сервисов для unit-тестов
   * Использование mock-объектов

9. **Резюме и выводы**

10. **Контрольные вопросы**

---

## Подробное содержание лекции

### 1. Введение в Dependency Injection

Dependency Injection (DI) — это паттерн проектирования, который позволяет **вынести зависимые объекты из класса и передавать их извне**.

**Проблемы без DI:**

* Жесткая связка классов.
* Сложность тестирования.
* Трудность замены реализации.

**Преимущества DI:**

* Повышение тестируемости.
* Слабая связка компонентов.
* Централизованное управление зависимостями.

**Пример без DI:**

```csharp
public class OrderService
{
    private readonly EmailService _emailService = new EmailService();

    public void ProcessOrder(Order order)
    {
        // обработка заказа
        _emailService.SendEmail(order);
    }
}
```

Проблема: нельзя заменить EmailService на другой класс, например, для тестирования.

**Пример с DI:**

```csharp
public class OrderService
{
    private readonly IEmailService _emailService;
    
    public OrderService(IEmailService emailService)
    {
        _emailService = emailService;
    }

    public void ProcessOrder(Order order)
    {
        _emailService.SendEmail(order);
    }
}
```

Теперь можно передавать любой класс, реализующий `IEmailService`.

---

### 2. Принципы работы контейнера DI в ASP.NET Core

ASP.NET Core поставляется с **встроенным контейнером DI**, который состоит из:

* `IServiceCollection` — коллекция сервисов, регистрируемых на старте приложения.
* `IServiceProvider` — объект, который создаёт и предоставляет зарегистрированные сервисы.

**Жизненные циклы сервисов:**

1. **Transient** — создается новый экземпляр при каждом запросе.
2. **Scoped** — создается один экземпляр на HTTP-запрос.
3. **Singleton** — создается один экземпляр на всё приложение.

**Пример:**

```csharp
builder.Services.AddTransient<ITransientService, TransientService>();
builder.Services.AddScoped<IScopedService, ScopedService>();
builder.Services.AddSingleton<ISingletonService, SingletonService>();
```

**Когда использовать:**

* Transient — легкие, краткоживущие сервисы.
* Scoped — сервисы с состоянием на запрос (например, DbContext).
* Singleton — глобальные сервисы, кэш, настройки.

---

### 3. Регистрация сервисов

**Регистрация через интерфейсы и классы:**

```csharp
builder.Services.AddScoped<IProductService, ProductService>();
```

**Регистрация через фабрики:**

```csharp
builder.Services.AddSingleton<IConnection>(sp => 
    new SqlConnection(Configuration.GetConnectionString("DefaultConnection")));
```

**Регистрация конкретного экземпляра:**

```csharp
var settings = new AppSettings { Name = "MyApp" };
builder.Services.AddSingleton(settings);
```

---

### 4. Внедрение зависимостей

**Конструкторное внедрение (рекомендуемый способ):**

```csharp
public class ProductsController : Controller
{
    private readonly IProductService _service;

    public ProductsController(IProductService service)
    {
        _service = service;
    }

    public IActionResult Index()
    {
        var products = _service.GetAll();
        return View(products);
    }
}
```

**Внедрение через свойства:**

```csharp
[FromServices]
public IProductService ProductService { get; set; }
```

**Внедрение через методы:**

```csharp
public IActionResult Index([FromServices] IProductService service)
{
    var products = service.GetAll();
    return View(products);
}
```

---

### 5. Работа с конфигурацией и Options через DI

**IOptions<T> для настройки:**

```csharp
builder.Services.Configure<MySettings>(Configuration.GetSection("MySettings"));
```

**Использование в сервисе:**

```csharp
public class MyService
{
    private readonly MySettings _settings;

    public MyService(IOptions<MySettings> options)
    {
        _settings = options.Value;
    }
}
```

**IOptionsMonitor** позволяет отслеживать изменения конфигурации в реальном времени.

---

### 6. Внедрение зависимостей в Middleware и другие компоненты

**Пример Middleware с DI:**

```csharp
public class LoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<LoggingMiddleware> _logger;

    public LoggingMiddleware(RequestDelegate next, ILogger<LoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        _logger.LogInformation("Request started");
        await _next(context);
        _logger.LogInformation("Request finished");
    }
}
```

**DI в Razor Pages:**

```csharp
@inject IProductService ProductService
```

**DI в View Components и Tag Helpers** также поддерживается через конструкторное внедрение.

---

### 7. Расширенные возможности DI

**Scoped сервисы и HttpContext:**

* Scoped сервисы могут зависеть от текущего запроса, например `DbContext`.
* Нельзя использовать Scoped сервис в Singleton напрямую (это вызовет ошибку).

**Фабрики и динамическое создание сервисов:**

```csharp
builder.Services.AddTransient<IProductService>(sp =>
{
    var config = sp.GetRequiredService<IOptions<MySettings>>();
    return new ProductService(config.Value.Mode);
});
```

**Анти-паттерны:**

* Service Locator (поиск сервисов через `IServiceProvider` вручную) нарушает принцип инверсии зависимостей.

---

### 8. Тестирование с использованием DI

DI облегчает модульное тестирование:

```csharp
var mockService = new Mock<IProductService>();
var controller = new ProductsController(mockService.Object);
```

* Можно легко подменять реальные сервисы моками.
* Тесты становятся независимыми от реальной базы данных и внешних сервисов.

---

### 9. Резюме

* Dependency Injection — ключевой паттерн для слабосвязанных приложений.
* ASP.NET Core имеет встроенный контейнер DI.
* Сервисы регистрируются в `IServiceCollection` и получают через конструктор или атрибут `[FromServices]`.
* Жизненные циклы сервисов (Transient, Scoped, Singleton) определяют время жизни объектов.
* DI облегчает тестирование, конфигурацию и масштабируемость приложения.

---

### 10. Контрольные вопросы

1. Что такое Dependency Injection и какие проблемы она решает?
2. Какие жизненные циклы сервисов существуют в ASP.NET Core?
3. Чем отличается Scoped сервис от Singleton?
4. Как зарегистрировать сервис через фабрику?
5. Как использовать DI в Middleware и Razor Pages?
6. Почему Service Locator считается анти-паттерном?
7. Как DI упрощает тестирование контроллеров и сервисов?