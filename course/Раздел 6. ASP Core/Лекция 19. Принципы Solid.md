# Лекция 19. Принципы SOLID в разработке на C# и ASP.NET Core

**Принципы SOLID: основы объектно-ориентированного проектирования для создания гибких, расширяемых и сопровождаемых приложений.**

---

## План лекции

1. **Введение в SOLID**

   * История и назначение принципов
   * Важность SOLID в профессиональной разработке
   * Общие цели: расширяемость, сопровождаемость, тестируемость

2. **Принцип SRP (Single Responsibility Principle)**

   * Определение и смысл
   * Примеры нарушения SRP
   * Правильная реализация SRP на C#

3. **Принцип OCP (Open/Closed Principle)**

   * Определение и смысл
   * Наследование vs композиция
   * Примеры соблюдения OCP

4. **Принцип LSP (Liskov Substitution Principle)**

   * Определение и смысл
   * Правила замещения
   * Примеры нарушения и исправления

5. **Принцип ISP (Interface Segregation Principle)**

   * Определение и смысл
   * Много маленьких интерфейсов vs один большой
   * Примеры применения ISP

6. **Принцип DIP (Dependency Inversion Principle)**

   * Определение и смысл
   * Работа с абстракциями
   * Примеры внедрения через DI

7. **SOLID в ASP.NET Core**

   * Контроллеры, сервисы и репозитории
   * Применение принципов при проектировании веб-приложений
   * Примеры архитектурных решений

8. **Резюме и выводы**

9. **Контрольные вопросы**

---

## Подробное содержание лекции

### 1. Введение в SOLID

SOLID — это набор пяти принципов объектно-ориентированного проектирования, предложенный Робертом Мартином (Uncle Bob).

**Цель SOLID:**

* Уменьшение связности между компонентами
* Повышение гибкости и расширяемости
* Улучшение тестируемости кода

Принципы SOLID:

1. **S** — Single Responsibility Principle (SRP)
2. **O** — Open/Closed Principle (OCP)
3. **L** — Liskov Substitution Principle (LSP)
4. **I** — Interface Segregation Principle (ISP)
5. **D** — Dependency Inversion Principle (DIP)

Применение этих принципов особенно важно при разработке сложных корпоративных приложений на C# и ASP.NET Core.

---

### 2. Принцип SRP (Single Responsibility Principle)

**Определение:**
Каждый класс должен иметь **только одну причину для изменения**, то есть отвечать за одну конкретную задачу.

**Пример нарушения SRP:**

```csharp
public class OrderService
{
    public void ProcessOrder(Order order)
    {
        // обработка заказа
    }

    public void SaveToDatabase(Order order)
    {
        // сохранение заказа в БД
    }

    public void SendEmail(Order order)
    {
        // отправка уведомления клиенту
    }
}
```

Проблема: класс выполняет сразу три обязанности — обработку, сохранение и отправку уведомлений.

**Правильная реализация SRP:**

```csharp
public class OrderProcessor
{
    private readonly IOrderRepository _repository;
    private readonly IEmailService _emailService;

    public OrderProcessor(IOrderRepository repository, IEmailService emailService)
    {
        _repository = repository;
        _emailService = emailService;
    }

    public void Process(Order order)
    {
        _repository.Save(order);
        _emailService.Send(order);
    }
}
```

Теперь каждая обязанность вынесена в отдельный сервис: `IOrderRepository` и `IEmailService`.

---

### 3. Принцип OCP (Open/Closed Principle)

**Определение:**
Программные сущности должны быть **открыты для расширения, но закрыты для модификации**.

**Пример нарушения OCP:**

```csharp
public class DiscountCalculator
{
    public double Calculate(Order order)
    {
        if (order.Type == "NewCustomer")
            return order.Amount * 0.9;
        else if (order.Type == "VIP")
            return order.Amount * 0.8;
        return order.Amount;
    }
}
```

Проблема: при добавлении нового типа клиента нужно модифицировать класс.

**Правильная реализация OCP через полиморфизм:**

```csharp
public interface IDiscount
{
    double Apply(double amount);
}

public class NewCustomerDiscount : IDiscount
{
    public double Apply(double amount) => amount * 0.9;
}

public class VIPDiscount : IDiscount
{
    public double Apply(double amount) => amount * 0.8;
}

public class DiscountCalculator
{
    private readonly IDiscount _discount;

    public DiscountCalculator(IDiscount discount)
    {
        _discount = discount;
    }

    public double Calculate(double amount) => _discount.Apply(amount);
}
```

Теперь добавление нового типа скидки не требует изменения `DiscountCalculator`.

---

### 4. Принцип LSP (Liskov Substitution Principle)

**Определение:**
Объекты подкласса должны быть заменяемыми объектами базового класса без нарушения корректности программы.

**Пример нарушения LSP:**

```csharp
public class Bird
{
    public virtual void Fly() { }
}

public class Ostrich : Bird
{
    public override void Fly()
    {
        throw new NotImplementedException();
    }
}
```

Проблема: страус не умеет летать, нарушение LSP.

**Правильная реализация через интерфейсы:**

```csharp
public interface IFlyable
{
    void Fly();
}

public class Sparrow : IFlyable
{
    public void Fly() { /* летит */ }
}

public class Ostrich
{
    // не реализует IFlyable
}
```

Теперь объекты, которые не могут летать, не наследуют поведение, которое они нарушают.

---

### 5. Принцип ISP (Interface Segregation Principle)

**Определение:**
Лучше создавать несколько **узкоспециализированных интерфейсов**, чем один большой, который включает лишние методы.

**Пример нарушения ISP:**

```csharp
public interface IMachine
{
    void Print();
    void Scan();
    void Fax();
}

public class OldPrinter : IMachine
{
    public void Print() { }
    public void Scan() { throw new NotImplementedException(); }
    public void Fax() { throw new NotImplementedException(); }
}
```

Проблема: класс вынужден реализовывать ненужные методы.

**Правильная реализация ISP:**

```csharp
public interface IPrinter
{
    void Print();
}

public interface IScanner
{
    void Scan();
}

public class OldPrinter : IPrinter
{
    public void Print() { }
}
```

Теперь класс реализует только нужные интерфейсы.

---

### 6. Принцип DIP (Dependency Inversion Principle)

**Определение:**
Модули высокого уровня не должны зависеть от модулей низкого уровня. Оба должны зависеть от **абстракций**.

**Пример нарушения DIP:**

```csharp
public class OrderService
{
    private readonly EmailService _emailService = new EmailService();
}
```

Проблема: `OrderService` жестко зависит от конкретной реализации.

**Правильная реализация через абстракции и DI:**

```csharp
public class OrderService
{
    private readonly IEmailService _emailService;

    public OrderService(IEmailService emailService)
    {
        _emailService = emailService;
    }
}
```

Теперь OrderService зависит от абстракции, что повышает гибкость и тестируемость.

---

### 7. SOLID в ASP.NET Core

* **Контроллеры** должны зависеть от сервисов через DI (DIP).
* **Сервисы** должны выполнять одну обязанность (SRP).
* **Расширяемость** контроллеров и сервисов обеспечивается через абстракции (OCP).
* **Интерфейсы** должны быть узкими и специализированными (ISP).
* **Наследование и подстановки** должны соблюдаться для моделей и сервисов (LSP).

**Пример архитектуры ASP.NET Core с SOLID:**

* `IProductRepository` — интерфейс доступа к данным (SRP, DIP, ISP)
* `ProductService` — бизнес-логика, использует репозиторий через DI (SRP, DIP)
* `ProductsController` — использует ProductService через DI (SRP, DIP, OCP)

---

### 8. Резюме

* SOLID — фундаментальные принципы OOP, повышающие гибкость и тестируемость.
* SRP — один класс — одна ответственность.
* OCP — открытость для расширения, закрытость для изменения.
* LSP — подклассы должны корректно заменять базовые классы.
* ISP — много узких интерфейсов лучше одного большого.
* DIP — зависимость от абстракций, а не конкретных реализаций.
* В ASP.NET Core SOLID используется при проектировании контроллеров, сервисов, репозиториев и моделей.

---

### 9. Контрольные вопросы

1. Что такое принципы SOLID и кто их предложил?
2. Приведите пример нарушения принципа SRP.
3. Как обеспечить соблюдение OCP при добавлении новых функций?
4. В чем заключается суть LSP?
5. Почему большое количество методов в интерфейсе нарушает ISP?
6. Как DIP помогает в тестировании приложений?
7. Приведите пример применения SOLID в архитектуре ASP.NET Core.