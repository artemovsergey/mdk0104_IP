# Лекция 23. Архитектурные стили приложений в .NET

Архитектурные стили приложений в .NET: подходы к построению масштабируемых, поддерживаемых и тестируемых приложений.

---

## План лекции

1. **Введение в архитектуру приложений**

   * Понятие архитектуры программного обеспечения
   * Роль архитектуры в разработке приложений
   * Критерии выбора архитектурного стиля

2. **Монолитная архитектура**

   * Определение и структура
   * Преимущества и недостатки
   * Примеры реализации на .NET

3. **Многоуровневая (N-tier) архитектура**

   * Разделение на слои: Presentation, Business, Data
   * Взаимодействие слоев
   * Пример многослойного приложения на ASP.NET Core

4. **Сервис-ориентированная архитектура (SOA)**

   * Основные принципы SOA
   * Сервисы и их взаимодействие
   * Примеры реализации на .NET

5. **Микросервисная архитектура**

   * Отличия от SOA
   * Плюсы и минусы микросервисов
   * Примеры микросервисов на ASP.NET Core

6. **Event-driven архитектура**

   * Паттерн событийно-ориентированных систем
   * Использование сообщений и брокеров событий
   * Примеры на .NET с использованием RabbitMQ/Kafka

7. **Чистая архитектура (Clean Architecture)**

   * Принципы Роберта Мартина
   * Разделение на слои: Entities, Use Cases, Interface Adapters, Frameworks & Drivers
   * Пример реализации на ASP.NET Core

8. **Сравнение архитектурных стилей**

   * Плюсы и минусы каждого подхода
   * Когда применять монолит, микросервисы, чистую архитектуру

9. **Резюме и выводы**

10. **Контрольные вопросы**

---

## Подробное содержание лекции

### 1. Введение в архитектуру приложений

Архитектура — это **структурная организация системы**, определяющая компоненты, их взаимодействие и способы расширения.

**Цели архитектуры:**

* Масштабируемость
* Поддерживаемость
* Тестируемость
* Безопасность и отказоустойчивость

**Критерии выбора архитектуры:**

* Размер и сложность приложения
* Частота изменений и требования к расширяемости
* Командная структура и навыки разработчиков

---

### 2. Монолитная архитектура

**Определение:**
Все компоненты приложения объединены в единый процесс и развертываются вместе.

**Структура:**

* UI, Business Logic, Data Access — все в одном проекте

**Преимущества:**

* Простота разработки
* Легко развернуть на сервере

**Недостатки:**

* Сложно масштабировать
* При изменении части приложения приходится пересобирать весь монолит
* Высокая связность компонентов

**Пример на .NET:**

* ASP.NET Core MVC проект с контроллерами, сервисами и репозиториями в одном решении

---

### 3. Многоуровневая (N-tier) архитектура

**Концепция:**
Разделение приложения на логические слои:

1. **Presentation Layer** — UI и контроллеры
2. **Business Logic Layer** — бизнес-логика, сервисы
3. **Data Access Layer** — работа с базой данных

**Пример многослойного приложения на .NET:**

```csharp
// Presentation Layer
public class ProductsController : ControllerBase
{
    private readonly ProductService _service;
    public ProductsController(ProductService service) => _service = service;

    public IActionResult Get() => Ok(_service.GetAll());
}

// Business Layer
public class ProductService
{
    private readonly ProductRepository _repo;
    public ProductService(ProductRepository repo) => _repo = repo;

    public IEnumerable<Product> GetAll() => _repo.GetAll();
}

// Data Layer
public class ProductRepository
{
    public IEnumerable<Product> GetAll() => _context.Products.ToList();
}
```

**Преимущества:**

* Четкое разделение ответственности
* Легче тестировать и поддерживать

---

### 4. Сервис-ориентированная архитектура (SOA)

**Принцип SOA:**

* Приложение состоит из отдельных сервисов
* Сервисы взаимодействуют через стандартизированные протоколы (HTTP, SOAP)

**Пример:**

* `UserService` — управление пользователями
* `OrderService` — обработка заказов
* Сервисы общаются через REST API или WCF

**Плюсы:**

* Переиспользуемость
* Гибкость в развертывании

**Минусы:**

* Более сложная интеграция
* Задержки при сетевых вызовах

---

### 5. Микросервисная архитектура

**Отличие от SOA:**

* Меньшие, независимые сервисы
* Каждый микросервис разрабатывается, тестируется и развертывается отдельно

**Пример на ASP.NET Core:**

* `ProductService` — отдельный микросервис с API
* `OrderService` — отдельный микросервис
* Общение через HTTP REST или gRPC

**Плюсы:**

* Масштабируемость отдельных компонентов
* Независимое развертывание

**Минусы:**

* Управление большим количеством сервисов
* Сложность мониторинга и логирования

---

### 6. Event-driven архитектура

**Принцип:**

* Компоненты обмениваются сообщениями (events) через брокеры (RabbitMQ, Kafka)
* Компоненты реагируют на события асинхронно

**Пример на .NET:**

```csharp
// Публикация события
await _eventBus.Publish(new OrderCreatedEvent(orderId));

// Подписка
_eventBus.Subscribe<OrderCreatedEvent>(HandleOrderCreated);
```

**Плюсы:**

* Асинхронность и масштабируемость
* Слабая связность компонентов

**Минусы:**

* Сложнее отлаживать
* Требуется брокер сообщений

---

### 7. Чистая архитектура (Clean Architecture)

**Концепция Роберта Мартина:**

* Разделение приложения на слои:

1. **Entities** — бизнес-объекты
2. **Use Cases / Application** — бизнес-логика
3. **Interface Adapters** — контроллеры, репозитории, DTO
4. **Frameworks & Drivers** — база данных, UI, внешние сервисы

**Пример:**

* Контроллеры используют интерфейсы Application Layer
* Application Layer не зависит от фреймворка
* Entities не знают про инфраструктуру

**Плюсы:**

* Независимость бизнес-логики от технологий
* Легкая тестируемость
* Простое масштабирование

---

### 8. Сравнение архитектурных стилей

| Стиль              | Плюсы                           | Минусы                  | Применение                 |
| ------------------ | ------------------------------- | ----------------------- | -------------------------- |
| Монолит            | Простота разработки             | Сложно масштабировать   | Малые приложения           |
| N-tier             | Четкое разделение               | Более сложная структура | Корпоративные приложения   |
| SOA                | Переиспользуемость              | Сложная интеграция      | Средние и крупные системы  |
| Микросервисы       | Масштабируемость, независимость | Сложное управление      | Крупные приложения, облако |
| Event-driven       | Асинхронность, слабая связность | Отладка, инфраструктура | Реактивные системы         |
| Clean Architecture | Тестируемость, независимость    | Требует дисциплины      | Любые сложные приложения   |

---

### 9. Резюме

* Архитектура определяет структуру приложения, взаимодействие компонентов и способы расширения
* Выбор стиля зависит от размера приложения, требований к масштабируемости и командных навыков
* Монолит подходит для небольших проектов, микросервисы — для крупных распределённых систем
* Чистая архитектура обеспечивает тестируемость и независимость бизнес-логики
* SOA, микросервисы и event-driven подходы помогают создавать гибкие и масштабируемые решения

---

### 10. Контрольные вопросы

1. Что такое архитектура приложения и почему она важна?
2. В чем преимущества и недостатки монолитной архитектуры?
3. Какие слои выделяются в N-tier архитектуре?
4. Чем SOA отличается от микросервисов?
5. Как работает event-driven архитектура?
6. Какие слои выделяются в Clean Architecture?
7. Как выбрать подходящий архитектурный стиль для проекта на .NET?