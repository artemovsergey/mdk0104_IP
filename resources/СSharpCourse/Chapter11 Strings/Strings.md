# Работа со строками

## Строки и класс String

Довольно большое количество задач, которые могут встретиться при разработке приложений, так или иначе связано с обработкой строк - парсинг веб-страниц, поиск в тексте, какие-то аналитические задачи, связанные с извлечением нужной информации из текста и т.д. Поэтому в этом плане работе со строками уделяется особое внимание.

В языке C# строковые значения представляет тип string, а вся функциональность работы с данным типом сосредоточена в классе System.String. Собственно string является псевдонимом для класса String. Объекты этого класса представляют текст как последовательность символов Unicode. Максимальный размер объекта String может составлять в памяти 2 ГБ, или около 1 миллиарда символов.

## Создание строк

Создавать строки можно, как используя переменную типа string и присваивая ей значение, так и применяя один из конструкторов класса String:

```Csharp
string s1 = "hello";
string s2 = new String('a', 6); // результатом будет строка "aaaaaa"
string s3 = new String(new char[] { 'w', 'o', 'r', 'l', 'd' });
string s4 = new String(new char[] { 'w', 'o', 'r', 'l', 'd' }, 1, 3); // orl
 
Console.WriteLine(s1);  // hello
Console.WriteLine(s2);  // aaaaaaa
Console.WriteLine(s3);  // world
Console.WriteLine(s4);  // orl
```

Конструктор String имеет различное число версий. Так, вызов конструктора

```Csharp
new String('a', 6)
```

6 раз повторит объект из первого параметра, то есть фактически создаст строку "aaaaaa".

Еще один конструктор принимает массив символов, из которых создается строка

```Csharp
string s3 = new String(new char[] { 'w', 'o', 'r', 'l', 'd' });
```

Третий использованный выше в примере конструктор позволяет создать строку из части массива символов. Второй параметр передает начальный индекс, с которого извлкаются символы, а третий параметр указывает на количество символов:

```Csharp
string s4 = new String(new char[] { 'w', 'o', 'r', 'l', 'd' }, 1, 3); // orl
```

## Строка как набор символов

Так как строка хранит коллекцию символов, в ней определен индексатор для доступа к этим символам:

```Csharp
public char this[int index] {get;}
```

Применяя индексатор, мы можем обратиться к строке как к массиву символов и получить по индексу любой из ее символов:

```Csharp
string message = "hello";
// получаем символ
char firstChar = message[1]; // символ 'e'
Console.WriteLine(firstChar);   //e
 
Console.WriteLine(message.Length);  // длина строки  
```

Используя свойство Length, как и в обычном массиве, можно получить длину строки.

## Перебор строк

Класс String реализует интерфейс IEnumerable, благодаря чему строку можно перебрать в цикле foreach как набор объектов char. Также можно с помощью других типов циклов перебрать строку, применяя обращение к символам по индексу:

```Csharp
string message = "hello";
 
for(var i =0; i < message.Length; i++)
{
    Console.WriteLine(message[i]);
}
foreach(var ch in message)
{
    Console.WriteLine(ch);
}
```

## Сравнение строк

В отличие от других классов строки сравниваются по значению их символов, а не по ссылкам:

```Csharp
string message1 = "hello";
string message2 = "hello";
 
Console.WriteLine(message1 == message2);    // true
```

## Многострочные строки

Начиная с C# 11 с помощью трех пар двойных кавычек можно оформить многострочный текст, в том числе с применением интерполяции:

```Csharp
Print();
PrintValue("hello");
 
void Print()
{
    string text = """
              <element attr="content">
                <body>
                </body>
              </element>
              """;
    Console.WriteLine(text);
}
 
void PrintValue(string val)
{
    string text = $"""
              <element attr="content">
                <body>
                {val}
                </body>
              </element>
              """;
    //// или так 
    //string text =  $$"""
    //          <element attr="content">
    //            
    //            {{val}}
    //            
    //          </element>
    //          """;
    Console.WriteLine(text);
}
```

## Основные методы строк

Основная функциональность класса String раскрывается через его методы, среди которых можно выделить следующие:

- Compare: сравнивает две строки с учетом текущей культуры (локали) пользователя

- CompareOrdinal: сравнивает две строки без учета локали

- Contains: определяет, содержится ли подстрока в строке

- Concat: соединяет строки

- CopyTo: копирует часть строки, начиная с определенного индекса в массив

- EndsWith: определяет, совпадает ли конец строки с подстрокой

- Format: форматирует строку

- IndexOf: находит индекс первого вхождения символа или подстроки в строке

- Insert: вставляет в строку подстроку

- Join: соединяет элементы массива строк

- LastIndexOf: находит индекс последнего вхождения символа или подстроки в строке

- Replace: замещает в строке символ или подстроку другим символом или подстрокой

- Split: разделяет одну строку на массив строк

- Substring: извлекает из строки подстроку, начиная с указанной позиции

- ToLower: переводит все символы строки в нижний регистр

- ToUpper: переводит все символы строки в верхний регистр

- Trim: удаляет начальные и конечные пробелы из строки

Разберем работу этих методов.

# Операции со строками

## Объединение строк

Конкатенация строк или объединение может производиться как с помощью операции +, так и с помощью метода Concat:

```Csharp
string s1 = "hello";
string s2 = "world";
string s3 = s1 + " " + s2; // результат: строка "hello world"
string s4 = string.Concat(s3, "!!!"); // результат: строка "hello world!!!"
 
Console.WriteLine(s4);
```

Метод Concat является статическим методом класса string, принимающим в качестве параметров две строки. Также имеются другие версии метода, принимающие другое количество параметров.

Для объединения строк также может использоваться метод Join:

```Csharp
string s5 = "apple";
string s6 = "a day";
string s7 = "keeps";
string s8 = "a doctor";
string s9 = "away";
string[] values = new string[] { s5, s6, s7, s8, s9 };
 
string s10 = string.Join(" ", values);
Console.WriteLine(s10); // apple a day keeps a doctor away
```

Метод Join также является статическим. Использованная выше версия метода получает два параметра: строку-разделитель (в данном случае пробел) и массив строк, которые будут соединяться и разделяться разделителем.

## Сравнение строк

Для сравнения строк применяется статический метод Compare:

```Csharp
string s1 = "hello";
string s2 = "world";
 
int result = string.Compare(s1, s2);
if (result<0)
{
    Console.WriteLine("Строка s1 перед строкой s2");
}
else if (result > 0)
{
    Console.WriteLine("Строка s1 стоит после строки s2");
}
else
{
    Console.WriteLine("Строки s1 и s2 идентичны");
}
// результатом будет "Строка s1 перед строкой s2"
```

Данная версия метода Compare принимает две строки и возвращает число. Если первая строка по алфавиту стоит выше второй, то возвращается число меньше нуля. В противном случае возвращается число больше нуля. И третий случай - если строки равны, то возвращается число 0.

В данном случае так как символ h по алфавиту стоит выше символа w, то и первая строка будет стоять выше.

## Поиск в строке

С помощью метода IndexOf мы можем определить индекс первого вхождения отдельного символа или подстроки в строке:

```Csharp
string s1 = "hello world";
char ch = 'o';
int indexOfChar = s1.IndexOf(ch); // равно 4
Console.WriteLine(indexOfChar);
 
string substring = "wor";
int indexOfSubstring = s1.IndexOf(substring); // равно 6
Console.WriteLine(indexOfSubstring);
```

Подобным образом действует метод LastIndexOf, только находит индекс последнего вхождения символа или подстроки в строку.

Еще одна группа методов позволяет узнать начинается или заканчивается ли строка на определенную подстроку. Для этого предназначены методы StartsWith и EndsWith. Например, в массиве строк хранится список файлов, и нам надо вывести все файлы с расширением exe:

```Csharp
var files = new string[]
{
    "myapp.exe",
    "forest.jpg",
    "main.exe",
    "book.pdf",
    "river.png"
};
 
for (int i = 0; i < files.Length; i++)
{
    if (files[i].EndsWith(".exe"))
        Console.WriteLine(files[i]);
}
```

# Разделение строк

С помощью функции Split мы можем разделить строку на массив подстрок. В качестве параметра функция Split принимает массив символов или строк, которые и будут служить разделителями. Например, подсчитаем количество слов в сроке, разделив ее по пробельным символам:

```Csharp
string text = "И поэтому все так произошло";
 
string[] words = text.Split(new char[] { ' ' });
 
foreach (string s in words)
{
    Console.WriteLine(s);
}
```

Это не лучший способ разделения по пробелам, так как во входной строке у нас могло бы быть несколько подряд идущих пробелов и в итоговый массив также бы попадали пробелы, поэтому лучше использовать другую версию метода:

```Csharp
string[] words = text.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
```

Второй параметр StringSplitOptions.RemoveEmptyEntries говорит, что надо удалить все пустые подстроки.

## Обрезка строки

Для обрезки начальных или концевых символов используется функция Trim:

```Csharp
string text = " hello world ";
 
text = text.Trim(); // результат "hello world"
text = text.Trim(new char[] { 'd', 'h' }); // результат "ello worl"
```

Функция Trim без параметров обрезает начальные и конечные пробелы и возвращает обрезанную строку. Чтобы явным образом указать, какие начальные и конечные символы следует обрезать, мы можем передать в функцию массив этих символов.

Эта функция имеет частичные аналоги: функция TrimStart обрезает начальные символы, а функция TrimEnd обрезает конечные символы.

Обрезать определенную часть строки позволяет функция Substring:

```Csharp
string text = "Хороший день";
// обрезаем начиная с третьего символа
text = text.Substring(2);
// результат "роший день"
Console.WriteLine(text);
// обрезаем сначала до последних двух символов
text = text.Substring(0, text.Length - 2);
// результат "роший де"
 Console.WriteLine(text);
```

Функция Substring также возвращает обрезанную строку. В качестве параметра первая использованная версия применяет индекс, начиная с которого надо обрезать строку. Вторая версия применяет два параметра - индекс начала обрезки и длину вырезаемой части строки.

# Вставка

Для вставки одной строки в другую применяется функция Insert:

```Csharp
string text = "Хороший день";
string substring = "замечательный ";
 
text = text.Insert(8, substring);
Console.WriteLine(text);    // Хороший замечательный день
```

Первым параметром в функции Insert является индекс, по которому надо вставлять подстроку, а второй параметр - собственно подстрока.

## Удаление строк

Удалить часть строки помогает метод Remove:

```Csharp
string text = "Хороший день";
// индекс последнего символа
int ind = text.Length - 1;
// вырезаем последний символ
text = text.Remove(ind); 
Console.WriteLine(text);    // Хороший ден
 
// вырезаем первые два символа
text = text.Remove(0, 2);
Console.WriteLine(text);    // роший ден
```

Первая версия метода Remove принимает индекс в строке, начиная с которого надо удалить все символы. Вторая версия принимает еще один параметр - сколько символов надо удалить.

## Замена

Чтобы заменить один символ или подстроку на другую, применяется метод Replace:

```Csharp
string text = "хороший день";
 
text = text.Replace("хороший", "плохой");
Console.WriteLine(text);    // плохой день
 
text = text.Replace("о", "");
Console.WriteLine(text);    // плхй день
```

Во втором случае применения функции Replace строка из одного символа "о" заменяется на пустую строку, то есть фактически удаляется из текста. Подобным способом легко удалять какой-то определенный текст в строках.

## Смена регистра

Для приведения строки к верхнему и нижнему регистру используются соответственно функции ToUpper() и ToLower():

```Csharp
string hello = "Hello world!";
 
Console.WriteLine(hello.ToLower()); // hello world!
Console.WriteLine(hello.ToUpper()); // HELLO WORLD!
```

# Форматирование и интерполяция строк

## Форматирование строк

При выводе строк в консоли с помощью метода Console.WriteLine для встраивания значений в строку мы можем применять форматирование вместо конкатенации:

```Csharp
string name = "Tom";
int age = 23;
 
Console.WriteLine("Имя: {0}  Возраст: {1}", name, age);
// консольный вывод
// Имя: Tom  Возраст: 23
```

В строке "Имя: {0} Возраст: {1}" на место {0} и {1} затем будут вставляться в порядке следования значения переменныйх name и age

То же самое форматирование в строке мы можем сделать не только в методе Console.WriteLine, но и в любом месте программы с помощью метода string.Format:

```Csharp
string name = "Tom";
int age = 23;
string output = string.Format("Имя: {0}  Возраст: {1}", name, age);
Console.WriteLine(output);
```

Метод Format принимает строку с плейсхолдерами типа {0}, {1} и т.д., а также набор аргументов, которые вставляются на место данных плейсхолдеров. В итоге генерируется новая строка.

## Спецификаторы форматирования

В методе Format могут использоваться различные спецификаторы и описатели, которые позволяют настроить вывод данных. Рассмотрим основные описатели. Все используемые форматы:

C / c

Задает формат денежной единицы, указывает количество десятичных разрядов после запятой

D / d

Целочисленный формат, указывает минимальное количество цифр

E / e

Экспоненциальное представление числа, указывает количество десятичных разрядов после запятой

F / f

Формат дробных чисел с фиксированной точкой, указывает количество десятичных разрядов после запятой

G / g

Задает более короткий из двух форматов: F или E

N / n

Также задает формат дробных чисел с фиксированной точкой, определяет количество разрядов после запятой

P / p

Задает отображения знака процентов рядом с число, указывает количество десятичных разрядов после запятой

X / x

Шестнадцатеричный формат числа


## Форматирование валюты

Для форматирования валюты используется описатель "C":

```Csharp
double number = 23.7;
string result = string.Format("{0:C0}", number);
Console.WriteLine(result); // 24 р.
string result2 = string.Format("{0:C2}", number);
Console.WriteLine(result2); // 23,70 р.
```

Число после описателя указывает, сколько чисел будет использоваться после разделителя между целой и дробной частью. При выводе также добавляется обозначение денежного знака для текущей культуры компьютера. В зависимости от локализации текущей операционной системы результат может различаться. Также обратите внимание на округление в первом примере.

## Форматирование целых чисел

Для форматирования целочисленных значение применяется описатель "d":

```Csharp
int number = 23;
string result = string.Format("{0:d}", number);
Console.WriteLine(result); // 23
string result2 = string.Format("{0:d4}", number);
Console.WriteLine(result2); // 0023
```

Число после описателя указывает, сколько цифр будет в числовом значении. Если в исходном числе цифр меньше, то к нему добавляются нули.

## Форматирование дробных чисел

Для форматирования дробны чисел используется описатель F, число после которого указывает, сколько знаков будет использоваться после разделителя между целой и дробной частью. Если исходное число - целое, то к нему добавляются разделитель и нули.

```Csharp
int number = 23;
string result = string.Format("{0:f}", number);
Console.WriteLine(result); // 23,00
 
double number2 = 45.08;
string result2 = string.Format("{0:f4}", number2);
Console.WriteLine(result2); // 45,0800
 
double number3 = 25.07;
string result3 = string.Format("{0:f1}", number3);
Console.WriteLine(result3); // 25,1
```

## Формат процентов

Описатель "P" задает отображение процентов. Используемый с ним числовой спецификатор указывает, сколько знаков будет после запятой:

```Csharp
decimal number = 0.15345m;
Console.WriteLine("{0:P1}", number);// 15,3%
```

## Настраиваемые форматы

Используя знак #, можно настроить формат вывода. Например, нам надо вывести некоторое число в формате телефона +х (ххх)ххх-хх-хх:

```Csharp
long number = 19876543210;
string result = string.Format("{0:+# (###) ###-##-##}", number);
Console.WriteLine(result); // +1 (987) 654-32-10
```

## Метод ToString

Метод ToString() не только получает строковое описание объекта, но и может осуществлять форматирование. Он поддерживает те же описатели, что используются в методе Format:

```Csharp
long number = 19876543210;
Console.WriteLine(number.ToString("+# (###) ###-##-##"));// +1 (987) 654-32-10
 
double money = 24.8;
Console.WriteLine(money.ToString("C2")); // 24,80 р.
```

## Интерполяция строк

Интерполяция строк призвана упростить форматирование строк. Так, перепишем пример с выводом значений переменных в строке:

```Csharp
string name = "Tom";
int age = 23;
 
Console.WriteLine($"Имя: {name}  Возраст: {age}");
// консольный вывод
// Имя: Tom  Возраст: 23
```

Знак доллара перед строкой указывает, что будет осуществляться интерполяция строк. Внутри строки опять же используются плейсхолдеры {...}, только внутри фигурных скобок уже можно напрямую писать те выражения, которые мы хотим вывести.

Интерполяция по сути представляет более лаконичное форматирование. При этом внутри фигурных скобок мы можем указывать не только свойства, но и различные выражения языка C#:

```Csharp
int x = 8;
int y = 7;
string result = $"{x} + {y} = {x + y}";
Console.WriteLine(result); // 8 + 7 = 15
```

Также внутри фигурных скобок можно выполнять более сложные выражения, например, вызывать методы:

```Csharp
int x = 8;
int y = 7;
string result = $"{x} * {y} = {Multiply(x, y)}";
Console.WriteLine(result); // 8 * 7 = 56
 
int Multiply(int a, int b) => a * b;
```

Уже внутри строки можно применять форматирование. В этом случае мы можем применять все те же описатели, что и в методе Format. Например, выведем номер телефона в формате +x xxx-xxx-xx-xx:

```Csharp
long number = 19876543210;
Console.WriteLine($"{number:+# ### ### ## ##}"); // +1 987 654 32 10
```

Добавляем пространство до и после форматируемого вывода:

```Csharp
string name = "Tom";
int age = 23;
 
Console.WriteLine($"Имя: {name, -5} Возраст: {age}"); // пробелы после
Console.WriteLine($"Имя: {name, 5} Возраст: {age}"); // пробелы до
```

Вывод:

```
Имя: Том      Возраст: 23
Имя:      Том Возраст: 23
```

# Класс StringBuilder

Хотя класс System.String предоставляет нам широкую функциональность по работе со строками, все таки он имеет свои недостатки. Прежде всего, объект String представляет собой неизменяемую строку. Когда мы выполняем какой-нибудь метод класса String, система создает новый объект в памяти с выделением ему достаточного места. Удаление первого символа - не самая затратная операция. Однако когда подобных операций множество, а объем текста, для которого надо выполнить данные операции, также не самый маленький, то издержки при потере производительности становятся более существенными.

Чтобы выйти из этой ситуации во фреймворк .NET был добавлен новый класс StringBuilder, который находится в пространстве имен System.Text. Этот класс представляет динамическую строку.

## Создание StringBuilder

Для создания объекта StringBuilder можно использовать ряд его конструкторов. Прежде всего можно создать пустой StringBuilder:

```Csharp
using System.Text;
 
StringBuilder sb = new StringBuilder();
```

Можно сразу инициализировать объект определенной строкой:

```Csharp
StringBuilder sb = new StringBuilder("Привет мир");
```

С помощью метода ToString() мы можем получить строку, которая хранится в StringBuilder:

```Csharp
var sb = new StringBuilder("Hello World");
Console.WriteLine(sb.ToString());    //  Hello World
```

Либо можно просто передать объект StringBuilder:

```Csharp
var sb = new StringBuilder("Hello World");
Console.WriteLine(sb);    //  Hello World
```

## Длина и емкость StringBuilder

Для хранения длины строки в классе StringBuilder определенно свойство Length. Однако есть и вторая величина - емкость выделенной памяти. Это значение хранится в свойстве Capacity. Емкость - это выделенная память под объект. Установка емкости позволяет уменьшить выделения памяти и тем самым повысить производительность.

Если строка, которая передается в конструктор StringBuilder, имеет длину 16 символов или меньше, то начальная ёмкость в StringBuilder равна 16. Если начальная строка больше 16 символов, то в качестве начальной емкости StringBuilder будет использовать длину строки.

Например, посмотрим, что содержат данные свойства:

```Csharp
using System.Text;
 
StringBuilder sb = new StringBuilder("Привет мир");
Console.WriteLine($"Длина: {sb.Length}");       // Длина: 10
Console.WriteLine($"Емкость: {sb.Capacity}");   // Емкость: 16
```

Хотя в данном случае длина равна 10 символов, но реально емкость будет составлять по умолчанию 16 символов. То есть мы видим, что при создании строки StringBuilder выделяет памяти больше, чем необходимо этой строке. При увеличении строки в StringBuilder, когда количество символов превосходит начальную емкость, то емкость увеличивается в два и более раз.

Если у нас заранее известен максимальный размер объекта, то мы можем таким образом сразу задать емкость с помощью одного из конструкторов и тем самым избежать последующих издержек при дополнительном выделении памяти.

```Csharp
var sb = new StringBuilder(32);
```

StringBuilder также позволяет сразу задать строку и емкость:

```Csharp
var sb = new StringBuilder("Привет мир", 32);
```

## Операции со строками в StringBuilder

Для операций над строками класс StringBuilder определяет ряд методов:

- Append: добавляет подстроку в объект StringBuilder

- Insert: вставляет подстроку в объект StringBuilder, начиная с определенного индекса

- Remove: удаляет определенное количество символов, начиная с определенного индекса

- Replace: заменяет все вхождения определенного символа или подстроки на другой символ или подстроку

- AppendFormat: добавляет подстроку в конец объекта StringBuilder

Те  перь посмотрим на примере метода Append() использование и преимущества класса StringBuilder:

```Csharp
using System.Text;
 
var sb = new StringBuilder("Название: ");
Console.WriteLine(sb);   // Название: 
Console.WriteLine($"Длина: {sb.Length}"); // 10
Console.WriteLine($"Емкость: {sb.Capacity}"); // 16
 
sb.Append(" Руководство");
Console.WriteLine(sb);   // Название: Руководство
Console.WriteLine($"Длина: {sb.Length}"); // 22
Console.WriteLine($"Емкость: {sb.Capacity}"); // 32
 
sb.Append(" по C#");
Console.WriteLine(sb);   // Название: Руководство по C#
Console.WriteLine($"Длина: {sb.Length}"); // 28
Console.WriteLine($"Емкость: {sb.Capacity}"); // 32
```

При создании объекта StringBuilder выделяется память по умолчанию для 16 символов, так как длина начальной строки меньше 16.

Дальше применяется метод Append - этот метод добавляет к строке подстроку. Так как при объединении строк их общая длина - 22 символа - превышает начальную емкость в 16 символов, то начальная емкость удваивается - до 32 символов.

Если бы итоговая длина строки была бы больше 32 символов, то емкость расширялась бы до размера длины строки.

Далее опять применяется метод Append, однако финальная длина уже будет 28 символов, что меньше 32 символов, и дополнительная память не будет выделяться.

Используем остальные методы StringBuilder:

```Csharp
var sb = new StringBuilder("Привет мир");
sb.Append("!");
sb.Insert(7, "компьютерный ");
Console.WriteLine(sb);  // Привет компьютерный мир!
 
// заменяем слово
sb.Replace("мир", "world");
Console.WriteLine(sb);  // Привет компьютерный world!
 
// удаляем 13 символов, начиная с 7-го
sb.Remove(7, 13);
Console.WriteLine(sb);  // Привет world!
 
// получаем строку из объекта StringBuilder
string text = sb.ToString();
Console.WriteLine(text);    // Привет world!
```

Когда надо использовать класс String, а когда StringBuilder?

Microsoft рекомендует использовать класс String в следующих случаях:

- При небольшом количестве операций и изменений над строками

- При выполнении фиксированного количества операций объединения. В этом случае компилятор может объединить все операции объединения в одну

- Когда надо выполнять масштабные операции поиска при построении строки, например IndexOf или StartsWith. Класс StringBuilder не имеет подобных методов.

Класс StringBuilder рекомендуется использовать в следующих случаях:

- При неизвестном количестве операций и изменений над строками во время выполнения программы

- Когда предполагается, что приложению придется сделать множество подобных операций

# Регулярные выражения

Классы StringBuilder и String предоставляют достаточную функциональность для работы со строками. Однако .NET предлагает еще один мощный инструмент - регулярные выражения. Регулярные выражения представляют эффективный и гибкий метод по обработке больших текстов, позволяя в то же время существенно уменьшить объемы кода по сравнению с использованием стандартных операций со строками.

Основная функциональность регулярных выражений в .NET сосредоточена в пространстве имен System.Text.RegularExpressions. А центральным классом при работе с регулярными выражениями является класс Regex. Например, у нас есть некоторый текст и нам надо найти в нем все словоформы какого-нибудь слова. С классом Regex это сделать очень просто:

```Csharp
using System.Text.RegularExpressions;
 
string s = "Бык тупогуб, тупогубенький бычок, у быка губа бела была тупа";
Regex regex = new Regex(@"туп(\w*)");
MatchCollection matches = regex.Matches(s);
if (matches.Count > 0)
{
    foreach (Match match in matches)
        Console.WriteLine(match.Value);
}
else
{
    Console.WriteLine("Совпадений не найдено");
}
```

Здесь мы находим в искомой строке все словоформы слова "туп". В конструктор объекта Regex передается регулярное выражение для поиска. Далее мы разберем некоторые элементы синтаксиса регулярных выражений, а пока достаточно знать, что выражение туп(\w*) обозначает, найти все слова, которые имеют корень "туп" и после которого может стоять различное количество символов. Выражение \w означает алфавитно-цифровой символ, а звездочка после выражения указывает на неопределенное их количество - их может быть один, два, три или вообще не быть.

Метод Matches класса Regex принимает строку, к которой надо применить регулярные выражения, и возвращает коллекцию найденных совпадений.

Каждый элемент такой коллекции представляет объект Match. Его свойство Value возвращает найденное совпадение.

И в данном случае мы получим следующий консольный вывод

```
тупогуб
тупогубенький
тупа
```

## Параметр RegexOptions

Класс Regex имеет ряд конструкторов, позволяющих выполнить начальную инициализацию объекта. Две версии конструкторов в качестве одного из параметров принимают перечисление RegexOptions. Некоторые из значений, принимаемых данным перечислением:

- Compiled: при установке этого значения регулярное выражение компилируется в сборку, что обеспечивает более быстрое выполнение

- CultureInvariant: при установке этого значения будут игнорироваться региональные различия

- IgnoreCase: при установке этого значения будет игнорироваться регистр

- IgnorePatternWhitespace: удаляет из строки пробелы и разрешает комментарии, начинающиеся со знака #

- Multiline: указывает, что текст надо рассматривать в многострочном режиме. При таком режиме символы "^" и "$" совпадают, соответственно, с началом и концом любой строки, а не с началом и концом всего текста

- RightToLeft: приписывает читать строку справа налево

- Singleline: при данном режиме символ "." соответствует любому символу, в том числе последовательности "\n", которая осуществляет переход на следующую строку

Например:

```Csharp
Regex regex = new Regex(@"туп(\w*)", RegexOptions.IgnoreCase);
```

При необходимости можно установить несколько параметров:

```Csharp
Regex regex = new Regex(@"туп(\w*)", RegexOptions.Compiled | RegexOptions.IgnoreCase);
```

## Синтаксис регулярных выражений

Рассмотрим вкратце некоторые элементы синтаксиса регулярных выражений:

- ^: соответствие должно начинаться в начале строки (например, выражение @"^пр\w*" соответствует слову "привет" в строке "привет мир")

- $: конец строки (например, выражение @"\w*ир$" соответствует слову "мир" в строке "привет мир", так как часть "ир" находится в самом конце)

- .: знак точки определяет любой одиночный символ (например, выражение "м.р" соответствует слову "мир" или "мор")

- *: предыдущий символ повторяется 0 и более раз

- +: предыдущий символ повторяется 1 и более раз

- ?: предыдущий символ повторяется 0 или 1 раз

- \s: соответствует любому пробельному символу

- \S: соответствует любому символу, не являющемуся пробелом

- \w: соответствует любому алфавитно-цифровому символу

- \W: соответствует любому не алфавитно-цифровому символу

- \d: соответствует любой десятичной цифре

- \D : соответствует любому символу, не являющемуся десятичной цифрой

Это только небольшая часть элементов. Более подробное описание синтаксиса регулярных выражений можно найти на msdn в статье Элементы языка регулярных выражений — краткий справочник.

Теперь посмотрим на некоторые примеры использования. Возьмем первый пример с скороговоркой "Бык тупогуб, тупогубенький бычок, у быка губа бела была тупа" и найдем в ней все слова, где встречается корень "губ":

```Csharp
string s = "Бык тупогуб, тупогубенький бычок, у быка губа бела была тупа";
Regex regex = new Regex(@"\w*губ\w*");
```

Так как выражение \w* соответствует любой последовательности алфавитно-цифровых символов любой длины, то данное выражение найдет все слова, содержащие корень "губ".

Второй простенький пример - нахождение телефонного номера в формате 111-111-1111:

```Csharp
string s = "456-435-2318";
Regex regex = new Regex(@"\d{3}-\d{3}-\d{4}");
```

Если мы точно знаем, сколько определенных символов должно быть, то мы можем явным образом указать их количество в фигурных скобках: \d{3} - то есть в данном случае три цифры.

Мы можем не только задать поиск по определенным типам символов - пробелы, цифры, но и задать конкретные символы, которые должны входить в регулярное выражение. Например, перепишем пример с номером телефона и явно укажем, какие символы там должны быть:

```Csharp
string s = "456-435-2318";
Regex regex = new Regex("[0-9]{3}-[0-9]{3}-[0-9]{4}");
```

В квадратных скобках задается диапазон символов, которые должны в данном месте встречаться. В итоге данный и предыдущий шаблоны телефонного номера будут эквивалентны.

Также можно задать диапазон для алфавитных символов: Regex regex = new Regex("[a-v]{5}"); - данное выражение будет соответствовать любому сочетанию пяти символов, в котором все символы находятся в диапазоне от a до v.

Можно также указать отдельные значения: Regex regex = new Regex(@"[2]*-[0-9]{3}-\d{4}");. Это выражение будет соответствовать, например, такому номеру телефона "222-222-2222" (так как первые числа двойки)

С помощью операции | можно задать альтернативные символы, например:

```Csharp
Regex regex = new Regex(@"(2|3){3}-[0-9]{3}-\d{4}");
```

То есть первые три цифры могут содержать только двойки или тройки. Такой шаблон будет соответствовать, например, строкам "222-222-2222" и "323-435-2318". А вот строка "235-435-2318" уже не подпадает под шаблон, так как одной из трех первых цифр является цифра 5.

Итак, у нас такие символы, как *, + и ряд других используются в качестве специальных символов. И возникает вопрос, а что делать, если нам надо найти, строки, где содержится точка, звездочка или какой-то другой специальный символ? В этом случае нам надо просто экранировать эти символы слешем:

```Csharp
Regex regex = new Regex(@"(2|3){3}\.[0-9]{3}\.\d{4}");
// этому выражению будет соответствовать строка "222.222.2222"
```

## Проверка на соответствие строки формату

Нередко возникает задача проверить корректность данных, введенных пользователем. Это может быть проверка электронного адреса, номера телефона, Класс Regex предоставляет статический метод IsMatch, который позволяет проверить входную строку с шаблоном на соответствие:

```Csharp
using System.Text.RegularExpressions;
 
string pattern = @"^(?("")(""[^""]+?""@)|(([0-9a-z]((\.(?!\.))|[-!#\$%&'\*\+/=\?\^`\{\}\|~\w])*)(?<=[0-9a-z])@))" +
                @"(?(\[)(\[(\d{1,3}\.){3}\d{1,3}\])|(([0-9a-z][-\w]*[0-9a-z]*\.)+[a-z0-9]{2,17}))$";
var data = new string[]
{
    "tom@gmail.com",
    "+12345678999",
    "bob@yahoo.com",
    "+13435465566",
    "sam@yandex.ru",
    "+43743989393"
};
 
Console.WriteLine("Email List");
for(int i = 0; i < data.Length; i++)
{
    if (Regex.IsMatch(data[i], pattern, RegexOptions.IgnoreCase))
    {
        Console.WriteLine(data[i]);
    }
}
```

Переменная pattern задает регулярное выражение для проверки адреса электронной почты. Данное выражение предлагает нам Microsoft на страницах msdn.

Далее в цикле мы проходим по массиву строк и определяем, какие строки соответствуют этому шаблону, то есть представляют валидный адрес электронной почты. Для проверки соответствия строки шаблону используется метод IsMatch: Regex.IsMatch(data[i], pattern, RegexOptions.IgnoreCase). Последний параметр указывает, что регистр можно игнорировать. И если строка соответствует шаблону, то метод возвращает true.

## Замена и метод Replace

Класс Regex имеет метод Replace, который позволяет заменить строку, соответствующую регулярному выражению, другой строкой:

```Csharp
string text = "Мама  мыла  раму. ";
string pattern = @"\s+";
string target = " ";
Regex regex = new Regex(pattern);
string result = regex.Replace(text, target);
Console.WriteLine(result);
```

Данная версия метода Replace принимает два параметра: строку с текстом, где надо выполнить замену, и сама строка замены. Так как в качестве шаблона выбрано выражение "\s+ (то есть наличие одного и более пробелов), метод Replace проходит по всему тексту и заменяет несколько подряд идущих пробелов ординарными.

Другой пример - на вход подается номер телефона в произвольном формате, и мы хотим оставить в нем только цифры:

```Csharp
string phoneNumber = "+1(876)-234-12-98";
string pattern = @"\D";
string target = "";
Regex regex = new Regex(pattern);
string result = regex.Replace(phoneNumber, target);
Console.WriteLine(result);  // 18762341298
```

В данном случае шаблон "\D" представляет любой символ, который не является цифрой. Любой такой символ заменяется на пустую строку "", то есть в итоге из строки "+1(876)-234-12-98" мы получим строку "18762341298".