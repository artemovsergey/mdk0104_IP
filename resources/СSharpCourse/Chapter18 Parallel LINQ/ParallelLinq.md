# Parallel LINQ

# Введение в Parallel LINQ. Метод AsParallel

По умолчанию все элементы коллекции в LINQ обрабатываются последовательно, но начиная с .NET 4.0 в пространство имен System.Linq был добавлен класс ParallelEnumerable, который инкапсулирует функциональность PLINQ (Parallel LINQ) и позволяет выполнять обращения к коллекции в параллельном режиме.

При обработке коллекции PLINQ использует возможности всех процессоров в системе. Источник данных разделяется на сегменты, и каждый сегмент обрабатывается в отдельном потоке. Это позволяет произвести запрос на многоядерных машинах намного быстрее.

В то же время по умолчанию PLINQ выбирает последовательную обработку данных. Переход к параллельной обработке осуществляется в том случае, если это приведет к ускорению работы. Однако, как правило, при параллельных операциях возрастают дополнительные издержки. Поэтому если параллельная обработка потенциально требует больших затрат ресурсов, то PLINK в этом случае может выбрать последовательную обработку, если она не требует больших затрат ресурсов.

Поэтому смысл применения PLINQ имеется преимущественно на больших коллекциях или при сложных операциях, где действительно выгода от распараллеливания запросов может перекрыть возникающие при этом издержки.

Также следует учитывать, что при доступе к общему разделяемому состоянию в параллельных операциях будет неявно использоваться синхронизация, чтобы избежать взаимоблокировки доступа к этим общим ресурсам. Затраты на синхронизацию ведут к снижению производительности, поэтому желательно избегать или ограничивать применения в параллельных операциях разделяемых ресурсов.

## Метод AsParallel
Метод AsParallel() позволяет распараллелить запрос к источнику данных. Он реализован как метод расширения LINQ у массивов и коллекций. При вызове данного метода источник данных разделяется на части (если это возможно) и над каждой частью отдельно производятся операции.

Рассмотрим простейший пример нахождения квадратов чисел:

```Csharp
int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, };
var squares = from n in numbers.AsParallel()
                 select Square(n);

foreach (var n in squares)
    Console.WriteLine(n);

int Square(int n) => n * n;
```
Фактически здесь обычный запрос LINQ, только к источнику данных применяется метод AsParallel.

Результат работы программы говорит о том, что данные выбирались для нахождения квадратов не последовательно. То есть произошло распараллеливание работы программы:

```
49
1
9
25
64
4
16
36
```
Аналогичная операция с помощью методов расширения:

```Csharp
var squares = numbers.AsParallel().Select(x => Square(x));
```

## Метод ForAll
Выше рассмотренный код по вычислению квадрата числа можно еще больше оптимизировать с точки зрения параллелизации. В частности, для вывода результата параллельной операции используется цикл foreach. Но его использование приводит к увеличению издержек - необходимо склеить полученные в разных потоках данные в один набор и затем их перебрать в цикле. Более оптимально в данном случае было бы использование метода ForAll(), который выводит данные в том же потоке, в котором они обрабатываются:

```Csharp
int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, };

// с помощью операторов LINQ
(from n in numbers.AsParallel() select Square(n)).ForAll(Console.WriteLine);

// с помощью методов расширения LINQ
numbers.AsParallel().Select(n => Square(n)).ForAll(Console.WriteLine);

int Square(int n) => n * n;
```

Метод ForAll() в качестве параметра принимает делегат Action, который указывает на выполняемое действие.

# Метод AsOrdered

При выполнении параллельного запроса порядок данных в результирующей выборки может быть не предсказуем. Например:

```Csharp
int[] numbers = new int[] { -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, };
var squares = from n in numbers.AsParallel()
                 where n > 0
                 select Square(n);
 
foreach (var n in squares)
    Console.WriteLine(n);
 
int Square(int n) => n * n;
```
В данном случае программа вычисляет квадраты чисел, которые больше 0. Однако в результате работы программы мы можем получить неупорядоченный вывод:

```
1
16
49
4
25
64
9
36
```
То есть данные склеиваются в общий набор неупорядоченно.

Если в запросе применяются операторы или методы сортировки в запросе, данные автоматически упорядочиваются:

```Csharp
var squares = from n in numbers.AsParallel()
                 where n > 0
                 orderby n  // сортировка
                 select Square(n);
```
Однако не всегда оператор orderby или метод OrderBy используются в запросах. Более того они упорядочивают результирующую выборку в соответствии с результатами, а не в соответствии с исходной последовательностью. В этих случаях мы может применять метод AsOrdered():

```Csharp
var squares = from n in numbers.AsParallel().AsOrdered()
              where n > 0
              select Square(n);
```
В этом случае результат уже будет упорядоченным в соответствии с тем, как элементы располагаются в исходной последовательности:

```
1
4
9
16
25
36
49
64
```

В то же время надо понимать, что упорядочивание в параллельной операции приводит к увеличению издержек, поэтому подобный запрос будет выполняться медленнее, чем неупорядоченный. И если задача не требует возвращение упорядоченного набора, то лучше не применять метод AsOrdered.

Кроме того, если в программе предстоят какие-нибудь манипуляции с полученным набором, однако упорядочивание больше не требуется, мы можем применить метод AsUnordered():

```Csharp
int[] numbers = new int[] { -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, };
var squares = from n in numbers.AsParallel().AsOrdered()
              where n > 0
              select Square(n);
 
// выбираем числа больще 4 без упорядочивания результата
var query = from n in squares.AsUnordered()
            where n > 4
            select n;
 
foreach (var n in query)
    Console.WriteLine(n);
 
int Square(int n) => n * n;
```

# Обработка ошибок и отмена операции

При выполнении параллельных операций также могут возникать ошибки, обработка которых имеет свои особенности. При параллельной обработке коллекция разделяется а части, и каждая часть обрабатывается в отдельном потоке. Однако если возникнет ошибка в одном из потоков, то система прерывает выполнение всех потоков.

При генерации исключений все они агрегируются в одном исключении типа AggregateException

Например, пусть в метод факториала передается массив объектов, который содержит не только числа, но и строки:

```Csharp
object[] numbers = new object[] { 1, 2, 3, 4, 5, "6" };
 
var squares = from n in numbers.AsParallel()
                 let x = (int)n
                 select Square(x);
try
{
    squares.ForAll(n => Console.WriteLine(n));
}
catch (AggregateException ex)
{
    foreach (var e in ex.InnerExceptions)
    {
        Console.WriteLine(e.Message);
    }
}
 
int Square(int n) => n * n;
```
Запустим проект без отладки. И так как массив содержит строку, то попытка приведения закончится неудачей, и на консоль будет выведено сообщение об ошибке. При запуске приложения в Visual Studio в режиме отладки выполнение остановится на строке преобразования. А после продолжения также сработает перехват исключения в блоке catch, и на консоль будет выведено сообщение об ошибке.

# Прерывание параллельной операции
Вполне вероятно, что нам может потребоваться прекратить операцию до ее завершения. В этом случае мы можем использовать метод WithCancellation(), которому в качестве параметра передается токен CancellationToken:

```Csharp
CancellationTokenSource cts = new CancellationTokenSource();
// запускаем дополнительную задачу, в которой через 400 миллисек. прерываем операцию
new Task(() =>
{
    Thread.Sleep(400);
    cts.Cancel();
}).Start();
 
try
{
    int[] numbers = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, };
 
    var squares = from n in numbers.AsParallel().WithCancellation(cts.Token)
                     select Square(n);
 
    foreach (var n in squares)
        Console.WriteLine(n);
}
catch (OperationCanceledException)
{
    Console.WriteLine("Операция была прервана");
}
catch (AggregateException ex)
{
    if (ex.InnerExceptions != null)
    {
        foreach (Exception e in ex.InnerExceptions)
            Console.WriteLine(e.Message);
    }
}
finally
{
    cts.Dispose();
}
int Square(int n)
{
    var result = n * n;
    Console.WriteLine($"Квадрат числа {n} равен {result}");
    Thread.Sleep(1000); // имитация долгого вычисления
    return result;
}
```
В параллельной запущенной задаче вызывается метод cts.Cancel(), что приводит к завершению операции и генерации исключения OperationCanceledException:

```
Квадрат числа 5 равен 25
Квадрат числа 3 равен 9
Квадрат числа 1 равен 1
Квадрат числа 7 равен 49
Операция была прервана
```
При этом также имеет смысл обрабатывать исключение AggregateException, так как если параллельно возникает еще одно исключение, то это исключение, а также OperationCanceledException помещаются внутрь одного объекта AggregateException.


