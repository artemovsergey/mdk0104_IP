# Рефлексия

## Введение в рефлексию. Класс System.Type

Рефлексия представляет собой процесс выявления типов во время выполнения приложения. Каждое приложение содержит набор используемых классов, интерфейсов, а также их методов, свойств и прочих кирпичиков, из которых складывается приложение. И рефлексия как раз и позволяет определить все эти составные элементы приложения. То есть основная задача рефлексии - это исследование типов.

Основной функционал рефлексии сосредоточен в пространстве имен System.Reflection. В нем мы можем выделить следующие основные классы:

- Assembly: класс, представляющий сборку и позволяющий манипулировать этой сборкой

- AssemblyName: класс, хранящий информацию о сборке

- MemberInfo: базовый абстрактный класс, определяющий общий функционал для классов EventInfo, FieldInfo, MethodInfo и PropertyInfo

- EventInfo: класс, хранящий информацию о событии

- FieldInfo: хранит информацию об определенном поле типа

- MethodInfo: хранит информацию об определенном методе

- PropertyInfo: хранит информацию о свойстве

- ConstructorInfo: класс, представляющий конструктор

- Module: класс, позволяющий получить доступ к определенному модулю внутри сборки

- ParameterInfo: класс, хранящий информацию о параметре метода

Эти классы представляют составные блоки типа и приложения: методы, свойства и т.д. Но чтобы получить информацию о членах типа, нам надо воспользоваться классом System.Type.

Класс Type представляет изучаемый тип, инкапсулируя всю информацию о нем. С помощью его свойств и методов можно получить эту информацию. Некоторые из его свойств и методов:

- Метод FindMembers() возвращает массив объектов MemberInfo данного типа

- Метод GetConstructors() возвращает все конструкторы данного типа в виде набора объектов ConstructorInfo

- Метод GetEvents() возвращает все события данного типа в виде массива объектов EventInfo

- Метод GetFields() возвращает все поля данного типа в виде массива объектов FieldInfo

- Метод GetInterfaces() получает все реализуемые данным типом интерфейсы в виде массива объектов Type

- Метод GetMembers() возвращает все члены типа в виде массива объектов MemberInfo

- Метод GetMethods() получает все методы типа в виде массива объектов MethodInfo

- Метод GetProperties() получает все свойства в виде массива объектов PropertyInfo

- Свойство Name возвращает имя типа

- Свойство Assembly возвращает название сборки, где определен тип

- Свойство Namespace возвращает название пространства имен, где определен тип

- Свойство IsArray возвращает true, если тип является массивом

- Свойство IsClass возвращает true, если тип представляет класс

- Свойство IsEnum возвращает true, если тип является перечислением

- Свойство IsInterface возвращает true, если тип представляет интерфейс

# Получение типа

Чтобы управлять типом и получать всю информацию о нем, нам надо сперва получить данный тип. Это можно сделать тремя способами: с помощью оператора typeof, с помощью метода GetType() класса Object и применяя статический метод Type.GetType().

Получение типа через typeof:

```Csharp
Type myType = typeof(Person);
 
Console.WriteLine(myType);  // Person
 
public class Person
{
    public string Name { get;}
    public Person(string name) => Name = name;
}
```
Здесь определен класс Person с некоторой функциональностью. И чтобы получить его тип, используется выражение Type myType = typeof(Person);

Получение типа с помощью метода GetType, унаследованного от класса Object:

```Csharp
Person tom = new Person("Tom");
Type myType = tom.GetType();
```
В отличие от предыдущего примера здесь, чтобы получить тип, надо создавать объект класса.

И третий способ получения типа - статический метод Type.GetType():

```Csharp
Type? myType = Type.GetType("Person", false, true);
```
Первый параметр указывает на полное имя класса с пространством имен. Второй параметр указывает, будет ли генерироваться исключение, если класс не удастся найти. В данном случае значение false означает, что исключение не будет генерироваться. И третий параметр указывает, надо ли учитывать регистр символов в первом параметре. Значение true означает, что регистр игнорируется. Поскольку указанный тип может отсутствовать, то метод возвращает объект nullable-типа

В данном случае класс основной программы и класс Person находятся в глобальном пространстве имен. Однако если тип располагается в другом пространстве имен, то его также надо указать:

```Csharp
Type? myType = Type.GetType("PeopleTypes.Person", false, true);
 
Console.WriteLine(myType);  // PeopleTypes.Person
 
namespace PeopleTypes
{
    public class Person
    {
        public string Name { get;}
        public Person(string name) => Name = name;
    }
}
```
В качестве альтернативы можно применять оператор typeof, передавая в него имя типа с указанием пространства имен:

```Csharp
Type myType = typeof(PeopleTypes.Person);
```
Если нужный нам тип находится в другой сборке dll, то после полного имени класса через запятую указывается имя сборки:

```Csharp
Type myType = Type.GetType("PeopleTypes.Person, MyLibrary", false, true);
```
Теперь исследуем тип и получим некоторую информацию о нем.

```Csharp
Type myType = typeof(PeopleTypes.Person);
 
Console.WriteLine($"Name: {myType.Name}");              // получаем краткое имя типа
Console.WriteLine($"Full Name: {myType.FullName}");     // получаем полное имя типа
Console.WriteLine($"Namespace: {myType.Namespace}");    // получаем пространство имен типа
Console.WriteLine($"Is struct: {myType.IsValueType}");  // является ли тип структурой
Console.WriteLine($"Is class: {myType.IsClass}");       // является ли тип классом
 
namespace PeopleTypes
{
    class Person
    {
        public string Name { get; }
        public Person(string name) => Name = name;
    }
}
```
Консольный вывод:

```
Name: Person
Full Name: PeopleTypes.Person
Namespace: PeopleTypes
Is struct: False
Is class: True
```
# Поиск реализованных интерфейсов

Чтобы получить все реализованные типом интерфейсы, надо использовать метод GetInterfaces(), который возвращает массив объектов Type:

```Csharp
Type myType = typeof(Person);
 
Console.WriteLine("Реализованные интерфейсы:");
foreach (Type i in myType.GetInterfaces())
{
    Console.WriteLine(i.Name);
}
 
public class Person : IEater, IMovable
{
    public string Name { get;}
    public Person(string name) => Name = name;
    public void Eat() => Console.WriteLine($"{Name} eats");
 
    public void Move()=> Console.WriteLine($"{Name} moves");
}
interface IEater
{
    void Eat();
}
interface IMovable
{
    void Move();
}
```
Так как каждый интерфейс представляет объект Type, то для каждого полученного интерфейса можно также применить выше рассмотренные методы для извлечения информации о свойствах и методах

Но пока все примеры выше никак не использовали рефлексию. В следующих темах рассмотрим, как можно с помощью рефлексии получать компоненты типа и обращаться к ним, например, изменять значения приватных полей класса.

# Применение рефлексии и исследование типов

## Получение всех компонентов типа

Метод GetMembers() возвращает все доступные компоненты типа в виде объекта MemberInfo. Этот объект позволяет извлечь некоторую информацию о компоненте типа. В частности, некоторые его свойства:

- DeclaringType: возвращает полное название типа.

- MemberType: возвращает значение из перечисления MemberTypes:

    - MemberTypes.Constructor

    - MemberTypes.Method

    - MemberTypes.Field

    - MemberTypes.Event

    - MemberTypes.Property

    - MemberTypes.NestedType

- Name: возвращает название компонента

Применим метод GetMembers и выведем все доступные элементы типа:

```Csharp
using System.Reflection;     // подключаем функционал рефлексии
 
Type myType = typeof(Person);
 
foreach (MemberInfo member in myType.GetMembers())
{
    Console.WriteLine($"{member.DeclaringType} {member.MemberType} {member.Name}");
}
 
public class Person
{
    string name;
    public int Age { get; set; }
    public Person(string name, int age)
    {
        this.name = name;
        this.Age = age;
    }
    public void Print() => Console.WriteLine($"Name: {name} Age: {Age}");
}
```
В данном случае мы получим все общедоступные члены класса Person.

```
Person Method get_Age
Person Method set_Age
Person Method Print
System.Object Method GetType
System.Object Method ToString
System.Object Method Equals
System.Object Method GetHashCode
Person Constructor .ctor
Person Property Age
```
Обратите внимание, что в данном случае мы получаем только все публичные компоненты класса, и нам не выводится информация о приватной переменной name.

Кроме того, для свойства выводятся методы доступа - геттер (здесь get_Age) и сеттер (здесь set_Age).

Третий момент, который надо отметить, что по умолчанию мы получаем весь функционал, в том числе унаследованный от базовых классов (в данном случае функционал базового класса Object).

## BindingFlags

В примере выше использовалась простая форма метода GetMembers(), которая извлекает все общедоступные публичные методы. Но мы можем использовать и другую форму метода: MembersInfo[] GetMembers(BindingFlags). Перечисление BindingFlags может принимать различные значения:

- DeclaredOnly: получает только методы непосредственно данного класса, унаследованные методы не извлекаются

- Instance: получает только методы экземпляра

- NonPublic: извлекает не публичные методы

- Public: получает только публичные методы

- Static: получает только статические методы

Объединяя данные значения с помощью побитовой операции ИЛИ можно комбинировать вывод. Например, получим только компоненты непосредственно самого класса без унаследованных, как публичные, так и все остальные:

```Csharp
using System.Reflection;     // подключаем функционал рефлексии
 
Type myType = typeof(Person);
 
foreach (MemberInfo member in myType.GetMembers(BindingFlags.DeclaredOnly
            | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))
{
    Console.WriteLine($"{member.DeclaringType} {member.MemberType} {member.Name}");
}
 
public class Person
{
    string name;
    public int Age { get; set; }
    public Person(string name, int age)
    {
        this.name = name;
        this.Age = age;
    }
    public void Print() => Console.WriteLine($"Name: {name} Age: {Age}");
}
```
И в данном случае мы получим несколько другой вывод:

```
Person Method get_Age
Person Method set_Age
Person Method Print
Person Constructor .ctor
Person Property Age
Person Field name
Person Field <Age>k__BackingField
```

## Получение одного компонента по имени
Для получения одного компонента можно использовать метод GetMember(), в который передается имя компонента. И опционально можно передать флаги BindingFlags.

```Csharp
Type myType = typeof(Person);
 
// получаем метод print
MemberInfo[] print = myType.GetMember("Print", BindingFlags.Instance | BindingFlags.Public);
foreach (MemberInfo member in print)
{
    Console.WriteLine($"{member.MemberType} {member.Name}");
}
```
Стоит отметить, что при получении одного члена типа опять же возвращается массив MemberInfo[], поскольку в классе может быть несколько элементов с одним именем, например, несколько перегруженных версий метода Print.

# Исследование методов и конструкторов с помощью рефлексии

Получение информации о методах
Для получения получении информации отдельно о методах применяется метод GetMethods(). Этот метод возвращает все методы типа в виде массива объектов MethodInfo. Его свойства предоставляют информацию о методе. Отметим некоторые из его свойств:

- IsAbstract: возвращает true, если метод абстрактный

- IsFamily: возвращает true, если метод имеет модификатор доступа protected

- IsFamilyAndAssembly: возвращает true, если метод имеет модификатор доступа private protected

- IsFamilyOrAssembly: возвращает true, если метод имеет модификатор доступа protected internal

- IsAssembly: возвращает true, если метод имеет модификатор доступа internal

- IsPrivate: возвращает true, если метод имеет модификатор доступа private

- IsPublic: возвращает true, если метод имеет модификатор доступа public

- IsConstructor: возвращает true, если метод предоставляет конструктор

- IsStatic: возвращает true, если метод статический

- IsVirtual: возвращает true, если метод виртуальный

- ReturnType: возвращает тип возвращаемого значения

Некоторые из методов MethodInfo:

- GetMethodBody(): возвращает тело метода в виде объекта MethodBody

- GetParameters(): возвращает массив параметров, где каждый параметр представлен объектом типа ParameterInfo

- Invoke(): вызывает метод

Применим ряд свойств для исследования методов класса:

```Csharp
using System.Reflection;
 
Type myType = typeof(Printer);
 
Console.WriteLine("Методы:");
foreach (MethodInfo method in myType.GetMethods())
{
    string modificator = "";
 
    // если метод статический
    if (method.IsStatic) modificator += "static ";
    // если метод виртуальный
    if (method.IsVirtual) modificator += "virtual ";
 
    Console.WriteLine($"{modificator}{method.ReturnType.Name} {method.Name} ()");
}
class Printer
{
    public string DefaultMessage { get; set; } = "Hello";
    public void PrintMessage(string message, int times = 1)
    {
        while (times-- > 0) Console.WriteLine(message);
    }
    public string CreateMessage() => DefaultMessage;
}
```
На выходе получим следующую информацию:

```
Методы:
String get_DefaultMessage ()
Void set_DefaultMessage ()
Void PrintMessage ()
String CreateMessage ()
Type GetType ()
virtual String ToString ()
virtual Boolean Equals ()
virtual Int32 GetHashCode ()
```
Как видно из вывода в категорию методов также попадают и свойства, которые по сути представляют два метода: get и set. Если подобная ситуация не устраивает, то можно дополнительно фильтровать список методов:

```Csharp
foreach (MethodInfo method in myType.GetMethods()
            .Where(m => !m.Name.StartsWith("get_") && !m.Name.StartsWith("set_")))
{
 // .........
}
```
# BindingFlags

В примере выше использовалась простая форма метода GetMethods(), которая извлекает все общедоступные публичные методы. Но мы можем использовать и другую форму метода: MethodInfo[] GetMethods(BindingFlags). Объединяя значения BindingFlags можно комбинировать вывод. Например, получим только методы самого класса без унаследованных, как публичные, так и все остальные:

```Csharp
using System.Reflection;
 
Type myType = typeof(Printer);
 
Console.WriteLine("Методы:");
foreach (MethodInfo method in myType.GetMethods(BindingFlags.DeclaredOnly
            | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))
{
    Console.WriteLine($"{method.ReturnType.Name} {method.Name} ()");
}
class Printer
{
    public string DefaultMessage { get; set; } = "Hello";
    protected internal void PrintMessage(string message, int times = 1)
    {
        while (times-- > 0) Console.WriteLine(message);
    }
    private string CreateMessage() => DefaultMessage;
}
```
Теперь метод Print в классе Person является приватным, а метод SayMessage имеет модификатор protected internal.

Для получения всех непубличных методов в метод GetMethods() передается набор флагов BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public, то есть получаем все методы экземпляра, как публичные, так и непубличные, но исключаем статические. Соответственно теперь получим следующий вывод:

```
Методы:
String get_DefaultMessage ()
Void set_DefaultMessage ()
Void PrintMessage ()
String CreateMessage ()
```
## Исследование параметров
С помощью метода GetParameters() можно получить все параметры метода в виде массива объектов ParameterInfo. Отметим некоторые из свойств ParameterInfo, которые позволяют получить информацию о параметрах:

- Attributes: возвращает атрибуты параметра

- DefaultValue: возвращает значение параметра по умолчанию

- HasDefaultValue: возвращает true, если параметр имеет значение по умолчанию

- IsIn: возвращает true, если параметр имеет модификатор in

- IsOptional: возвращает true, если параметр является необязательным

- IsOut: возвращает true, если параметр является выходным, то есть имеет модификатор out

- Name: возвращает имя параметра

- ParameterType: возвращает тип параметра

Используем тип ParameterInfo для исследования параметров:

```Csharp
using System.Reflection;
 
foreach (MethodInfo method in typeof(Printer).GetMethods())
{
    Console.Write($"{method.ReturnType.Name} {method.Name} (");
    //получаем все параметры
    ParameterInfo[] parameters = method.GetParameters();
    for (int i = 0; i < parameters.Length; i++)
    {
        var param = parameters[i];
        // получаем модификаторы параметра
         string modificator = "";
        if (param.IsIn) modificator = "in";
        else if (param.IsOut) modificator = "out";
 
        Console.Write($"{param.ParameterType.Name} {modificator} {param.Name}");
        // если параметр имеет значение по умолчанию
        if (param.HasDefaultValue) Console.Write($"={param.DefaultValue}");
        // если не последний параметр, добавляем запятую
        if (i < parameters.Length - 1) Console.Write(", ");
    }
    Console.WriteLine(")");
}
 
class Printer
{
    public void PrintMessage(string message, int times = 1)
    {
        while (times-- > 0) Console.WriteLine(message);
    }
     public void CreateMessage(out string message) => message = "Hello Metanit.com";
}
```
Консольный вывод:

```
Void PrintMessage (String  message, Int32  times=1)
Void CreateMessage (String& out message)
Type GetType ()
String ToString ()
Boolean Equals (Object  obj)
Int32 GetHashCode ()
```
Стоит отметить, что если параметр имеет модификатор ref, in, out, то в конце названия типа добавляется амперсанд - String&.

## Вызов методов
С помощью метода Invoke() можно вызвать метод:

```Csharp
public object? Invoke (object? obj, object?[]? parameters);
```
Первый параметр представляет объект, для которого вызывается метод. Второй объект представляет массив значений, которые передаются параметрам метода. И также метод может возвращать результат в виде значения object?.

Вызов метода:

```Csharp
using System.Reflection;
 
var myPrinter = new Printer("Hello");
 
// получаем метод Print
var print = typeof(Printer).GetMethod("Print");
// вызываем метод Print
print?.Invoke(myPrinter, parameters: null); // Hello
 
class Printer
{
    public string Text { get;}
    public Printer(string text) => Text = text;
    public void Print() => Console.WriteLine(Text);
}
```
Метод GetMethod() возвращает метод, который имеет определенное имя - в данном случае метод Print. Далее используя полученный метод, его можно вызвать. Здесь при вызове в качестве первого параметра передается объект, для которого вызывается метод Print - объект myPrinter. И поскольку метод Print не принимает параметров, параметру parameters передается значение null.

Если метод непубличный, то для получения метода мы можем передать флаги в вызов GetMethod:

```Csharp
using System.Reflection;
 
var myPrinter = new Printer("Hello METANIT.COM");
 
// получаем метод Print
var print = typeof(Printer).GetMethod("Print",
            BindingFlags.Instance |
            BindingFlags.Public |
            BindingFlags.NonPublic);
// вызываем метод Print
print?.Invoke(myPrinter, parameters: null); // Hello METANIT.COM
 
class Printer
{
    public string Text { get;}
    public Printer(string text) => Text = text;
    private void Print() => Console.WriteLine(Text);
}
```
Получение результата:

```Csharp
using System.Reflection;
 
var myPrinter = new Printer();
// получаем метод CreateMessage
var createMessage = typeof(Printer).GetMethod("CreateMessage");
// вызываем метод CreateMessage и получаем его результат
var result = createMessage?.Invoke(myPrinter, parameters: null);
Console.WriteLine(result);  // Hello Metanit.com
 
class Printer
{
    public string CreateMessage() => "Hello Metanit.com";
}
```
Стоит отметить, что результат метода представляет тип object?, соответственно при необходимости может потребоваться выполнить приведение типов.

Передача параметров:

```Csharp
using System.Reflection;
 
var myPrinter = new Printer();
// получаем метод PrintMessage
var printMessage = typeof(Printer).GetMethod("PrintMessage");
// вызываем метод PrintMessage, передавая ему два аргумента
printMessage?.Invoke(myPrinter, new object[] {"Hi world", 3});
 
class Printer
{
    public void PrintMessage(string message, int times)
    {
        while (times-- > 0) Console.WriteLine(message);
    }
}
```
Здесь метод PrintMessage имеет два параметра - messsage (некоторое соощение) и times (сколько раз надо вывести сообщение на консоль). И для этих параметров передаем массив аргументов new object[] {"Hi world", 3}. Таким образом, метод три раза выведет строку "Hi world".

Вызов обобщенного метода:

```Csharp
using System.Reflection;
 
var myPrinter = new Printer();
// получаем метод PrintValue
var printValue = typeof(Printer).GetMethod("PrintValue");
// получаем обобщенную версию метода для типа string
var printStringValue = printValue?.MakeGenericMethod(typeof(string));
// вызываем метод PrintValue, передавая ему строку
printStringValue?.Invoke(myPrinter, new object[] {"Hello world"});
 
class Printer
{
    public void PrintValue<T>(T value)
    {
        Console.WriteLine(value);
    }
}
```
Для получения обобщенной версии метода, которая типизирована определенным типом, у объекта MethodInfo вызывается метод MakeGenericMethod - в него передает тип, которым типизируется метод.

## Получение конструкторов
Для получения конструкторов применяется метод GetConstructors(), который возвращает массив объектов класса ConstructorInfo. Этот класс во многом похож на MethodInfo и имеет ряд общей функциональности. Некоторые основные свойства и методы:

- Свойство IsFamily: возвращает true, если конструктор имеет модификатор доступа protected

- Свойство IsFamilyAndAssembly: возвращает true, если конструктор имеет модификатор доступа private protected

- Свойство IsFamilyOrAssembly: возвращает true, если конструктор имеет модификатор доступа protected internal

- Свойство IsAssembly: возвращает true, если конструктор имеет модификатор доступа internal

- Свойство IsPrivate: возвращает true, если конструктор имеет модификатор доступа private

- Свойство IsPublic: возвращает true, если конструктор имеет модификатор доступа public

- Метод GetMethodBody(): возвращает тело конструктора в виде объекта MethodBody

- Метод GetParameters(): возвращает массив параметров, где каждый параметр представлен объектом типа ParameterInfo

- Метод Invoke(): вызывает конструктор

Исследуем конструкторы

```Csharp
using System.Reflection;
 
Type myType = typeof(Person);
 
Console.WriteLine("Конструкторы:");
foreach (ConstructorInfo ctor in myType.GetConstructors(
    BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))
{
    string modificator = "";
 
    // получаем модификатор доступа
    if (ctor.IsPublic)
        modificator += "public";
    else if (ctor.IsPrivate)
        modificator += "private";
    else if (ctor.IsAssembly)
        modificator += "internal";
    else if (ctor.IsFamily)
        modificator += "protected";
    else if (ctor.IsFamilyAndAssembly)
        modificator += "private protected";
    else if (ctor.IsFamilyOrAssembly)
        modificator += "protected internal";
 
    Console.Write($"{modificator} {myType.Name}(");
    // получаем параметры конструктора
    ParameterInfo[] parameters = ctor.GetParameters();
    for (int i = 0; i < parameters.Length; i++)
    {
        var param = parameters[i];
        Console.Write($"{param.ParameterType.Name} {param.Name}");
        if (i < parameters.Length - 1) Console.Write(", ");
    }
    Console.WriteLine(")");
}
class Person
{
    public string Name { get; }
    public int Age { get; }
    public Person(string name, int age)
    {
        Name = name; Age = age;
    }
    public Person(string name) : this(name, 1) { }
    private Person() : this("Tom") { }
}
```
В данном случае исследуем конструкторы класса Person, один из которых является приватным. Консольный вывод:

```
Конструкторы:
public Person(String name, Int32 age)
public Person(String name)
private Person()
```

# Исследование полей и свойств с помощью рефлексии

Получение информации о полях
Для извлечения всех полей применяется метод GetFields(), который возвращает массив объектов класса FieldInfo.

Некоторые основные свойства и методы класса FieldInfo:

- Свойство IsFamily: возвращает true, если поле имеет модификатор доступа protected

- Свойство IsFamilyAndAssembly: возвращает true, если поле имеет модификатор доступа private protected

- Свойство IsFamilyOrAssembly: возвращает true, если поле имеет модификатор доступа protected internal

- Свойство IsAssembly: возвращает true, если поле имеет модификатор доступа internal

- Свойство IsPrivate: возвращает true, если поле имеет модификатор доступа private

- Свойство IsPublic: возвращает true, если поле имеет модификатор доступа public

- Свойство IsStatic: возвращает true, если поле статическое

- Метод GetValue(): возвращает значение поля

- Метод SetValue(): устанавливает значение поля

Например, получим все поля класса:

```Csharp
using System.Reflection;
 
Type myType = typeof(Person);
 
Console.WriteLine("Поля:");
foreach (FieldInfo field in myType.GetFields(
    BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static))
{
    string modificator = "";
 
    // получаем модификатор доступа
    if (field.IsPublic)
        modificator += "public ";
    else if (field.IsPrivate)
        modificator += "private ";
    else if (field.IsAssembly)
        modificator += "internal ";
    else if (field.IsFamily)
        modificator += "protected ";
    else if (field.IsFamilyAndAssembly)
        modificator += "private protected ";
    else if (field.IsFamilyOrAssembly)
        modificator += "protected internal ";
 
    // если поле статическое
    if (field.IsStatic) modificator += "static ";
 
    Console.WriteLine($"{modificator}{field.FieldType.Name} {field.Name}");
}
 
class Person
{
    static int minAge = 0;
    string name;
    int age;
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"{name} - {age}");
}
```
Чтобы получить и статические, и не статические, и публичные, и непубличные поля, в метод GetFields() передается набор флагов

```Csharp
BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static
```
Консольный вывод:

```
Поля:
private String name
private Int32 age
private static Int32 minAge
```
## Получение и изменение значения поля

Для получения одного поля по имени применяется метод GetField(), в который передается имя поля:

```Csharp
var name = myType.GetField("name", BindingFlags.Instance | BindingFlags.NonPublic);
```
В качестве второго необязательного параметра передается набор флагов.

Причем рефлексия позволяет получать значения и изменять их даже у привтаных полей. Например, получим и изменим значение поля name:

```Csharp
using System.Reflection;
 
Type myType = typeof(Person);
Person tom = new Person("Tom", 37);
 
// получаем приватное поле name
var name = myType.GetField("name", BindingFlags.Instance | BindingFlags.NonPublic);
 
// получаем значение поля name
var value =name?.GetValue(tom);
Console.WriteLine(value);   // Tom
 
// изменяем значение поля name
name?.SetValue(tom, "Bob");
tom.Print();    // Bob - 37
 
class Person
{
    static int minAge = 1;
    string name;
    int age;
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"{name} - {age}");
}
```
## Свойства
Для извлечения всех свойств типа применяется соответственно метод GetProperties(), который возвращает массив объектов PropertyInfo. Для получения одного свойства по имени применяется метод GetProperty(), в который передается название свойства и который возвращает объект PropertyInfo?.

Некоторый основной функционал класса PropertyInfo:

- Свойство Attributes: возвращает коллекцию атрибутов свойства

- Свойство CanRead: возвращает true, если свойство доступно для чтения

- Свойство CanWrite: возвращает true, если свойство доступно для записи

- Свойство GetMethod: возвращает get-акссесор в виде объекта MethodInfo?

- Свойство SetMethod: возвращает set-акссесор в виде объекта MethodInfo?

- Свойство PropertyType: возвращает тип свойства

- Метод GetValue(): возвращает значение свойства

- Метод SetValue(): устанавливает значение свойства

Используем некоторые свойства PropertyInfo для получения информации о свойствах:

```Csharp
using System.Reflection;
 
Type myType = typeof(Person);
foreach (PropertyInfo prop in myType.GetProperties(
    BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static))
{
    Console.Write($"{prop.PropertyType} {prop.Name} {{");
 
    // если свойство доступно для чтения
    if (prop.CanRead) Console.Write("get;");
    // если свойство доступно для записи
    if (prop.CanWrite) Console.Write("set;");
    Console.WriteLine("}");
}
 
class Person
{
    public string Name { get; }
    public int Age { get; set; }
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
    public void Print() => Console.WriteLine($"{Name} - {Age}");
}
```

```
System.String Name {get;}
System.Int32 Age {get;set;}
```
С помощью методов PropertyInfo можно манипулировать значением свойства. Например, получим и изменим значение свойства:

```Csharp
using System.Reflection;
 
Type myType = typeof(Person);
Person tom = new Person("Tom", 37);
// получаем свойство Age
var ageProp = myType.GetProperty("Age");
// получаем значение свойства Age у объекта tom
var age = ageProp?.GetValue(tom);
Console.WriteLine(age); // 37
// устанавливаем новое значение для свойства Age объекта tom
ageProp?.SetValue(tom, 22);
tom.Print();    // Tom - 22
 
class Person
{
    public string Name { get; }
    public int Age { get; set; }
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
    public void Print() => Console.WriteLine($"{Name} - {Age}");
}
```
Для получения значения свойства в метод GetValue() объекта PropertyInfo передается объект, у которого вызывается свойства. Результатом метода является значение свойства. Для установки значения в метод SetValue() объекта PropertyInfo передается объект, у которого устанавливается свойство, и собственно новое значение свойства.

# Динамическая загрузка сборок и позднее связывание

При создании приложения для него определяется набор сборок, которые будут использоваться. В проекте указываются ссылки на эти сборки, и когда приложение выполняется, при обращении к функционалу этих сборок они автоматически подгружаются.

Но также мы можем сами динамически подгружать другие сборки, на которые в проекте нет ссылок.

Для управления сборками в пространстве имен System.Reflection имеется класс Assembly. С его помощью можно загружать сборку, исследовать ее.

Чтобы динамически загрузить сборку в приложение, надо использовать статические методы Assembly.LoadFrom() или Assembly.Load().

Метод LoadFrom() принимает в качестве параметра путь к сборке.

Допустим, у нас есть два проекта:

![](https://metanit.com/sharp/tutorial/pics/14.1.png)

Пусть в проекте MyApp, который компилируется в сборку MyApp.dll, имеется файл Program.cs со следующим кодом:

```Csharp
Person tom = new Person("Tom");
Console.WriteLine($"Hello, {tom.Name}");
 
class Person
{
    public string Name { get; }
    public Person(string name) => Name = name;
}
```
В другом проект исследуем сборку MyApp.dll на наличие в ней различных типов:

```Csharp
using System.Reflection;
 
Assembly asm = Assembly.LoadFrom("MyApp.dll");
 
Console.WriteLine(asm.FullName);
// получаем все типы из сборки MyApp.dll
Type[] types = asm.GetTypes();
foreach (Type t in types)
{
    Console.WriteLine(t.Name);
}
```
В данном случае для исследования указывается сборка MyApp.dll. Здесь использован относительный путь, так как сборка находится в одной папке с приложением - в проекте в каталоге bin/Debug/net6.x. Можно в принципе в качестве имени указать и имя текущего приложение. В этом случае программа будет исследовать саму себя. В любом случае стоит учитывать, что загрузке подлежат (по крайней мере в .NET 6.0) сборки с расширением dll, но не exe.

И в моем случае я получу следующий консольный вывод:

```
MyApp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null
EmbeddedAttribute
NullableAttribute
NullableContextAttribute
Program
Person
```
Как видно из вывода, полное название сборки: MyApp, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null. А сама сборка MyApp.dll содержит пять типов - кроме класса Person и неявно определяемого класса Program добавляется еще три автоматически генерируемых класса.

Метод Load() действует аналогично, только в качестве его параметра передается дружественное имя сборки, которое нередко совпадает с именем приложения: Assembly asm = Assembly.Load("MyApp");

Получив все типы сборки с помощью метода GetTypes(), мы опять же можем применить к каждому типу все те методы, которые были рассмотрены в прошлой теме.

# Позднее связывание
С помощью динамической загрузки мы можем реализовать технологию позднего связывания. Позднее связывание позволяет создавать экземпляры некоторого типа, а также использовать его во время выполнения приложения.

Использование позднего связывания менее безопасно в том плане, что при жестком кодировании всех типов (ранее связывание) на этапе компиляции мы можем отследить многие ошибки. В то же время позднее связывание позволяет создавать расширяемые приложения, когда дополнительный функционал программы неизвестен, и его могут разработать и подключить сторонние разработчики.

Ключевую роль в позднем связывании играет класс System.Activator. С помощью его статического метода Activator.CreateInstance() можно создавать экземпляры заданного типа.

Например, динамически загрузим сборку и вызовем у ней некоторый метод. Допустим, загружаемая сборка MyApp.exe представляет следующую программу:

```Csharp
class Program
{
    static void Main(string[] args)
    {
        var number = 5;
        var result = Square(number);
        Console.WriteLine($"Квадрат {number} равен {result}");
    }
    static int Square(int n) => n * n;
}
```
В данном случае мы явным образом определили класс Program с методом Main. И кроме того, в классе Program определен статический метод Square, который в качестве параметра принимает число и возвращает его квадрат.

Теперь динамически подключим сборку с этой программой в другой программе и вызовем ее методы.

Пусть наша основная программа будет выглядеть так:

```Csharp
using System.Reflection;
 
Assembly asm = Assembly.LoadFrom("MyApp.dll");
 
Type? t = asm.GetType("Program");
if (t is not null)
{
    // получаем метод Square
    MethodInfo? square = t.GetMethod("Square", BindingFlags.NonPublic | BindingFlags.Static);
 
    // вызываем метод, передаем ему значения для параметров и получаем результат
    object? result = square?.Invoke(null, new object[] { 7 });
    Console.WriteLine(result); // 49
}
```
Сначала получаем ссылку на исследуемую сборку в переменную asm:

```Csharp
Assembly asm = Assembly.LoadFrom("MyApp.dll")
```
Затем с помощью метода GetType получаем тип - класс Program, который находится в сборке MyApp.dll:

```Csharp
Type? t = asm.GetType("Program");
```
И в конце остается вызвать метод. Во-первых, получаем сам метод:

```Csharp
MethodInfo? square = t.GetMethod("Square", BindingFlags.NonPublic | BindingFlags.Static);
```
Поскольку метод Square приватный и статический, то в качестве второго параметра в метод передаются флаги BindingFlags.NonPublic | BindingFlags.Static

И потом с помощью метода Invoke вызываем его:

```Csharp
object? result = square?.Invoke(null, new object[] { 7 });
```
Здесь первый параметр представляет объект, для которого вызывается метод, а второй - набор параметров в виде массива object[]. Однако поскольку вызываемый метод - статический и не относится к какому-то определенному объекту, то первым аргументом в метод передается null.

Так как метод Square возвращает некоторое значение, то мы можем его получить из метода в виде объекта типа object.

Если бы метод не принимал параметров, то вместо массива объектов использовалось бы значение null: method.Invoke(null, null)

В сборке MyApp.exe в классе Program также есть и другой метод - метод Main, который также выполняет некоторую работу. Вызовем теперь его:

```Csharp
using System.Reflection;
 
Assembly asm = Assembly.LoadFrom("MyApp.dll");
 
Type? program = asm.GetType("Program");
if (program is not null)
{
    // получаем метод Main
    MethodInfo? main = program.GetMethod("Main", BindingFlags.NonPublic | BindingFlags.Static);
 
    // вызываем метод Main
    main?.Invoke(null, new object[] { new string[] { } });   // Квадрат 5 равен 25
}
```
Так как метод Main является статическим и не публичным, то к нему также применяется битовая маска BindingFlags.NonPublic | BindingFlags.Static. И поскольку он в качестве параметра принимает массив строк, то при вызове метода передается соответствующее значение: ```main.Invoke(null, new object[]{new string[]{}})```


# Атрибуты в .NET

Атрибуты в .NET представляют специальные инструменты, которые позволяют встраивать в сборку дополнительные метаданные. Атрибуты могут применяться как ко всему типу (классу, интерфейсу и т.д.), так и к отдельным его частям (методу, свойству и т.д.). Основу атрибутов составляет класс System.Attribute, от которого образованы все остальные классы атрибутов. В .NET имеется множество встроенных классов атрибутов. И также мы можем создавать свои собственные классы атрибутов, которые будут определять метаданные других типов.

Допустим, нам надо проверять пользователя на соответствие некоторым возрастным ограничениям. Создадим свой атрибут, который будет хранить пороговое значение возраста, с которого разрешены некоторые действия:

```Csharp
class AgeValidationAttribute : Attribute
{
    public int Age { get;}
    public AgeValidationAttribute() { }
    public AgeValidationAttribute(int age) => Age = age;
}
```
По сути это обычный класс, унаследованный от System.Atribute. В нем определено два конструктора: с параметром и без. В качестве параметра второй конструктор атрибута принимает некий пороговый возраст и сохраняет его в свойстве.

Теперь применим его к некоторому классу:

```Csharp
[AgeValidation(18)]
public class Person
{
    public string Name { get;}
    public int Age { get; set; }
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
```
Данный класс Person применяет атрибут. Для этого имя атрибута указывается в квадратных скобках непосредственно перед определением класса. Причем суффикс Attribute указывать необязательно. Обе записи [AgeValidation(18)] и [AgeValidationAttribute(18)] будут равноправны.

Если конструктор атрибута предусматривает использование параметров (public AgeValidationAttribute(int age)), то после имени атрибута мы можем указать значения для параметров конструктора. В данном случае передается значение для параметра age. То есть фактически мы говорим, что в AgeValidationAttribute свойство Age будет иметь значение 18.

В качестве альтернативы можно использовать именованные параметры для всех свойств атрибута, если класс атрибута имеет конструктор без параметров: [AgeValidation(Age = 18)]

Теперь получим атрибут класса Person и используем его для проверки объектов данного класса:

```Csharp
Person tom = new Person("Tom", 35);
Person bob = new Person("Bob", 16);
bool tomIsValid = ValidateUser(tom);    // true
bool bobIsValid = ValidateUser(bob);    // false
 
Console.WriteLine($"Результат валидации Тома: {tomIsValid}");
Console.WriteLine($"Результат валидации Боба: {bobIsValid}");
 
bool ValidateUser(Person person)
{
    Type type = typeof(Person);
    // получаем все атрибуты класса Person
    object[] attributes = type.GetCustomAttributes(false);
 
    // проходим по всем атрибутам
    foreach (Attribute attr in attributes)
    {
        // если атрибут представляет тип AgeValidationAttribute
        if (attr is AgeValidationAttribute ageAttribute)
            // возвращаем результат проверки по возрасту
            return person.Age >= ageAttribute.Age;
    }
    return true;
}
 
class AgeValidationAttribute : Attribute
{
    public int Age { get;}
    public AgeValidationAttribute() { }
    public AgeValidationAttribute(int age) => Age = age;
}
 
[AgeValidation(18)]
public class Person
{
    public string Name { get;}
    public int Age { get; set; }
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
```
В данном случае в методе ValidateUser через параметр получаем некоторый объект Person и с помощью метода GetCustomAttributes вытаскиваем из типа Person все атрибуты. Далее берем из атрибутов атрибут AgeValidationAttribute при его наличии (ведь мы можем его и не применять к классу) и проверям допустимость возраста пользователя. Если пользователь прошел проверку по возрасту, то возвращаем true, иначе возвращаем false. Если атрибут не применяется, возвращаем true.

## Ограничение применения атрибута

С помощью атрибута AttributeUsage можно ограничить типы, к которым будет применяться атрибут. Например, мы хотим, чтобы выше определенный атрибут мог применяться только к классам:

```Csharp
[AttributeUsage(AttributeTargets.Class)]
class AgeValidationAttribute : Attribute
{
//....................................
}
```
Ограничение задает перечисление AttributeTargets, которое может принимать еще ряд значений:

- All: используется всеми типами

- Assembly: атрибут применяется к сборке

- Constructor: атрибут применяется к конструктору

- Delegate: атрибут применяется к делегату

- Enum: применяется к перечислению

- Event: атрибут применяется к событию

- Field: применяется к полю типа

- Interface: атрибут применяется к интерфейсу

- Method: применяется к методу

- Property: применяется к свойству

- Struct: применяется к структуре

С помощью логической операции ИЛИ можно комбинировать эти значения. Например, пусть атрибут может применяться к классам и структурам: ```[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct)]```

