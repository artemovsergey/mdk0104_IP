# Сборка мусора, управление памятью и указатели
## Сборщик мусора в C#

Ранее в теме мы рассматривали отдельные типы данных и как они располагаются в памяти. Так, при использовании переменных типов значений в методе, все значения этих переменных попадают в стек. После завершения работы метода стек очищается.

При использовании же ссылочных типов, например, объектов классов, для них также будет отводиться место в стеке, только там будет храниться не значение, а адрес на участок памяти в хипе или куче, в котором и будут находиться сами значения данного объекта. И если объект класса перестает использоваться, то при очистке стека ссылка на участок памяти также очищается, однако это не приводит к немедленной очистке самого участка памяти в куче. Впоследствии сборщик мусора (garbage collector) увидит, что на данный участок памяти больше нет ссылок, и очистит его.

Например:

```Csharp
Test();
 
void Test()
{
    Person tom = new Person("Tom");
    Console.WriteLine(tom.Name);
}
record class Person(string Name);
```

В методе Test создается объект Person. С помощью оператора new в куче для хранения объекта CLR выделяет участок памяти. А в стек добавляет адрес на этот участок памяти. В неявно определенном методе Main мы вызываем метод Test. И после того, как Test отработает, место в стеке очищается, а сборщик мусора очищает ранее выделенный под хранение объекта Person участок памяти.

Сборщик мусора не запускается сразу после удаления из стека ссылки на объект, размещенный в куче. Он запускается в то время, когда среда CLR обнаружит в этом потребность, например, когда программе требуется дополнительная память.

Как правило, объекты в куче располагаются неупорядочено, между ними могут иметься пустоты. Куча довольно сильно фрагментирована. Поэтому после очистки памяти в результате очередной сборки мусора оставшиеся объекты перемещаются в один непрерывный блок памяти. Вместе с этим происходит обновление ссылок, чтобы они правильно указывали на новые адреса объектов.

Так же надо отметить, что для крупных объектов существует своя куча - Large Object Heap. В эту кучу помещаются объекты, размер которых больше 85 000 байт. Особенность этой кучи состоит в том, что при сборке мусора сжатие памяти не проводится по причине больших издержек, связанных с размером объектов.

Несмотря на то что, на сжатие занятого пространства требуется время, да и приложение не сможет продолжать работу, пока не отработает сборщик мусора, однако благодаря подобному подходу также происходит оптимизация приложения. Теперь чтобы найти свободное место в куче среде CLR не надо искать островки пустого пространства среди занятых блоков. Ей достаточно обратиться к указателю кучи, который указывает на свободный участок памяти, что уменьшает количество обращений к памяти.

Кроме того, чтобы снизить издержки от работы сборщика мусора, все объекты в куче разделяются по поколениям. Всего существует три поколения объектов: 0, 1 и 2-е.

К поколению 0 относятся новые объекты, которые еще ни разу не подвергались сборке мусора. К поколению 1 относятся объекты, которые пережили одну сборку, а к поколению 2 - объекты, прошедшие более одной сборки мусора.

Когда сборщик мусора приступает к работе, он сначала анализирует объекты из поколения 0. Те объекты, которые остаются актуальными после очистки, повышаются до поколения 1.

Если после обработки объектов поколения 0 все еще необходима дополнительная память, то сборщик мусора приступает к объектам из поколения 1. Те объекты, на которые уже нет ссылок, уничтожаются, а те, которые по-прежнему актуальны, повышаются до поколения 2.

Поскольку объекты из поколения 0 являются более молодыми и нередко находятся в адресном пространстве памяти рядом друг с другом, то их удаление проходит с наименьшими издержками.

## Класс System.GC
Функционал сборщика мусора в библиотеке классов .NET представляет класс System.GC. Через статические методы данный класс позволяет обращаться к сборщику мусора. Как правило, надобность в применении этого класса отсутствует. Наиболее распространенным случаем его использования является сборка мусора при работе с неуправляемыми ресурсами, при интенсивном выделении больших объемов памяти, при которых необходимо такое же быстрое их освобождение.

Рассмотрим некоторые методы и свойства класса System.GC:

- Метод AddMemoryPressure информирует среду CLR о выделении большого объема неуправляемой памяти, которую надо учесть при планировании сборки мусора. В связке с этим методом используется метод RemoveMemoryPressure, который указывает CLR, что ранее выделенная память освобождена, и ее не надо учитывать при сборке мусора.

- Метод Collect приводит в действие механизм сборки мусора. Перегруженные версии метода позволяют указать поколение объектов, вплоть до которого надо произвести сборку мусора

- Метод GetGeneration(Object) позволяет определить номер поколения, к которому относится переданый в качестве параметра объект

- Метод GetTotalMemory возвращает объем памяти в байтах, которое занято в управляемой куче

- Метод WaitForPendingFinalizers приостанавливает работу текущего потока до освобождения всех объектов, для которых производится сборка мусора

Работать с методами System.GC несложно:

```Csharp
long totalMemory = GC.GetTotalMemory(false);
 
GC.Collect();
GC.WaitForPendingFinalizers();
```
С помощью перегруженных версий метода GC.Collect можно выполнить более точную настройку сборки мусора. Так, его перегруженная версия принимает в качестве параметра число - номер поколения, вплоть до которого надо выполнить очистку. Например, GC.Collect(0) - удаляются только объекты поколения 0.

Еще одна перегруженная версия принимает еще и второй параметр - перечисление GCCollectionMode. Это перечисление может принимать три значения:

- Default: значение по умолчанию для данного перечисления (Forced)

- Forced: вызывает немедленное выполнение сборки мусора

- Optimized: позволяет сборщику мусора определить, является ли текущий момент оптимальным для сборки мусора

Например, немедленная сборка мусора вплоть до первого поколения объектов: GC.Collect(1, GCCollectionMode.Forced);

# Финализируемые объекты

Большинство объектов, используемых в программах на C#, относятся к управляемым или managed-коду. Такие объекты управляются CLR и легко очищаются сборщиком мусора. Однако вместе с тем встречаются также и такие объекты, которые задействуют неуправляемые объекты (подключения к файлам, базам данных, сетевые подключения и т.д.). Такие неуправляемые объекты обращаются к API операционной системы. Сборщик мусора может справиться с управляемыми объектами, однако он не знает, как удалять неуправляемые объекты. В этом случае разработчик должен сам реализовывать механизмы очистки на уровне программного кода.

Освобождение неуправляемых ресурсов подразумевает реализацию одного из двух механизмов:

- Создание деструктора

- Реализация классом интерфейса System.IDisposable

## Создание деструкторов
Если вы вдруг программировали на языке C++, то наверное уже знакомы с концепцией деструкторов. Метод деструктора носит имя класса (как и конструктор), перед которым стоит знак тильды (~).

Деструкторы можно определить только в классах. Деструктор в отличие от конструктора не может иметь модификаторов доступа и параметры. При этом каждый класс может иметь только один деструктор.

Например, определим в классе Person простейший деструктор:

```Csharp
class Person
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    ~Person()
    {
        Console.WriteLine($"{Name} has deleted");
    }
}
```
В данном случае в деструкторе в целях демонстрации просто выводится строка на консоль, которая уведомляет, что объект удален. Но в реальных программах в деструктор вкладывается логика освобождения неуправляемых ресурсов.

Однако на деле при очистке сборщик мусора вызывает не деструктор, а метод Finalize. Все потому, что компилятор C# компилирует деструктор в конструкцию, которая эквивалентна следующей:

```Csharp
protected override void Finalize()
{
    try
    {
        // здесь идут инструкции деструктора
    }
    finally
    {
        base.Finalize();
    }
}
```
Метод Finalize уже определен в базовом для всех типов классе Object, однако данный метод нельзя так просто переопределить. И фактическая его реализация происходит через создание деструктора.

Используя в программе класс Person, после ее завершения можно будет увидеть на консоли сообщение об удалении объекта tom:

```Csharp
Test();        
GC.Collect();   // очистка памяти под объект tom
Console.Read(); // ставим задержку
 
void Test()
{
    Person tom = new Person("Tom");
}
 
public class Person
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    ~Person()
    {
        Console.WriteLine($"{Name} has been deleted");
    }
}
```

Обратите внимание, что даже после завершения метода Test и соответственно удаления из стека ссылки на объект Person в куче, может не последовать немедленного вызова деструктора. Лишь при завершении всей программы гарантировано произойдет очистка памяти. Однако с .NET 5 и в последующих версиях при завершении программы деструкторы не вызываются. Поэтому в программе выше для более быстрой очистки памяти применяется метод GC.Collect и для гарантированного вызова деструктора устанавливается задержка с помощью вызова Console.Read(), который ожидает от пользователя ввода.

На уровне памяти это выглядит так: сборщик мусора при размещении объекта в куче определяет, поддерживает ли данный объект метод Finalize. И если объект имеет метод Finalize, то указатель на него сохраняется в специальной таблице, которая называется очередь финализации. Когда наступает момент сборки мусора, сборщик видит, что данный объект должен быть уничтожен, и если он имеет метод Finalize, то он копируется в еще одну таблицу и окончательно уничтожается лишь при следующем проходе сборщика мусора.

Стоит отметить, что точное время вызова деструктора не определено. Кроме того, при финализации двух связанных объектов порядок вызова деструкторов не гарантируется. То есть если объект A хранит ссылку на объект B, и при этом оба эти объекта имеют деструкторы, то для объекта B деструктор моет уже отработать в то время, как для объекта A деструктор только начнет работу.

И здесь мы можем столкнуться со следующей проблемой: а что если нам немедленно надо вызвать деструктор и освободить все связанные с объектом неуправляемые ресурсы? В этом случае мы можем использовать второй подход - реализацию интерфейса IDisposable.

## Интерфейс IDisposable

Интерфейс IDisposable объявляет один единственный метод Dispose, в котором при реализации интерфейса в классе должно происходить освобождение неуправляемых ресурсов. Например:

```Csharp
Test();
 
void Test()
{
    Person? tom = null;
    try
    {
        tom = new Person("Tom");
    }
    finally
    {
        tom?.Dispose();
    }
}
 
public class Person : IDisposable
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    public void Dispose()
    {
        Console.WriteLine($"{Name} has been disposed");
    }
}
```
В данном коде используется конструкция try...finally. По сути эта конструкция по функционалу в общем эквивалентна следующим двум строкам кода:

```Csharp
Person tom = new Person("Tom");
tom.Dispose();
```
Но конструкцию try...finally предпочтительнее использовать при вызове метода Dispose, так как она гарантирует, что даже в случае возникновения исключения произойдет освобождение ресурсов в методе Dispose.

## Комбинирование подходов
Мы рассмотрели два подхода. Какой же из них лучше? С одной стороны, метод Dispose позволяет в любой момент времени вызвать освобождение связанных ресурсов, а с другой - программист, использующий наш класс, может забыть поставить в коде вызов метода Dispose. В общем бывают различные ситуации. И чтобы сочетать плюсы обоих подходов мы можем использовать комбинированный подход. Microsoft предлагает нам использовать следующий формализованный шаблон:

```Csharp
public class SomeClass: IDisposable
{
    private bool disposed = false;
 
    // реализация интерфейса IDisposable.
    public void Dispose()
    {
        // освобождаем неуправляемые ресурсы
        Dispose(true);
        // подавляем финализацию
        GC.SuppressFinalize(this);
    }
 
    protected virtual void Dispose(bool disposing)
    {
        if (disposed) return;
        if (disposing)
        {
            // Освобождаем управляемые ресурсы
        }
        // освобождаем неуправляемые объекты
        disposed = true;
    }
 
    // Деструктор
    ~SomeClass()
    {
        Dispose (false);
    }
}
```

Логика очистки реализуется перегруженной версией метода Dispose(bool disposing). Если параметр disposing имеет значение true, то данный метод вызывается из публичного метода Dispose, если false - то из деструктора.

При вызове деструктора в качестве параметра disposing передается значение false, чтобы избежать очистки управляемых ресурсов, так как мы не можем быть уверенными в их состоянии, что они до сих пор находятся в памяти. И в этом случае остается полагаться на деструкторы этих ресурсов. Ну и в обоих случаях освобождаются неуправляемые ресурсы.

Еще один важный момент - вызов в методе Dispose метода GC.SuppressFinalize(this). GC.SuppressFinalize не позволяет системе выполнить метод Finalize для данного объекта. Если же в классе деструктор не определен, то вызов этого метода не будет иметь никакого эффекта.

Таким образом, даже если разработчик не использует в программе метод Dispose, все равно произойдет очистка и освобождение ресурсов.

Общие рекомендации по использованию Finalize и Dispose
- Деструктор следует реализовывать только у тех объектов, которым он действительно необходим, так как метод Finalize оказывает сильное влияние на производительность

- После вызова метода Dispose необходимо блокировать у объекта вызов метода Finalize с помощью GC.SuppressFinalize

- При создании производных классов от базовых, которые реализуют интерфейс IDisposable, следует также вызывать метод Dispose базового класса:
```Csharp
public class Derived: Base
{
    private bool IsDisposed = false;
 
    protected override void Dispose(bool disposing)
    {
        if (IsDisposed) return;
        if (disposing)
        {
            // Освобождение управляемых ресурсов
        }
        IsDisposed = true;
        // Обращение к методу Dispose базового класса
        base.Dispose(disposing);
    }
}
```
- Отдавайте предпочтение комбинированному шаблону, реализующему как метод Dispose, так и деструктор


# Конструкция using

В прошлой теме, где рассматривалась реализация метода Dispose, говорилось, что для его вызова можно использовать следующую конструкцию try..catch:

```Csharp
Test();
 
void Test()
{
    Person? tom = null;
    try
    {
        tom = new Person("Tom");
    }
    finally
    {
        tom?.Dispose();
    }
}
public class Person : IDisposable
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    public void Dispose() => Console.WriteLine($"{Name} has been disposed");
}
```
Однако синтаксис C# также предлагает синонимичную конструкцию для автоматического вызова метод Dispose - конструкцию using:

```Csharp
using (Person tom = new Person("Tom"))
{
}
```
Конструкция using оформляет блок кода и создает объект некоторого типа, который реализует интерфейс IDisposable, в частности, его метод Dispose. При завершении блока кода у объекта вызывается метод Dispose.

Важно, что данная конструкция применяется только для типов, которые реализуют интерфейс IDisposable.

Ее использование:

```Csharp
Test();
 
void Test()
{
    using (Person tom = new Person("Tom"))
    {
        // переменная tom доступна только в блоке using
        // некоторые действия с объектом Person
        Console.WriteLine($"Name: {tom.Name}");
    }
    Console.WriteLine("Конец метода Test");
}
public class Person : IDisposable
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    public void Dispose() => Console.WriteLine($"{Name} has been disposed");
}
```
Консольный вывод:

```
Name: Tom
Tom has been disposed
Конец метода Test
```
Здесь мы видим, что по завершении блока using у объекта Person вызывается метод Dispose. Вне блока кода using объект tom не существует.

Начиная с версии C# 8.0 мы можем задать в качестве области действия всю окружающую область видимости, например, метод:

```Csharp
Test();
 
void Test()
{
    using Person tom = new Person("Tom");
     
    // переменная tom доступна только в блоке using
    // некоторые действия с объектом Person
    Console.WriteLine($"Name: {tom.Name}");
    Console.WriteLine("Конец метода Test");
}
public class Person : IDisposable
{
    public string Name { get;}
    public Person(string name) => Name = name;
 
    public void Dispose() => Console.WriteLine($"{Name} has been disposed");
}
```
В данном случае using сообщает компилятору, что объявляемая переменная должна быть удалена в конце области видимости - то есть в конце метода Test. Соответственно мы получим следующий консольный вывод:

```
Name: Tom
Конец метода Test
Tom has been disposed
```

## Освобождение множества ресурсов
Для освобождения множества ресурсов мы можем применять вложенные конструкции using. Например:

```Csharp
void Test()
{
    using (Person tom = new Person("Tom"))
    {
        using (Person bob = new Person("Bob"))
        {
            Console.WriteLine($"Person1: {tom.Name}    Person2: {bob.Name}");
        }// вызов метода Dispose для объекта bob
    } // вызов метода Dispose для объекта tom
    Console.WriteLine("Конец метода Test");
}
```
В данном случае обе конструкции using создают объекты одного и того же типа, но это могут быть и разные типы данных, главное, чтобы они реализовали интерфейс IDisposable.

Мы можем сократить это определение:

```Csharp
void Test()
{
    using (Person tom = new Person("Tom"))
    using(Person bob = new Person("Bob"))
    {
        Console.WriteLine($"Person1: {tom.Name}    Person2: {bob.Name}");
    } // вызов метода Dispose для объектов bob и tom
    Console.WriteLine("Конец метода Test");
}
```

И, как уже было выше сказано, в C# мы можем задать в качестве области действия для объектов, создаваемых в конструкции using, весь метод:

```Csharp
private static void Test()
{
    using Person tom = new Person { Name = "Tom" };
    using Person bob = new Person { Name = "Bob" };
     
    Console.WriteLine($"Person1: {tom.Name}    Person2: {bob.Name}");
     
    Console.WriteLine("Конец метода Test");
} // вызов метода Dispose для объектов bob и tom
```
# Указатели

Если вы программировали на С/С++, то, возможно, вы знакомы с таким понятием как указатели. Указатели позволяют получить доступ к определенной ячейке памяти и произвести определенные манипуляции со значением, хранящимся в этой ячейке.

В языке C# указатели редко используются, однако в некоторых случаях можно прибегать к ним для оптимизации приложений. Код, применяющий указатели, еще называют небезопасным (unsafe) кодом. Однако это не значит, что он представляет какую-то опасность. Просто при работе с ним все действия по использованию памяти, в том числе по ее очистке, ложится целиком на нас, а не на среду CLR. И с точки зрения CLR такой код не безопасен, так как среда не может проверить данный код, поэтому повышается вероятность различного рода ошибок.

Чтобы использовать небезопасный код в C#, надо первым делом указать проекту, что он будет работать с небезопасным кодом. Для этого надо установить в настройках проекта соответствующий флаг - в меню Project (Проект) найти Свойства проекта. Затем в меню Build установить флажок Unsafe code (Небезопасный код):

![](https://metanit.com/sharp/tutorial/pics/8.1.png)

Теперь мы можем приступать к работе с небезопасным кодом и указателями.

## Ключевое слово unsafe
Блок кода или метод, в котором используются указатели, помечается ключевым словом unsafe:

```Csharp
// блок кода, использующий указатели
unsafe
{
     
}
```
Метод, использующий указатели:

```Csharp
unsafe void Test()
{
 
}
```
Также с помощью unsafe можно объявлять структуры и классы:

```Csharp
unsafe struct State
{ 
 
}
 
unsafe class Person
{
 
}
```

## Операции * и &
Ключевой при работе с указателями является операция *, которую еще называют операцией разыменовывания. Операция разыменовывания позволяет получить или установить значение по адресу, на который указывает указатель. Для получения адреса переменной применяется операция &:

```Csharp
unsafe
{
    int* x; // определение указателя
    int y = 10; // определяем переменную
 
    x = &y; // указатель x теперь указывает на адрес переменной y
    Console.WriteLine(*x); // 10
 
    y = y + 20;     // меняем значение
    Console.WriteLine(*x);// 30
 
    *x = 50;
    Console.WriteLine(y); // переменная y=50
}
```
При объявлении указателя указываем тип int* x; - в данном случае объявляется указатель на целое число. Но кроме типа int можно использовать и другие: sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal или bool. Также можно объявлять указатели на типы enum, структуры и другие указатели.

Выражение ```x = &y;``` позволяет нам получить адрес переменной y и установить на него указатель x. До этого указатель x не на что не указывал.

После этого все операции с y будут влиять на значение, получаемое через указатель x и наоборот, так как они указывают на одну и ту же область в памяти.

Для получения значения, которое хранится в области памяти, на которую указывает указатель x, используется выражение *x.

## Получение адреса
Используя преобразование указателя к целочисленному типу, можно получить адрес памяти, на который указывает указатель:

```Csharp
int* x; // определение указателя
int y = 10; // определяем переменную
 
x = &y; // указатель x теперь указывает на адрес переменной y
 
// получим адрес переменной y
ulong addr = (ulong)x;
Console.WriteLine($"Адрес переменной y: {addr}");
```
Для получения адреса используется преобразование в тип uint, long или ulong. Так как значение адреса - это целое число, а на 32-разрядных системах диапазон адресов 0 до 4 000 000 000, а адрес можно получить в переменную uint/int. Соответственно на 64-разрядных системах диапазон доступных адресов гораздо больше, поэтому в данном случае лучше использовать ulong, чтобы избежать ошибки переполнения.

## Указатель на другой указатель
Объявление и использование указателя на указатель:

```Csharp
unsafe
{
    int* x; // определение указателя
    int y = 10; // определяем переменную
 
    x = &y; // указатель x теперь указывает на адрес переменной y
    int** z = &x; // указатель z теперь указывает на адрес, указателя x
    **z = **z + 40; // изменение указателя z повлечет изменение переменной y
    Console.WriteLine(y); // переменная y=50
    Console.WriteLine(**z); // переменная **z=50
}
```

# Указатели на структуры, члены классов и массивы

## Указатели на типы и операция ->
Кроме указателей на простые типы можно использовать указатели на структуры. А для доступа к полям структуры, на которую указывает указатель, используется операция ->:

```Csharp
unsafe
{
    Point point = new Point(0, 0);
    Console.WriteLine(point);   // X: 0  Y: 0
    Point* p = &point;
 
    p->X = 30;
    Console.WriteLine(p->X);    // 30
 
    // разыменовывание указателя
    (*p).Y = 180;
    Console.WriteLine((*p).Y);  // 180
 
    Console.WriteLine(point);   // X: 30  Y: 180
}
struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
    public Point(int x, int y)
    {
        X = x; Y = y;
    }
    public override string ToString() => $"X: {X}  Y: {Y}";
}
```
Обращаясь к указателю p->X = 30; мы можем получить или установить значение свойства структуры, на которую указывает указатель. Обратите внимание, что просто написать p.X=30 мы не можем, так как p - это не структура Point, а указатель на структуру.

Альтернативой служит операция разыменования: (*p).X = 30;

Стоит отметить, что указатель может указывать только на те структуры, которые не имеют полей ссылочных типов (в том числе полей, которые генерируются компилятором автоматически для автосвойств).

## Указатели на массивы и stackalloc
С помощью ключевого слова stackalloc можно выделить память под массив в стеке. Смысл выделения памяти в стеке в повышении быстродействия кода. Посмотрим на примере вычисления квадратов чисел:

```Csharp
unsafe
{
    const int size = 7;
    int* square = stackalloc int[size]; // выделяем память в стеке под семь объектов int
    int* p = square;
    // вычисляем квадраты чисел от 1 до 7 включая
    for (int i = 1; i <= size; i++, p++)
    {
        // считаем квадрат числа
        *p = i * i;
    }
    for (int i = 0; i < size; i++)
    {
        Console.WriteLine(square[i]);
    }
}
```
Оператор stackalloc принимает после себя массив, на который будет указывать указатель. int* square = stackalloc int[size];.

Для манипуляций с массивом создаем указатель p: int* p = square;, который указывает на первый элемент массива, в котором всего 7 элементов. То есть с помощью указателя p мы сможем перемещаться по массиву square.

Далее в цикле происходит подсчет квадратов чисел от 1 до 7. В цикле для установки значения (квадрата числа - i * i) по адресу, который хранит указатель, выполняется выражение:

```
*p = i * i;
```
Затем происходит инкремент указателя p++, и указатель p смещается вперед на следующий элемент в массиве square.

Чуть более сложный пример - вычисление факториала:

```Csharp
unsafe
{
    const int size = 7;
    int* factorial = stackalloc int[size]; // выделяем память в стеке под семь объектов int
    int* p = factorial;
 
    *(p++) = 1; // присваиваем первой ячейке значение 1 и
    // увеличиваем указатель на 1
    for (int i = 2; i <= size; i++, p++)
    {
        // считаем факториал числа
        *p = p[-1] * i;
    }
    for (int i = 0; i < size; i++)
    {
        Console.WriteLine(factorial[i]);
    }
}
```
Также с помощью оператора stackalloc выделяется память для 7 элементов массива. И также для манипуляций с массивом создаем указатель p: int* p = factorial;, который указывает на первый элемент массива, в котором всего 7 элементов

Далее начинаются уже сами операции с указателем и подсчет факториала. Так как факториал 1 равен 1, то присваиваем первому элементу, на который указывает указатель p, единицу с помощью операции разыменования: *(p++)= 1;

Для установки некоторого значения по адресу указателя применяется выражение: *p=1. Но кроме этого тут происходит также инкремент указателя p++. То есть сначала первому элементу массива присваивается единица, потом указатель p смещается и начинает указывать уже на второй элемент. Мы могли бы написать это так:

```
*p= 1;
p++;
```

Чтобы получить предыдущий элемент и сместиться назад, можно использовать операцию декремента: Console.WriteLine(*(--p));. Обратите внимание, что операции *(--p) и *(p--) различаются, так как в первом случае сначала идет смещение указателя, а затем его разыменовывание. А во втором случае - наоборот.

Затем вычисляем факториал всех остальных шести чисел: *p = p[-1] *i;. Обращение к указателям как к массивам представляет альтернативу операции разыменовывания для получения значения. В данном случае мы получаем значение предыдущего элемента.

И в заключении, используя указатель factorial, выводим факториалы всех семи чисел.

## Оператор fixed и закрепление указателей
Ранее мы посмотрели, как создавать указатели на типы значений, например, int или структуры. Однако кроме структур в C# есть еще и классы, которые в отличие от типов значений, помещают все связанные значения в куче. И в работу данных классов может в любой момент вмешаться сборщик мусора, периодически очищающий кучу. Чтобы фиксировать на все время работы указатели на объекты классов используется оператор fixed.

Допустим, у нас есть класс Point:

```Csharp
class Point
{
    public int x;
    public int y;
    public override string ToString() => $"x: {x}  y: {y}";
}
```
Зафиксируем указатель с помощью оператора fixed:

```Csharp
unsafe
{
    Point point = new Point();
 
    // блок фиксации указателя
    fixed (int* pX = &point.x)
    {
        *pX = 30;
    }
    fixed (int* pY = &point.y)
    {
        *pY = 150;
    }
    // можно совместить оба блока
    /*fixed (int* pX = &point.x, pY = &point.y)
    {
        *pX = 30;
        *pY = 150;
    }*/
    Console.WriteLine(point); // x: 30  y: 150
}
```
Оператор fixed создает блок, в котором фиксируется указатель на поле объекта person. После завершения блока fixed закрепление с переменных снимается, и они могут быть подвержены сборке мусора.

Кроме адреса переменной можно также инициализировать указатель, используя массив, строку или буфер фиксированного размера:

```Csharp
unsafe
{
    int[] nums = { 0, 1, 2, 3, 7, 88 };
    string str = "Привет мир";
    fixed(int* p = nums)
    {
        int third = *(p+2);     // получим третий элемент
        Console.WriteLine(third); // 2
    }
    fixed(char* p = str)
    {
        char forth = *(p + 3);     // получим четвертый элемент
        Console.WriteLine(forth); // в
    }
}
```
При инициализации указателей на строку следует учитывать, что указатель должен иметь тип char*.
