# Классы, структуры и пространства имен

## Классы и объекты

C# является полноценным объектно-ориентированным языком. Это значит, что программу на C# можно представить в виде взаимосвязанных взаимодействующих между собой объектов.

Описанием объекта является **класс**, а объект представляет экземпляр этого класса. Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики. То есть некоторый шаблон - этот шаблон можно назвать классом. Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. И реально существующий человек (фактически экземпляр данного класса) будет представлять объект этого класса.

В принципе ранее уже использовались классы. Например, тип ```string```, который представляет строку, фактически является классом. Или, например, класс ```Console```, у которого метод ```WriteLine()``` выводит на консоль некоторую информацию. Теперь же посмотрим, как мы можем определять свои собственные классы.

По сути класс представляет новый тип, который определяется пользователем. Класс определяется с помощью ключевого слова **сlass**:

```Csharp
class название_класса
{
    // содержимое класса
}
```

После слова **class** идет имя класса и далее в фигурных скобках идет собственно содержимое класса. Например, определим в файле ```Program.cs``` класс Person, который будет представлять человека:

```Csharp
class Person
{
  
}
```

![](https://metanit.com/sharp/tutorial/pics/3.25.png)

Однако такой класс не особо показателен, поэтому добавим в него некоторую функциональность.

## Поля и методы класса

Класс может хранить некоторые данные. Для хранения данных в классе применяются **поля**. По сути **поля класса** - это переменные, определенные на уровне класса.

Кроме того, класс может определять некоторое поведение или выполняемые действия. Для определения поведения в классе применяются методы.

Итак, добавим в класс Person поля и методы:

```Csharp
class Person 
{
    public string name = "Undefined";   // имя
    public int age;                     // возраст
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

В данном случае в классе Person определено поле name, которое хранит имя, и поле age, которое хранит возраст человека. В отличие от переменных, определенных в методах, поля класса могут иметь модификаторы, которые указываются перед полем. Так, в данном случае, чтобы все поля были доступны вне класса Person поля определены с модификатором **public**.

При определении полей мы можем присвоить им некоторые значения, как в примере выше в случае переменной ```name```. Если поля класса не инициализированы, то они получают значения по умолчанию. Для переменных числовых типов это число 0.

Также в классе ```Person``` определен метод ```Print()```. Методы класса имеют доступ к его поля, и в данном случае обращаемся к полям класса ```name``` и ```age``` для вывода их значения на консоль. И чтобы этот метод был виден вне класса, он также определен с модификатором **public**.

## Создание объекта класса  

После определения класса мы можем создавать его объекты. Для создания объекта применяются **конструкторы**. По сути конструкторы представляют специальные методы, которые называются так же как и класс, и которые вызываются при создании нового объекта класса и выполняют инициализацию объекта. Общий синтаксис вызова конструктора:

```Csharp
new конструктор_класса(параметры_конструктора);
```

Сначала идет оператор ```new```, который выделяет память для объекта, а после него идет вызов **конструктора**.

## Конструктор по умолчанию

Если в классе не определено ни одного конструктора (как в случае с нашим классом Person), то для этого класса автоматически создается пустой конструктор по умолчанию, который не принимает никаких параметров.

Теперь создадим объект класса Person:

```Csharp
Person tom = new Person();  // создание объекта класса Person
 
// определение класса Person
class Person 
{
    public string name = "Undefined";
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

Для создания объекта ```Person``` используется выражение new ```Person()```. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта ```Person```. А переменная ```tom``` получит ссылку на созданный объект, и через эту переменную мы можем использовать данный объект и обращаться к его функциональности.

## Обращение к функциональности класса

Для обращения к функциональности класса - полям, методам (а также другим элементам класса) применяется точечная нотация точки - после объекта класса ставится точка, а затем элемент класса:

```Csharp
объект.поле_класса
объект.метод_класса(параметры_метода)
```

Например, обратимся к полям и методам объекта ```Person```:


```Csharp
Person tom = new Person();  // создание объекта класса Person
 
// Получаем значение полей в переменные
string personName = tom.name;
int personAge = tom.age;
Console.WriteLine($"Имя: {personName}  Возраст {personAge}");   // Имя: Undefined  Возраст: 0
 
// устанавливаем новые значения полей
tom.name = "Tom";
tom.age = 37;
 
// обращаемся к методу Print
tom.Print();    // Имя: Tom  Возраст: 37
 
class Person 
{
    public string name = "Undefined";
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

Консольный вывод данной программы:  

```
Имя: Undefined	Возраст: 0
Имя: Tom	Возраст: 37
```

## Константы классы

Кроме полей класс может определять для хранения данных константы. В отличие от полей из значение устанавливается один раз непосредственно при их объявлении и впоследствии не может быть изменено. Кроме того, константы хранят некоторые данные, которые относятся не к одному объекту, а ко всему классу в целом. И для обращения к константам применяется не имя объекта, а имя класса:

```Csharp
Person tom = new Person();
tom.name = "Tom";
tom.age = 37;
tom.Print();    // Person: Tom - 37
 
Console.WriteLine(Person.type); // Person
// Person.type = "User";    // !Ошибка: изменить константу нельзя
 
class Person
{
    public const string type = "Person";
    public string name = "Undefined";
    public int age;
    public void Print() => Console.WriteLine($"{type}: {name} - {age}");
}
```

Здесь в классе ```Person``` определена константа ```type```, которая хранит название класса:

```Csharp
public const string type = "Person";
```

Название класса не зависит от объекта. Мы можем создать много объектов ```Person```, но название класса от этого не должно измениться - оно относится ко всем объектам Person и не должно меняться. Поэтому название типа можно сохранить в виде константы.

Стоит отметить, что константе сразу при ее определении необходимо присвоить значение.

Подобно обычным полям мы можем обращаться к константам класса внутри этого класса. Например, в методе ```Print``` значение константы выводится на консоль.

Однако если мы хотим обратиться к константе вне ее класса, то для обращения необходимо использовались имя класса:

```Csharp
Console.WriteLine(Person.type); // Person
```

Таким образом, если необходимо хранить данные, которые относятся ко всему классу в целом, то можно использовать константы.

## Добавление класса в Visual Studio

Обычно классы помещаются в отдельные файлы. Нередко для одного класса предназначен один файл. И Visual Studio предоставляет по умолчанию встроенные шаблоны для добвления класса.

Для добавления класса нажмем в Visual Studio правой кнопкой мыши на название проекта:

![](https://metanit.com/sharp/tutorial/pics/3.39.png)

В появившемся контекстном меню выберем пункт **Add -> New Item... (или Add -> Class...)**

В открывшемся окне добавления нового элемента убедимся, что в центральной части с шаблонами элементов у нас выбран пункт **Class**. А внизу окна в поле **Name** введем название добавляемого класса - пусть он будет назваться **Person**:

![](https://metanit.com/sharp/tutorial/pics/3.40.png)

В качестве названия класса можно вводить как Person, так и Person.cs. И после нажатия на кнопку добавления в проект будет добавлен новый класс:

![](https://metanit.com/sharp/tutorial/pics/3.41.png)

В файле Person.cs определим следующий код:

```Csharp
class Person
{
    public string name = "Undefined";
    public void Print()
    {
        Console.WriteLine($"Person {name}");
    }
}
```

Здесь определен класс ```Person``` с одним полем name и методом ```Print```

В файле ```Program.cs```, который представляет основной файл программы используем класс ```Person```:

![](https://metanit.com/sharp/tutorial/pics/3.42.png)

Таким образом, мы можем определять классы в отдельных файлах и использовать их в программе.






# Конструкторы, инициализаторы и деконструкторы

## Создание конструкторов

Выше для создания объекта использовался конструктор по умолчанию. Однако мы сами можем определить свои конструкторы. Как правило, конструктор выполняет инициализацию объекта. При этом если в классе определяются свои конструкторы, то он лишается конструктора по умолчанию.

На уровне кода конструктор представляет метод, который называется по имени класса, который может иметь параметры, но для него не надо определять возвращаемый тип. Например, определим в классе ```Person``` простейший конструктор:

```Csharp
Person tom = new Person();  // Создание объекта класса Person
 
tom.Print();    // Имя: Tom  Возраст: 37
 
class Person 
{
    public string name;
    public int age;

    public Person()
    {
        Console.WriteLine("Создание объекта Person");
        name = "Tom";
        age = 37;
    }
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

Итак, здесь определен конструктор, который выводит на консоль некоторое сообщение и инициализирует поля класса.


```Csharp
public Person()
{
    Console.WriteLine("Создание объекта Person");
    name = "Tom";
    age = 37;
}
```

Конструкторы могут иметь модификаторы, которые указываются перед именем конструктора. Так, в данном случае, чтобы конструктор был доступен вне класса Person, он определен с модификатором ```public```.

Определив конструктор, мы можем вызвать его для создания объекта ```Person```:

```Csharp
Person tom = new Person();  // Создание объекта Person
```

В данном случае выражение ```Person()``` как раз представляет вызов определенного в классе конструктора (это больше не автоматический конструктор по умолчанию, которого у класса теперь нет). Соответственно при его выполнении на консоли будет выводиться строка "Создание объекта Person"

Подобным образом мы можем определять и другие конструкторы в классе. Например, изменим класс ```Person``` следующим образом:

```Csharp
Person tom = new Person();          // вызов 1-ого конструктора без параметров
Person bob = new Person("Bob");     //вызов 2-ого конструктора с одним параметром
Person sam = new Person("Sam", 25); // вызов 3-его конструктора с двумя параметрами
 
tom.Print();          // Имя: Неизвестно  Возраст: 18
bob.Print();          // Имя: Bob  Возраст: 18
sam.Print();          // Имя: Sam  Возраст: 25
 
class Person 
{
    public string name;
    public int age;
    public Person() { name = "Неизвестно"; age = 18; }      // 1 конструктор
    public Person(string n) { name = n; age = 18; }         // 2 конструктор
    public Person(string n, int a) { name = n; age = a; }   // 3 конструктор
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

Теперь в классе определено три конструктора, каждый из которых принимает различное количество параметров и устанавливает значения полей класса. И мы можем вызвать один из этих конструкторов для создания объекта класса.

Консольный вывод данной программы:

```
Имя: Неизвестно  Возраст: 18
Имя: Bob  Возраст: 18
Имя: Sam  Возраст: 25
```

Стоит отметить, что начиная с версии **C# 9** мы можем сократить вызов конструктора, убрав из него название типа:

```Csharp
Person tom = new ();            // аналогично new Person();
Person bob = new ("Bob");       // аналогично new Person("Bob");
Person sam = new ("Sam", 25);   // аналогично new Person("Sam", 25);
```

## Ключевое слово this

Ключевое слово **this** представляет ссылку на текущий экземпляр/объект класса. В каких ситуациях оно нам может пригодиться?

```Csharp
Person sam = new("Sam", 25); 
sam.Print();          // Имя: Sam  Возраст: 25
 
class Person 
{
    public string name;
    public int age;
    public Person() { name = "Неизвестно"; age = 18; }
    public Person(string name) { this.name = name; age = 18; }
    public Person(string name, int age) 
    { 
        this.name = name; 
        this.age = age; 
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```

В примере выше во втором и третьем конструкторе параметры называются также, как и поля класса. И чтобы разграничить параметры и поля класса, к полям класса обращение идет через ключевое слово this. Так, в выражении

```Csharp
this.name = name;
```

первая часть - this.name означает, что name - это поле текущего класса, а не название параметра name. Если бы у нас параметры и поля назывались по-разному, то использовать слово this было бы необязательно. Также через ключевое слово **this** можно обращаться к любому полю или методу.

## Цепочка вызова конструкторов

В примере выше определены три конструктора. Все три конструктора выполняют однотипные действия - устанавливают значения полей name и age. Но этих повторяющихся действий могло быть больше. И мы можем не дублировать функциональность конструкторов, а просто обращаться из одного конструктора к другому также через ключевое слово this, передавая нужные значения для параметров:

```Csharp
class Person 
{
    public string name;
    public int age;
    public Person() : this("Неизвестно")    // первый конструктор
    { }
    public Person(string name) : this(name, 18) // второй конструктор
    { }
    public Person(string name, int age)     // третий конструктор
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```

В данном случае первый конструктор вызывает второй, а второй конструктор вызывает третий. По количеству и типу параметров компилятор узнает, какой именно конструктор вызывается. Например, во втором конструкторе:

```Csharp
public Person(string name) : this(name, 18)
{ }
```

идет обращение к третьему конструктору, которому передаются два значения. Причем в начале будет выполняться именно третий конструктор, и только потом код второго конструктора.

Стоит отметить, что в примере выше фактически все конструкторы не определяют каких-то других действий, кроме как передают третьему конструктору некоторые значения. Поэтому в реальности в данном случае проще оставить один конструктор, определив для его параметров значения по умолчанию:

```Csharp
Person tom = new();
Person bob = new("Bob");
Person sam = new("Sam", 25);
 
tom.Print();          // Имя: Неизвестно  Возраст: 18
bob.Print();          // Имя: Bob  Возраст: 18
sam.Print();          // Имя: Sam  Возраст: 25
 
class Person 
{
    public string name;
    public int age;
    public Person(string name = "Неизвестно", int age = 18)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```
И если при вызове конструктора мы не передаем значение для какого-то параметра, то применяется значение по умолчанию.

## Инициализаторы объектов

Для инициализации объектов классов можно применять **инициализаторы**. Инициализаторы представляют передачу в фигурных скобках значений доступным полям и свойствам объекта:

```Csharp
Person tom = new Person { name = "Tom", age = 31 };
// или так
// Person tom = new() { name = "Tom", age = 31 };
tom.Print();          // Имя: Tom  Возраст: 31
```

С помощью инициализатора объектов можно присваивать значения всем доступным полям и свойствам объекта в момент создания. При использовании инициализаторов следует учитывать следующие моменты:

- С помощью инициализатора мы можем установить значения только доступных из вне класса полей и свойств объекта. Например, в примере выше поля name и age имеют модификатор доступа public, поэтому они доступны из любой части программы.

- Инициализатор выполняется после конструктора, поэтому если и в конструкторе, и в инициализаторе устанавливаются значения одних и тех же полей и свойств, то значения, устанавливаемые в конструкторе, заменяются значениями из инициализатора.

Инициализаторы удобно применять, когда поле или свойство класса представляет другой класс:

```Csharp
Person tom = new Person{ name = "Tom", company = { title = "Microsoft"} };
tom.Print();          // Имя: Tom  Компания: Microsoft
 
class Person
{
    public string name;
    public Company company;
    public Person() 
    { 
        name = "Undefined";
        company = new Company();
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Компания: {company.title}");
}
 
class Company
{
    public string title = "Unknown";
}
```

Обратите внимание, как устанавливается поле company:

```Csharp
company = { title = "Microsoft"}
```

## Деконструкторы

Деконструкторы (не путать с деструкторами) позволяют выполнить декомпозицию объекта на отдельные части.

Например, пусть у нас есть следующий класс ```Person```:

```Csharp
class Person
{
    string name;
    int age;
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
 
    public void Deconstruct(out string personName, out int personAge)
    {
        personName = name;
        personAge = age;
    }
}
```

В этом случае мы могли бы выполнить декомпозицию объекта ```Person``` так:

```Csharp
Person person = new Person("Tom", 33);
 
(string name, int age) = person;
 
Console.WriteLine(name);    // Tom
Console.WriteLine(age);     // 33
```

Значения переменным из деконструктора передаюся по позиции. То есть первое возвращаемое значение в виде параметра personName передается первой переменной - name, второе возващаемое значение - переменной age.

По сути деконструкторы это не более,чем синтаксический сахар. Это все равно, что если бы мы написали:

```Csharp
Person person = new Person("Tom", 33);
 
string name; int age;
person.Deconstruct(out name, out age);
```
При получении значений из декоструктора нам необходимо предоставить столько переменных, сколько деконструктор возвращает значений. Однако бывает, что не все эти значения нужны. И вместо возвращаемых значений мы можем использовать прочерк ```_```. Например, нам надо получить только возраст пользователя:

```Csharp
Person person = new Person("Tom", 33);
 
(_, int age) = person;
 
Console.WriteLine(age);    // 33
```

Поскольку первое возвращаемое значение - это имя пользователя, которое не нужно, в в данном случае вместо переменной прочерк.





# Класс Program и метод Main. Программы верхнего уровня

Точкой входа в программу на языке C# является метод ```Main```. Именно с этого метода начинается выполнение программы на C#. И программа на C# должна обязательно иметь метод ```Main```. Однако может возникнуть вопрос, какой еще метод ```Main```, если, например, Visual Studio 2022 по умолчанию создает проект консольного приложения со следующим кодом:

```Csharp
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");
```

И эта программа никаких методов ```Main``` не содержит, но при этом нормально выполняется и выводит на консоль строку "Hello, World!", как и запланировано. Это так называемая программа верхнего уровня (top-level program). А вызов Console.WriteLine("Hello, World!") представляет инструкцию вехнего уровня (top-level statement).

Однако в реальности этот код неявно помещается компилятором в метод ```Main```, который, в свою очередь, помещается в класс ```Program```. В действительности название класса может быть любым (как правило, это класс ```Program```, собственно поэтому генерируемый по умолчанию файл кода называется ```Program.cs```). Но метод ```Main``` является обязательной частью консольного приложения. Поэтому выше представленный код фактически эквивалентен следующей программе:

```Csharp
class Program
{
    static void Main(string[] args)
    {
        // See https://aka.ms/new-console-template for more information
        Console.WriteLine("Hello, World!");
    }
}
```

Определение метода **Main** обязательно начинается с модификатора static, которое указывает, что метод Main - статический. Позже мы подробнее разберем, что все это значит.

Возвращаемым типом метода **Main** обязательно является тип **void**. Кроме того, в качестве параметра он принимает массив строк - ```string[] args``` - в реальной программе это те параметры, через которые при запуске программы из консоли мы можем передать ей некоторые значения. Внутри метода располагаются действия, которые выполняет программа.

До Visual Studio 2022 все предыдущие студии создавали по умолчанию примерно такой код. Но начиная с Visual Studio 2022 нам необязательно вручную определять класс ```Program``` и в нем метод ```Main``` - компилятор генерирует их самостоятельно.

Если мы определяем какие-то переменные, константы, методы и обращаемся к ним, они помещаются в метод ```Main```. Например, следующая программа верхнего уровня

```Csharp
string hello = "Hello METANIT.COM";
 
Print(hello);
 
void Print(string message)
{
    Console.WriteLine(message);
}
```

будет аналогична следующей программе:

```Csharp
class Program
{
    static void Main(string[] args)
    {
        string hello = "Hello METANIT.COM";
 
        Print(hello);
 
        void Print(string message)
        {
            Console.WriteLine(message);
        }
    }
}
```

Если определяются новые типы, например, классы, то они помещаются вне класса ```Program```. Например, код:

```Csharp
Person tom = new();
tom.SayHello();
 
class Person
{ 
    public void SayHello() =>Console.WriteLine("Hello");
}
```

будет аналогичен следующему

```Csharp
class Program
{
    static void Main(string[] args)
    {
        Person tom = new();
        tom.SayHello();
    }
}
class Person
{
    public void SayHello() => Console.WriteLine("Hello");
}
```

Однако надо учитывать, что опредления типов (в частности классов) должны идти в конце файла после инструкций верхнего уровня. То есть:


```Csharp
// инструкции верхнего уровня (top-level statements)
Person tom = new();
tom.SayHello();
 
// определение класса идет после инструкций верхнего уровня
class Person
{
    public void SayHello() => Console.WriteLine("Hello");
}
```

Таким образом, мы можем продолжать писать программы верхнего уровня без явного определения метода ```Main```. Либо мы можем явным образом определить метод ```Main``` и класс ```Program```:

![](https://metanit.com/sharp/tutorial/pics/3.35.png)

И этот код будет выполняться аналогичным образом, как если бы мы не использовали класс ```Program``` и метод ```Main```.

# Структуры

Наряду с классами структуры представляют еще один способ создания собственных типов данных в C#. Более того многие примитивные типы, например, int, double и т.д., по сути являются структурами.

## Определение структуры

Для определения структуры применяется ключевое слово **struct**:

```Csharp
struct имя_структуры
{
    // элементы структуры
}
```

После слова **struct** идет название структуры и далее в фигурных скобках размещаются элементы структуры - поля, методы и т.д.

Например, определим структуру, которая будет называться ```Person``` и которая будет представлять человека:

```Csharp
struct Person
{
}   
```

Как и классы, структуры могут хранить состояние в виде полей (переменных) и определять поведение в виде методов. Например, добавим в структуру ```Person``` пару полей и метод:

```Csharp
struct Person
{
    public string name;
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```
В данном случае определены две переменные - name и age для хранения соответственно имени и возраста человека и метод Print для вывода информации о человеке на консоль.

И как и в случае с классами, для обращения к функциональности структуры - полям, методам и другим компонентам структуры применяется точечная нотация - после объекта структуры ставится точка, а затем указывается компонент структуры:

```Csharp
объект.поле_структуры
объект.метод_структуры(параметры_метода)
```

## Создание объекта структуры

### Инициализация с помощью конструктора

Для использования структуры ее необходмо инициализировать. Для инициализации создания объектов структуры, как и в случае с классами, применяется вызов конструктура с оператором new. Даже если в коде стуктуры не определено ни одного конструктора, тем не менее имеет как минимум один конструктор - конструктор по умолчанию, который генерируется компилятором. Этот конструктор не принимает параметров и создает объект структуры со значениями по умолчанию.

```Csharp
new название_структуры();
```
Например, создадим объект структуры ```Person``` с помощью конструктора по умолчанию:

```Csharp
Person tom = new Person();  // вызов конструктора
// или так 
// Person tom = new();
 
tom.name = "Tom";   // изменяем значение по умолчанию в поле name
 
tom.Print();    // Имя: Tom  Возраст: 0
 
struct Person
{
    public string name;
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```
В данном случае создается объект tom. Для его создания вызывается конструктор по умолчанию, который устанавливает значения по умолчанию для его полей. Для числовых данных это значение 0, поэтому поле age будет иметь значение 0. Для строк это значение null, которое указывает на отсутствие значения. Но далее, если поля доступны (а в данном случае поскольку они имеют модификатор public они доступны), мы можем измениь их значения. Так, здесь полю name присваивается строка "Tom". Соответственно при выполнении метода Print() мы получим следующий консольный вывод:

```
Имя: Tom  Возраст: 0
```

### Непосредственная иницилизация полей

Если все поля структуры доступны (как в случае с полями структуры Person, который имеют модификатор **public**), то структуру можно инициализировать без вызова конструктора. В этом случае необходимо присвоить значения всем полям структуры перед получением значений полей и обращением к методам структуры. Например:

```Csharp
Person tom;         // не вызываем конструктор
// инициализация полей
tom.name = "Sam";
tom.age = 37;
 
tom.Print();    // Имя: Sam  Возраст: 37
 
struct Person
{
    public string name;
    public int age;
 
    public void Print()
    {
        Console.WriteLine($"Имя: {name}  Возраст: {age}");
    }
}
```

## Инициализация полей по умолчанию

Стоит отметить, что начиная с версии C# 10, мы можем напрямую инициализировать поля структуры при их определении (до C# 10 это делать было нельзя):

```Csharp
Person tom = new Person();
tom.Print();    // Имя:Tom  Возраст: 1
 
struct Person
{
    // инициализация полей значениями по умолчанию - доступна с C#10
    public string name = "Tom";
    public int age = 1;
    public Person() { }
    public void Print() =>Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```
Однако даже в этом случае, несмотря на значения по умолчанию, необходимо явно определить и вызывать конструктор, если мы хотим использоват эти значения.

## Конструкторы структуры

Как и класс, структура может определять конструкторы. Однако, если в структуре определяется конструктор, то в нем обязательно надо инициализировать все поля структуры.

Например, добавим в структуру ```Person``` конструктор:


```Csharp
Person tom = new();
Person bob = new("Bob");
Person sam = new("Sam", 25);
 
tom.Print();    // !!!! Имя:   Возраст: 0
bob.Print();    // Имя: Bob  Возраст: 1 
sam.Print();    // Имя: Sam  Возраст: 25
 
struct Person
{
    public string name;
    public int age;
 
    public Person(string name = "Tom", int age = 1)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```

В данном случае в структуре Person определен конструктор с двумя параметрами, для которых предоставлены значения по умолчания. Однако обратите внимание на создание первого объекта структуры:

```Csharp
Person tom = new(); // по прежнему используется конструктор без параметров по умолчанию
tom.Print();    // !!!! Имя:   Возраст: 0
```
Здесь по-прежнему применяется конструктор по умолчанию, тогда как при инициализации остальных двух переменных структуры применяется явно определенный конструктор.

Однако начиная с версии C# 10 мы можем определить свой конструктор без параметров:

```Csharp
Person tom = new();
 
tom.Print();    // Имя: Tom  Возраст: 37
 
struct Person
{
    public string name;
    public int age;
 
    public Person()
    {
        name = "Tom";
        age = 37;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}   
```
Опять же при определении конструктора без параметров необходимо инициализировать все поля структуры.

В случае если нам необходимо вызывать конструкторы с различным количеством параметров, то мы можем, как и в случае с классами, вызывать их по цепочке:

```Csharp
Person tom = new();
Person bob = new("Bob");
Person sam = new("Sam", 25);
 
tom.Print();    // Имя: Tom  Возраст: 1
bob.Print();    // Имя: Bob  Возраст: 1 
sam.Print();    // Имя: Sam  Возраст: 25
 
struct Person
{
    public string name;
    public int age;
 
    public Person() : this("Tom")
    { }
    public Person(string name) : this(name, 1)
    { }
    public Person(string name, int age)
    {
        this.name = name;
        this.age = age;
    }
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```
Конструкторы по прежнему должны инициализировать значения всех полей, однако поскольку при вызове любого конструктора цепочка все равно закончится на последнем конструкторе, который выполняет инициализацию, то инициализацию полей в других конструкторах можно не делать. Консольный вывод программы:

```
Имя: Tom  Возраст: 1
Имя: Bob  Возраст: 1 
Имя: Sam  Возраст: 25
```

## Инициализатор структуры

Также, как и для класса, можно использовать инициализатор для создания структуры:

```Csharp
Person tom = new Person { name = "Tom", age = 22 };
 
tom.Print();    // Имя: Tom  Возраст: 22
 
struct Person
{
    public string name;
    public int age;
    public void Print() => Console.WriteLine($"Имя: {name}  Возраст: {age}");
}
```
При использовании инициализатора сначала вызывается конструктор без параметров: если мы явным образом не определили конструктор без параметров, то вызывается конструктор по умолчанию. А затем его полям присваиваются соответствующие значения.

## Копирование структуры с помощью with

Если нам необходимо скопировать в один объект структуры значения из другого с небольшими изменениями, то мы можем использовать оператор **with**:

```Csharp
Person tom = new Person { name = "Tom", age = 22 };
Person bob = tom with { name = "Bob" };
bob.Print();    // Имя: Bob  Возраст: 22
```
В данном случае объект bob получает все значения объекта tom, а затем после оператора with в фигурных скобках указывается поля со значениями, которые мы хотим изменить.

```
1) Переменные структуры хранят не ссылку на объект, а сам объект (у вас это не очевидно, хотя и можно догадаться). То есть это значимый тип, а не ссылочный.
2) Значит если одной структуре присвоить другую, то Скопируются Все Поля одной структуры в другую, а не ссылка, как было бы с классами.
3) Т.к. переменная хранит сами данные, а не ссылку на них, то доступ к полям осуществляется быстрее и есть некоторая экономия памяти.
4) Структуры не поддерживают наследование
```

# Типы значений и ссылочные типы

Ранее мы рассматривали следующие элементарные типы данных: int, byte, double, string, object и др. Также есть сложные типы: структуры, перечисления, классы. Все эти типы данных можно разделить на типы значений, еще называемые значимыми типами, (value types) и ссылочные типы (reference types). Важно понимать между ними различия.

Типы значений:

- Целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong)

- Типы с плавающей запятой (float, double)

- Тип decimal

- Тип bool

- Тип char

- Перечисления enum

- Структуры (struct)

Ссылочные типы:

- Тип object

- Тип string

- Классы (class)

- Интерфейсы (interface)

- Делегаты (delegate)

В чем же между ними различия? Для этого надо понять организацию памяти в .NET. Здесь память делится на два типа: **стек** и **куча (heap)**. Параметры и переменные метода, которые представляют типы значений, размещают свое значение в стеке. 

Стек представляет собой структуру данных, которая растет снизу вверх: каждый новый добавляемый элемент помещается поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. 

Физически стек - это некоторая область памяти в адресном пространстве.

Когда программа только запускается на выполнение, в конце блока памяти, зарезервированного для стека устанавливается указатель стека. При помещении данных в стек указатель переустанавливается таким образом, что снова указывает на новое свободное место. При вызове каждого отдельного метода в стеке будет выделяться область памяти или фрейм стека, где будут храниться значения его параметров и переменных.

Например:

```Csharp
class Program
{
    static void Main(string[] args)
    {
        Calculate(5);
    }
 
    static void Calculate(int t)
    {
        int x = 6;
        int y = 7;
        int z = y + t;
    }
}
```

При запуске такой программы в стеке будут определяться два фрейма - для метода ```Main``` (так как он вызывается при запуске программы) и для метода ```Calculate```:

![](https://metanit.com/sharp/tutorial/pics/2.4.png)

При вызове этого метода ```Calculate``` в его фрейм в стеке будут помещаться значения ```t```, ```x```, ```y``` и ```z```. Они определяются в контексте данного метода. Когда метод отработает, область памяти, которая выделялась под стек, впоследствии может быть использована другими методами.

Причем если параметр или переменная метода представляет тип значений, то в стеке будет храниться непосредсвенное значение этого параметра или переменной. Например, в данном случае переменные и параметр метода ```Calculate``` представляют значимый тип - тип ```int```, поэтому в стеке будут храниться их числовые значения.

Ссылочные типы хранятся в куче или хипе, которую можно представить как неупорядоченный набор разнородных объектов. Физически это остальная часть памяти, которая доступна процессу.

При создании объекта ссылочного типа в стеке помещается ссылка на адрес в куче (хипе). Когда объект ссылочного типа перестает использоваться, в дело вступает автоматический сборщик мусора: он видит, что на объект в хипе нету больше ссылок, условно удаляет этот объект и очищает память - фактически помечает, что данный сегмент памяти может быть использован для хранения других данных.

Так, в частности, если мы изменим метод Calculate следующим образом:

```Csharp
static void Calculate(int t)
{
    object x = 6;
    int y = 7;
    int z = y + t;
}
```

То теперь значение переменной x будет храниться в куче, так как она представляет ссылочный тип object, а в стеке будет храниться ссылка на объект в куче.

![](https://metanit.com/sharp/tutorial/pics/2.5.png)

## Составные типы

Теперь рассмотим ситуацию, когда тип значений и ссылочный тип представляют составные типы - структуру и класс:

```Csharp
State state1 = new State(); // State - структура, ее данные размещены в стеке
Country country1 = new Country(); // Country - класс, в стек помещается ссылка на адрес в хипе
                                  // а в хипе располагаются все данные объекта country1
struct State
{
    public int x;
    public int y;
}
class Country
{
    public int x;
    public int y;
}
```

Здесь в методе Main в стеке выделяется память для объекта state1. Далее в стеке создается ссылка для объекта country1 (Country country1), а с помощью вызова конструктора с ключевым словом new выделяется место в хипе (new Country()). Ссылка в стеке для объекта country1 будет представлять адрес на место в хипе, по которому размещен данный объект..

![](https://metanit.com/sharp/tutorial/pics/2.2.png)

Таким образом, в стеке окажутся все поля структуры state1 и ссылка на объект country1 в хипе.

Но, допустим, в структуре State также определена переменная ссылочного типа Country. Где она будет хранить свое значение, если она определена в типе значений?

```Csharp
State state1 = new State();
Country country1 = new Country();
 
struct State
{
    public int x;
    public int y;
    public Country country;
    public State()
    {
        x = 0;
        y = 0;
        country = new Country();
    }
}
class Country
{
    public int x;
    public int y;
}
```
Значение переменной state1.country также будет храниться в куче, так как эта переменная представляет ссылочный тип:

![](https://metanit.com/sharp/tutorial/pics/2.62.png)

## Копирование значений

Тип данных надо учитывать при копировании значений. При присвоении данных объекту значимого типа он получает копию данных. При присвоении данных объекту ссылочного типа он получает не копию объекта, а ссылку на этот объект в хипе. Например:

```Csharp
State state1 = new State(); // Структура State
State state2 = new State();
state2.x = 1;
state2.y = 2;
state1 = state2;
state2.x = 5; // state1.x=1 по-прежнему
Console.WriteLine(state1.x); // 1
Console.WriteLine(state2.x); // 5
 
Country country1 = new Country(); // Класс Country
Country country2 = new Country();
country2.x = 1;
country2.y = 4;
country1 = country2;
country2.x = 7; // теперь и country1.x = 7, так как обе ссылки и country1 и country2 
                // указывают на один объект в хипе
Console.WriteLine(country1.x); // 7
Console.WriteLine(country2.x); // 7
```

Так как state1 - структура, то при присвоении state1 = state2 она получает копию структуры state2. А объект класса country1 при присвоении country1 = country2; получает ссылку на тот же объект, на который указывает country2. Поэтому с изменением country2, так же будет меняться и country1.

## Ссылочные типы внутри типов значений

Теперь рассмотрим более изощренный пример, когда внутри структуры у нас может быть переменная ссылочного типа, например, какого-нибудь класса:

```Csharp
State state1 = new State();
State state2 = new State();
 
state2.country = new Country();
state2.country.x = 5;
state1 = state2;
state2.country.x = 8; // теперь и state1.country.x=8, так как state1.country и state2.country
                      // указывают на один объект в хипе
Console.WriteLine(state1.country.x); // 8
Console.WriteLine(state2.country.x); // 8
 
struct State
{
    public int x;
    public int y;
    public Country country;
    public State()
    {
        x = 0;
        y = 0;
        country = new Country(); // выделение памяти для объекта Country
    }
}
class Country
{
    public int x;
    public int y;
}
```
Переменные ссылочных типов в структурах также сохраняют в стеке ссылку на объект в хипе. И при присвоении двух структур state1 = state2; структура state1 также получит ссылку на объект country в хипе. Поэтому изменение state2.country повлечет за собой также изменение state1.country.

![](https://metanit.com/sharp/tutorial/pics/2.3.png)

## Объекты классов как параметры методов

Организацию объектов в памяти следует учитывать при передаче параметров по значению и по ссылке. Если параметры методов представляют объекты классов, то использование параметров имеет некоторые особенности. Например, создадим метод, который в качестве параметра принимает объект Person:

```Csharp
Person p = new Person { name = "Tom", age = 23 };
ChangePerson(p);
 
Console.WriteLine(p.name); // Alice
Console.WriteLine(p.age); // 23
 
void ChangePerson(Person person)
{
    // сработает
    person.name = "Alice";
    // сработает только в рамках данного метода
    person = new Person { name = "Bill", age = 45 };
    Console.WriteLine(person.name); // Bill
}
 
class Person
{
    public string name = "";
    public int age;
}
```
При передаче объекта класса по значению в метод передается копия ссылки на объект. Эта копия указывает на тот же объект, что и исходная ссылка, потому мы можем изменить отдельные поля и свойства объекта, но не можем изменить сам объект. Поэтому в примере выше сработает только строка person.name = "Alice".

А другая строка person = new Person { name = "Bill", age = 45 } создаст новый объект в памяти, и person теперь будет указывать на новый объект в памяти. Даже если после этого мы его изменим, то это никак не повлияет на ссылку p в методе Main, поскольку ссылка p все еще указывает на старый объект в памяти.

Но при передаче параметра по ссылке (с помощью ключевого слова **ref**) в метод в качестве аргумента передается сама ссылка на объект в памяти. Поэтому можно изменить как поля и свойства объекта, так и сам объект:

```Csharp
Person p = new Person { name = "Tom", age = 23 };
ChangePerson(ref p);
 
Console.WriteLine(p.name); // Bill
Console.WriteLine(p.age); // 45
 
void ChangePerson(ref Person person)
{
    // сработает
    person.name = "Alice";
    // сработает
    person = new Person { name = "Bill", age = 45 };
}
 
class Person
{
    public string name = "";
    public int age;
}
```

Операция new создаст новый объект в памяти, и теперь ссылка person (она же ссылка p из метода Main) будет указывать уже на новый объект в памяти.

# Область видимости (контекст) переменных и констант

Каждая переменная доступна в рамках определенного контекста или области видимости. Вне этого контекста переменная уже не существует.

Существуют различные контексты:

- Контекст класса. Переменные, определенные на уровне класса, доступны в любом методе этого класса. Их еще называют глобальными переменными или **полями**

- Контекст метода. Переменные, определенные на уровне метода, являются локальными и доступны только в рамках данного метода. В других методах они недоступны

- Контекст блока кода. Переменные, определенные на уровне блока кода, также являются локальными и доступны только в рамках данного блока. Вне своего блока кода они не доступны.

Например, пусть класс ```Program``` определен следующим образом:

```Csharp
Person tom = new();
tom.PrintName();
tom.PrintSurname();
 
class Person                            // начало контекста класса
{
    string type = "Person";             // переменная уровня класса
    public void PrintName()             // начало контекста метода PrintName
    {
        string name = "Tom";            // переменная уровня метода
 
        {                               // начало контекста блока кода
            string shortName = "Tomas"; // переменная уровня блока кода
            Console.WriteLine(type);    // в блоке доступна переменная класса
            Console.WriteLine(name);    // в блоке доступна переменная окружающего метода
            Console.WriteLine(shortName);// в блоке доступна переменная этого же блока
        }                               // конец контекста блока кода, переменная shortName уничтожается
 
        Console.WriteLine(type);        // в методе доступна переменная класса
        Console.WriteLine(name);        // в методе доступна переменная этого же метода
        //Console.WriteLine(shortName); //так нельзя, переменная c определена в блоке кода
        //Console.WriteLine(surname);     //так нельзя, переменная surname определена в другом методе
 
    }       // конец контекста метода PrintName, переменная name уничтожается
 
    public void PrintSurname()      // начало контекста метода PrintSurname
    {
        string surname = "Smith";   // переменная уровня метода
 
        Console.WriteLine(type);        // в методе доступна переменная класса
        Console.WriteLine(surname);     // в методе доступна переменная этого же метода 
    }       // конец конекста метода PrintSurname, переменная surname уничтожается
 
}   // конец контекста класса, переменная type уничтожается
```

Здесь определенно четыре переменных: type, name, shortName и surname. Каждая из них существует в своем контексте. Переменная type существует в контексте всего класса Person и доступна в любом месте и блоке кода в методах PrintName и PrintSurname.

Переменная name существует только в рамках метода PrintName. Также как и переменная surname существует в рамках метода PrintSurname. В методе PrintName мы не можем обратиться к переменной surname, так как она в другом контексте.

Переменная shortName существует только в блоке кода, границами которого являются открывающая и закрывающая фигурные скобки. Вне его границ переменная shortName не существует и к ней нельзя обратиться.

Нередко границы различных контекстов можно ассоциировать с открывающимися и закрывающимися фигурными скобками, как в данном случае, которые задают пределы блока кода, метода, класса.

При работе с переменными надо учитывать, что локальные переменные, определенные в методе или в блоке кода, скрывают переменные уровня класса, если их имена совпадают:

```Csharp
class Person 
{
    string name = "Tom";             // переменная уровня класса
    public void PrintName() 
    {
        string name = "Tomas";      // переменная уровня метода скрывает переменную уровня класса
 
        Console.WriteLine(name);    // Tomas
    } 
}
```
При объявлении переменных также надо учитывать, что в одном контексте нельзя определить несколько переменных с одним и тем же именем.

# Пространства имен

Обычно определяемые классы и другие типы в .NET не существуют сами по себе, а заключаются в специальные контейнеры - **пространства имен**. Пространства имен позволяют организовать код программы в логические блоки, поволяют объединить и отделить от остального кода некоторую функциональность, которая связана некоторой общей идеей или которая выполняет определенную задачу.

Для определения пространства имен применяется ключевое слово namespace, после которого идет название название пространства имен:

```Csharp
namespace имя_пространства_имен
{
    // содержимое пространства имен
}
```

Например, определим в файле ```Program.cs``` пространство имен, которое будет называться ```Base```

```Csharp
namespace Base
{
    class Person
    {
        string name;
        public Person(string name) => this.name = name;
        public void Print() => Console.WriteLine($"Имя: {name}");
    }
}
```

Здесь пространство имен содержит класс Person, которой имеет одну переменную - name, конструктор и метод Print.


![](https://metanit.com/sharp/tutorial/pics/3.27.png)

Теперь попробуем использовать класс Person:

```Csharp
Person tom = new Person("Tom"); // Ошибка - Visual Studio не видит класс Person
tom.Print();
 
namespace Base
{
    class Person
    {
        string name;
        public Person(string name) => this.name = name;
        public void Print() => Console.WriteLine($"Имя: {name}");
    }
}
```

Здесь на первой строке мы столкнемся с ошибкой, так как Visual Studio не может найти класс Person. Чтобы все-таки обратиться к классу Person, необходимо использовать полное имя этого класса с учетом пространства имен:

```Csharp
Base.Person tom = new("Tom");
tom.Print();          // Имя: Tom
 
namespace Base
{
    class Person
    {
        string name;
        public Person(string name) => this.name = name;
        public void Print() => Console.WriteLine($"Имя: {name}");
    }
}
```
 
Поскольку класс ````Person``` располагается в пространстве имен ```Base```, то его полное имя - Base.Person. Соответственно, используя это имя, мы можем обращаться к данному классу вне его пространства имен.

## Подключение пространства имен

Однако полное имя класса с учетом пространства имен добавляет в код избыточность - особенно, если пространство имен содержит множество классов, которые мы хотим использовать. И чтобы не писать полное имя класса, мы можем просто подключить пространство имен с помощью директивы **using**:

```Csharp
using Base; // подключение пространства имен Base
 
Person tom = new("Tom");
tom.Print();     // Имя: Tom
 
namespace Base
{
    class Person
    {
        string name;
        public Person(string name) => this.name = name;
        public void Print() => Console.WriteLine($"Имя: {name}");
    }
}
```

![](https://metanit.com/sharp/tutorial/pics/3.28.png)


## Вложенные пространства имен

Одни пространства имен могут содержать другие. Например:

```Csharp
namespace Base
{
    namespace PersonTypes
    {
        class Person
        {
            string name;
            OrganisationTypes.Company company;
            public Person(string name, OrganisationTypes.Company company) 
            { 
                this.name = name; 
                this.company = company; 
            }
            public void Print()
            {
                Console.WriteLine($"Имя: {name} ");
                company.Print();
            }
        }
    }
    namespace OrganisationTypes
    {
        class Company
        {
            string title;
            public Company(string title) => this.title = title;
            public void Print() => Console.WriteLine($"Название компании: {title}");
        }
    }
}
```

В данном случае классы ```Person``` и ```Company``` находятся в разных вложенных пространствах имен, поэтому чтобы в классе ```Person``` использовать класс ```Company```, надо прописывать имя класса с учетом его пространства имен: ```OrganisationTypes.Company``` (так как оба класса в итоге находятся в общем пространстве - Base, то его имя можно не указывать в названии класса) или подключать пространство имен класса Company с помощью директивы **using**.

Для обращения к этим классам вне пространства Base необходимо использовать всю цепочку пространств имен:

```Csharp
using Base.PersonTypes; // подключение пространства имен Base.PersonTypes для класса Person
 
Base.OrganisationTypes.Company microsoft = new("Microsoft");
Person tom = new("Tom", microsoft);
tom.Print();     // Имя: Tom   Название компании: Microsoft
 
namespace Base
{
    namespace PersonTypes
    {
        class Person
        {
            string name;
            OrganisationTypes.Company company;
            public Person(string name, OrganisationTypes.Company company) 
            { 
                this.name = name; 
                this.company = company; 
            }
            public void Print()
            {
                Console.WriteLine($"Имя: {name} ");
                company.Print();
            }
        }
    }
    namespace OrganisationTypes
    {
        class Company
        {
            string title;
            public Company(string title) => this.title = title;
            public void Print() => Console.WriteLine($"Название компании: {title}");
        }
    }
}
```

## Пространства имен уровня файла


Начиная с .NET 6 и C# 10 можно определять пространства имен на уровне файла. Например, добавим в проект новый файл с кодом c#. Для этого в Visual Studio нажмем на название проекта правой кнопкой мыши и в появившемся меню выберем пункт Add -> New Item...

![](https://metanit.com/sharp/tutorial/pics/3.29.png)

В окне добавления нового элемента выберем пункт Class и поле Name в качестве имени файла укажем Base.cs

![](https://metanit.com/sharp/tutorial/pics/3.30.png)

После этого в проект будет добавлен файл Base.cs. Удалим из него все содержимое по умолчанию и определим в нем следующий код:

```Csharp
namespace Base;
 
class Person
{
    string name;
    public Person(string name) => this.name = name;
    public void Print() => Console.WriteLine($"Имя: {name} ");
}
```

Директива namespace Base в начале файла указывает, что содержимое файла будет представлять пространство имен Base.

Теперь подключим это пространство имен в файле ```Program.cs```:


```Csharp
using Base; // подключение пространства имен Base
 
Person tom = new("Tom");
tom.Print();
```

# Глобальные пространства имен

Если мы хотим использовать какое-нибудь пространство имен в файлах кода в проекте, то по умолчанию нам надо его подключать во все файлы, где мы планируем его использовать.

Например, пусть у нас в проекте есть три файла с кодом:


![](https://metanit.com/sharp/tutorial/pics/3.33.png)

В файле **Base.cs** определяется класс Company в пространстве **Base**:

```Csharp
namespace Base;
class Company
{
    string title;
    public Company(string title) => this.title = title;
    public void Print() => Console.WriteLine($"Компания: {title}");
}
```
В файле Person.cs определен класс ```Person```, который использует класс ```Company```:

```Csharp
using Base;
 
class Person
{
    string name;
    Company company;
    public Person(string name, Company company)
    {
        this.name = name;
        this.company = company;
    }
    public void Print()
    {
        Console.WriteLine($"Имя: {name}");
        company.Print();
    }
}
```

Чтобы использовать класс Company мы подключаем его пространство имен: using Base;

В классе **Program.cs** используются классы Person и Company:

```Csharp
using Base;
 
Company microsoft = new("Microsoft");
Person tom = new("Tom", microsoft);
tom.Print();
```

Опять же чтобы использовать класс Company, подключается его пространство имен: using Base;

И таких файлов, где надо подключать пространство Base (или какое-то другое) может быть множество. Это не очень удобно. И в .NET 6 для этого предложена концепция **глобальных пространств имен**, который подключаются один раз но сразу во все файлы кода в проекте. Для этого нам достаточно в одном файле прописать директиву:

```Csharp
global using подключаемое_пространство_имен;
```

Например, изменим файл **Program.cs** следующим образом:

```Csharp
global using Base;
 
Company microsoft = new("Microsoft");
Person tom = new("Tom", microsoft);
tom.Print();
```

Теперь пространство Base подключается во все файлы кода в проекте. И из файла **Person.cs** мы можем убрать строку

## Определение глобальных пространств в отдельном файле

Однако вышеуказанный подход опять же может быть не очень удобным, поскольку проще определить глобальные пространство имен, которые подключаются во весь проект где-то в одном месте. И для этого в Visual Studio 2022 мы можем добавить в проект новый файл с кодом C# и в нем определить набор подключаемых пространств имен. Например, добавим в проект файл, который назовем **GlobalUsings.cs** и в котором определим следующее содержимое:

```Csharp
global using System.Text;
global using System.Reflection;
global using Base;
```

И этот набор пространств имен будет автоматически подключаться во все файлы кода в проекте.

![](https://metanit.com/sharp/tutorial/pics/3.34.png)



# Подключение пространств имен по умолчанию

Все классы существуют в некотором пространстве имен, и чтобы эти классы использовать, необходимо подключить их пространства имен, либо использовать полное название класса с указанием его пространства имен. Однако начиная с Visual Studio 2022 и .NET 6 и C# 10 мы можем просто в файле программы написать:

```Csharp
Console.WriteLine("Hello");
```

При этом не подключая явно пространство имен System, где располагается класс Console, тем не менее этот класс будет доступен, и мы его сможем использовать в любом файле кода C# в проекте. Дело в том, что начиная с .NET 6 в проекте по умолчанию подключается ряд наиболее часто используемых пространств имен, поэтому нам их не надо явно подключать. Эта настройка действует на уровне всего проекта. Так, откроем файл проекта. Для этого либо двойным кликом левой кнопкой мыши нажмем на проект, либо нажмем на проект правой кнопкой мыши и в появившемся меню выберем пункт **Edit Project File**


![](https://metanit.com/sharp/tutorial/pics/3.31.png)

После этого Visual Studio откроет нам файл проекта, который будет выглядеть примерно следующим образом:


```xml
<Project Sdk="Microsoft.NET.Sdk">
 
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
 
</Project>
```

Здесь строка

```xml
<ImplicitUsings>enable</ImplicitUsings>
```

точнее элемент <ImplicitUsings> задает подключение некоторого набора пространств имен по умолчанию. Значение **enable** указывает, что эта настройка будет применяться.

Если мы запустим проект на выполнение, то после компиляции проект в проекте в папке **obj/Debug/net6.0** можно будет увидеть файл **[Имя_проекта].GlobalUsings.g.cs** (например, у меня проект называется HelloApp, соответственно файл будет называться **HelloApp.GlobalUsings.g.cs**). Если мы откроем этот файл, то увидим там следующее содержимое:

```Csharp
global using global::System;
global using global::System.Collections.Generic;
global using global::System.IO;
global using global::System.Linq;
global using global::System.Net.Http;
global using global::System.Threading;
global using global::System.Threading.Tasks;
```
Здесь перечислены все те пространства имен, которые подключаются в проект по умолчанию:

```Csharp
System
System.Collections.Generic
System.IO
System.Linq
System.Net.Http
System.Threading
System.Threading.Tasks
```
Стоит отметить, что это набор пространств имен, которые подключаются в проект консольного приложения по умолчанию, у других типов проектов набор подключаемых пространств может отличаться.

## Отключение пространств по умолчанию

В проектах, создаваемых в Visual Studio 2022 для .NET 6 и C# 10 эта возможность включена по умолчанию. Тем не менее при необходимости мы ее можем отключить. Для этого изменим эту настройку следующим образом:

```Csharp
<ImplicitUsings>disable</ImplicitUsings>
```

После этого Visual Studio 2022 подчеркнет нам класс Console, так как он нигде не определен в проекте, а его пространство имен не подключено:

![](https://metanit.com/sharp/tutorial/pics/3.32.png)

В этом случае нам потребуется либо подключить пространство имен System, где располагается класс Console, либо использовать его полное имя:

```Csharp
using System;   // или подключить пространство System
Console.WriteLine("Hello world");
 
// или использовать полное имя класса
System.Console.WriteLine("Hello work");
```

## Подключение и отключение пространств по отдельности

Вместо подключения по умолчанию некоторого набора пространств имен по умолчанию также можно подключать и отключать по отдельности пространств имен. Так, изменим файл проекта следующим образом:


```xml
<Project Sdk="Microsoft.NET.Sdk">
 
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>disable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
   
  <ItemGroup>
    <Using Include="System" />
    <Using Include="System.Threading.Tasks" />
  </ItemGroup>
   
</Project>
```

Здесь атрибут **Include** элемента **Using** подключает пространства имен глобально по всему проекту. Например:

```xml
<Using Include="System" />
```

Подключает пространство System. Соответственно после этого нам не надо его подключать в файлы кода в проекте.

Обратная ситуация - отключение некоторых ненужных пространств имен из тех, которые подключаются по умолчанию. Для этого применяется атрибут **Remove** элемента **Using**:

```xml
<Project Sdk="Microsoft.NET.Sdk">
 
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
   
  <ItemGroup>
    <Using Remove="System" />
    <Using Remove="System.Threading.Tasks"/>
  </ItemGroup>
   
</Project>
```

В данном случае отключаются пространства "System" и "System.Threading.Tasks"

# Создание библиотеки классов

Нередко различные классы и структуры оформляются в виде отдельных библиотек, которые компилируются в файлы dll и затем могут подключаться в другие проекты. Благодаря этому мы можем определить один и тот же функционал в виде библиотеки классов и подключать в различные проекты или передавать на использование другим разработчикам.

Создадим и подключим библиотеку классов.

Возьмем имеющийся проект консольного приложения C#, например, созданный в прошлых темах. В структуре проекта нажмем правой кнопкой на название решения и далее в появившемся контекстном меню выберем **Add -> New Project...** (Добавить новый проект):

![](https://metanit.com/sharp/tutorial/pics/3.16.png)

Далее в списке шаблонов проекта найдем пункт Class Library:

![](https://metanit.com/sharp/tutorial/pics/3.17.png)

Затем дадим новому проекту какое-нибудь название, например, MyLib:

![](https://metanit.com/sharp/tutorial/pics/3.18.png)

После создания этого проекта в решение будет добавлен новый проект, в моем случае с названием MyLib:

![](https://metanit.com/sharp/tutorial/pics/3.19.png)

По умолчанию новый проект имеет один пустой класс Class1 в файле Class1.cs. Мы можем этот файл удалить или переименовать, как нам больше нравится.

Например, переименуем файл Class1.cs в Person.cs, а класс Class1 в Person. Определим в классе Person простейший код:

```Csharp
public class Person
{
    string name;
    public Person(string name) 
    {
        this.name = name;
    }
    public void Print() => Console.WriteLine($"Name: {name}");
}
```
![](https://metanit.com/sharp/tutorial/pics/3.20.png)

Теперь скомпилируем библиотеку классов. Для этого нажмем правой кнопкой на проект библиотеки классов и в контекстном меню выберем пункт **Rebuild**:

![](https://metanit.com/sharp/tutorial/pics/3.21.png)


После компиляции библиотеки классов в папке проекта в каталоге bin/Debug/net6.0 мы сможем найти скомпилированный файл dll (MyLib.dll). Подключим его в основной проект. Для этого в основном проекте нажмем правой кнопкой на узел **Dependencies** и в контекстном меню выберем пункт **Add Project Reference...**:

![](https://metanit.com/sharp/tutorial/pics/3.22.png)

Далее нам откроется окно для добавления библиотек. В этом окне выберем пункт Solution,который позволяет увидеть все библиотеки классов из проектов текущего решения, поставим отметку рядом с нашей библиотекой и нажмем на кнопку OK:

![](https://metanit.com/sharp/tutorial/pics/3.23.png)

Если наша библиотека вдруг представляет файл dll, который не связан ни с каким проектом в нашем решении, то с помощью кнопки **Browse** мы можем найти местоположение файла dll и также его подключить.

После успешного подключения библиотеки в главном проекте изменим файл **Program.cs**, чтобы он использовал класс Person из библиотеки классов:

```Csharp
using MyLib;    // подключение пространства имен из библиотеки классов
 
Person tom = new("Tom");
tom.Print();    // Name: Tom
```

# Модификаторы доступа

Все поля, методы и остальные компоненты класса имеют **модификаторы доступа**. Модификаторы доступа позволяют задать допустимую область видимости для компонентов класса. То есть модификаторы доступа определяют контекст, в котором можно употреблять данную переменную или метод.

В языке C# применяются следующие модификаторы доступа:

- **private**: закрытый или приватный компонент класса или структуры. Приватный компонент доступен только в рамках своего класса или структуры.
- **private protected**: компонент класса доступен из любого места в своем классе или в производных классах, которые определены в той же сборке.

- **protected:** такой компонент класса доступен из любого места в своем классе или в производных классах. При этом производные классы могут располагаться в других сборках.

- **internal**: компоненты класса или структуры доступен из любого места кода в той же сборке, однако он недоступен для других программ и сборок.

- **protected internal**: совмещает функционал двух модификаторов protected и internal. Такой компонент класса доступен из любого места в текущей сборке и из производных классов, которые могут располагаться в других сборках.

- **public**: публичный, общедоступный компонент класса или структуры. Такой компонент доступен из любого места в коде, а также из других программ и сборок.

|Модификаторы|Текущий класс|Производный класс из текущей сборки|Производный класс из другой сборки|Непроизводный класс из текущей сборки|Непроизводный класс из другой сборки|
|:-----------|:----:|:----:|:----:|:----:|:----:|
|private|+|||||
|private protected|+|+||||
|protected|+|+|+|||
|internal|+|+||+||
|protected internal|+|+|+|+||
|public|+|+|+|+|+|

Стоит отметить, что эти модификаторы могут применяться как к компонентам класса, так и к компонентам структуры за тем исключением, что структуры не могут использовать модификаторы private protected, protected и protected internal, поскольку структуры не могут быть унаследованы.

Все классы и структуры, определенные напрямую вне других типов (классов и структур) могут иметь только модификаторы public или internal.

Мы можем явно задать модификатор доступа, а можем его и не указывать:

```Csharp
public class Person
{
    string name;
    public Person(string name) 
    {
        this.name = name;
    }
    public void Print() => Console.WriteLine($"Name: {name}");
}
```

Если для компонентов не определен модификатор доступа, то по умолчанию для них применяется модификатор **private**. Например, в примере выше переменная name неявно будет иметь модификатор **private**.

Классы и структуры, которые объявлены без модификатора и которые расположены вне других типов, по умолчанию имеют доступ **internal**, а вложенные классы и структуры, как и остальные компоненты классов/структур имеют модификатор **private**. Например:

```Csharp
class Phone
{
    struct Camera
    {
 
    }
}
```

Здесь класс Phone не является вложенным ни в один другой класс/структуру, поэтому неявно имеет модификатор **internal**. А структура Camera является вложенной, поэтому, как и другие компоненты класса, неявно имеет модификатор **private**

## Модификаторы в рамках текущего проекта

Посмотрим на примере и создадим следующий класс State:

```Csharp
class State
{
    // все равно, что private string defaultVar;
    string defaultVar ="default";
    // поле доступно только из текущего класса
    private string privateVar = "private";
    // доступно из текущего класса и производных классов, которые определены в этом же проекте
    protected private string protectedPrivateVar = "protected private";
    // доступно из текущего класса и производных классов
    protected string protectedVar = "protected";
    // доступно в любом месте текущего проекта
    internal string internalVar = "internal";
    // доступно в любом месте текущего проекта и из классов-наследников в других проектах
    protected internal string protectedInternalVar = "protected internal";
    // доступно в любом месте программы, а также для других программ и сборок
    public string publicVar = "public";
 
    // по умолчанию имеет модификатор private
    void Print() => Console.WriteLine(defaultVar);
 
    // метод доступен только из текущего класса
    private void PrintPrivate() => Console.WriteLine(privateVar);
 
    // доступен из текущего класса и производных классов, которые определены в этом же проекте
    protected private void PrintProtectedPrivate() => Console.WriteLine(protectedPrivateVar);
 
    // доступен из текущего класса и производных классов
    protected void PrintProtected() => Console.WriteLine(protectedVar);
 
    // доступен в любом месте текущего проекта
    internal void PrintInternal() => Console.WriteLine(internalVar);
 
    // доступен в любом месте текущего проекта и из классов-наследников в других проектах
    protected internal void PrintProtectedInternal() => Console.WriteLine(protectedInternalVar);
 
    // доступен в любом месте программы, а также для других программ и сборок
    public void PrintPublic() => Console.WriteLine(publicVar);
}
```

Так как класс State не имеет явного модификатора, по умолчанию он имеет модификатор internal, поэтому он будет доступен из любого места данного проекта, однако не будет доступен из других программ и сборок.

Класс State имеет шесть полей для каждого уровня доступа. Плюс одна переменная без модификатора, которая является закрытой (private) по умолчанию. А также определено семь методов с разными модификаторами, которые выводят значения соответствующих переменных на консоль. Поскольку все модификаторы позволяют использовать компоненты класса внутри данного класса, то и все переменные класса, в том числе закрытые, у нас доступны всем его методам, так как все находятся в контексте класса State.

Теперь посмотрим, как мы сможем использовать переменные класса State в другом классе, который, допустим, будет называться StateConsumer и который расположен **в том же проекте**:

```Csharp
class StateConsumer
{
    public void PrintState()
    {
        State state = new State();
 
        // обратиться к переменной defaultVar у нас не получится,
        // так как она имеет модификатор private и класс StateConsumer ее не видит
        Console.WriteLine(state.defaultVar); //Ошибка, получить доступ нельзя
 
        // то же самое относится и к переменной privateVar
        Console.WriteLine(state.privateVar); // Ошибка, получить доступ нельзя
 
        // обратиться к переменной protectedPrivateVar не получится,
        // так как класс StateConsumer не является классом-наследником класса State
        Console.WriteLine(state.protectedPrivateVar); // Ошибка, получить доступ нельзя
 
        // обратиться к переменной protectedVar тоже не получится,
        // так как класс StateConsumer не является классом-наследником класса State
        Console.WriteLine(state.protectedVar); // Ошибка, получить доступ нельзя
 
        // переменная internalVar с модификатором internal доступна из любого места текущего проекта
        // поэтому спокойно присваиваем ей значение
        Console.WriteLine(state.internalVar);
 
        // переменная protectedInternalVar так же доступна из любого места текущего проекта
        Console.WriteLine(state.protectedInternalVar);
 
        // переменная publicVar общедоступна
        Console.WriteLine(state.publicVar);
    }
}
```

Таким образом, в классе StateConsumer мы смогли только обратиться к переменным internalVar, protectedInternalVar и publicVar, так как их модификаторы позволяют использовать в данном контексте.

Аналогично дело обстоит и с методами:


```Csharp
class StateConsumer
{
    public void PrintState()
    {
        State state = new State();
 
        state.Print(); //Ошибка, получить доступ нельзя
 
        state.PrintPrivate(); // Ошибка, получить доступ нельзя
 
        state.PrintProtectedPrivate(); // Ошибка, получить доступ нельзя
 
        state.PrintProtected(); // Ошибка, получить доступ нельзя
 
        state.PrintInternal();    // норм
 
        state.PrintProtectedInternal();  // норм
 
        state.PrintPublic();      // норм
    }
}
```

Здесь нам оказались доступны только три метода: PrintInternal, PrintProtectedInternal, PrintPublic, которые имееют соответственно модификаторы internal, protected internal, public.

## Модификаторы в рамках сборок

Допустим, у нас есть проект (и соответственно сборка) MyLib, в которой определены три класса:

```Csharp
namespace MyLib;
// класс доступен из других сборок
public class PublicState
{
    internal void PrintInternal() => Console.WriteLine("internal");
    protected internal void PrintProtectedInternal() => Console.WriteLine("protected internal");
    public void PrintPublic() => Console.WriteLine("public");
 
}
 
// класс доступен только в текущей сборке - по умолчанию internal
class DefaultlState { }
// класс доступен только в текущей сборке
internal class InternalState{  }
```

Здесь классы DefaultlState и InternalState имеют модификатор **internal**, поэтому доступны только в текущем проекте.

Класс PublicState модификатором **public** доступен из других проектов. Однако его методы PrintInternal() и PrintProtectedInternal() доступны только в текущем проекте. Вне текущего проекта доступен только его метод PrintPublic.

Допустим, мы подключаем сборку этого проекта MyLib в другой проект, где есть класс StateConsumer:

```Csharp
using MyLib;
class StateConsumer
{
    public void PrintState()
    {
        // Ошибка DefaultState - по умолчанию internal, поэтому нет доступа
        DefaultState defaultState = new DefaultState();
        // Ошибка InternalState - internal, поэтому нет доступа
        InternalState internalState = new InternalState();
 
        // норм, PublicState - public, доступен из других программ
        PublicState publicState = new PublicState();
        // Ошибка, нет доступа - метод доступен только в свой сборке
        publicState.PrintInternal();
        // Ошибка, нет доступа - метод доступен только в свой сборке
        publicState.PrintProtectedInternal();  // нет доступа
        // норм - общедоступный метод
        publicState.PrintPublic();      // норм
    }
}
```

![](https://metanit.com/sharp/tutorial/pics/3.37.png)

В классе StateConsumer есть доступ только к классу PublicState и его методу PrintPublic, потому что они имеют модификатор ***public**. К остальной функциональности подключенной сборки StateConsumer доступа не имеет.

Благодаря такой системе модификаторов доступа можно скрывать некоторые моменты реализации класса от других частей программы.

# Свойства

Кроме обычных методов в языке C# предусмотрены специальные методы доступа, которые называют **свойства**. Они обеспечивают простой доступ к полям классов и структур, узнать их значение или выполнить их установку.

## Определение свойств

Стандартное описание свойства имеет следующий синтаксис:



```Csharp
[модификаторы] тип_свойства название_свойства
{
    get { действия, выполняемые при получении значения свойства}
    set { действия, выполняемые при установке значения свойства}
}
```

Вначале определения свойства могут идти различные модификаторы, в частности, модификаторы доступа. Затем указывается тип свойства, после которого идет название свойства. Полное определение свойства содержит два блока: **get** и **set**.

В блоке **get** выполняются действия по получению значения свойства. В этом блоке с помощью оператора **return** возвращаем некоторое значение.

В блоке **set** устанавливается значение свойства. В этом блоке с помощью параметра value мы можем получить значение, которое передано свойству.

Блоки **get** и **set** еще называются акссесорами или методами доступа (к значению свойства), а также геттером и сеттером.

То есть по сути свойство ничего не хранит, оно выступает в роли посредника между внешним кодом и переменной name.

Рассмотрим пример:

```Csharp
Person person = new Person();
 
// Устанавливаем свойство - срабатывает блок Set
// значение "Tom" и есть передаваемое в свойство value
person.Name = "Tom";
 
// Получаем значение свойства и присваиваем его переменной - срабатывает блок Get
string personName = person.Name;
Console.WriteLine(personName);  // Tom
 
class Person
{
    private string name = "Undefined";
 
    public string Name
    {
        get
        {
            return name;    // возвращаем значение свойства
        }
        set
        {
            name = value;   // устанавливаем новое значение свойства
        }
    }
}
```

Здесь в классе Person определено приватное поле name, которая хранит имя пользователя, и есть общедоступное свойство Name. Хотя они имеют практически одинаковое название за исключением регистра, но это не более чем стиль, названия у них могут быть произвольные и не обязательно должны совпадать.

Через это свойство мы можем управлять доступом к переменной name. В свойстве в блоке **get** возвращаем значение поля:

```Csharp
get { return name; }
```

А в блоке **set** устанавливаем значение переменной name. Параметр **value** представляет передаваемое значение, которое передается переменной name.

```Csharp
set { name = value; }
```

В программе мы можем обращаться к этому свойству, как к обычному полю. Если мы ему присваиваем какое-нибудь значение, то срабатывает блок **set**, а передаваемое значение передается в параметр **value**:

```Csharp
person.Name = "Tom";
```

Если мы получаем значение свойства, то срабатывает блок **get**, который по сути возвращает значение переменной name:

```Csharp
string personName = p.Name; 
```

Возможно, может возникнуть вопрос, зачем нужны свойства, если мы можем в данной ситуации обходиться обычными полями класса? Но свойства позволяют вложить дополнительную логику, которая может быть необходима при установке или получении значения. Например, нам надо установить проверку по возрасту:

```Csharp
Person person = new Person();
 
Console.WriteLine(person.Age);  // 1
// изменяем значение свойства
person.Age = 37;
Console.WriteLine(person.Age);  // 37
// пробуем передать недопустимое значение
person.Age = -23;               // Возраст должен быть в диапазоне от 1 до 120
Console.WriteLine(person.Age);  // 37 - возраст не изменился
 
class Person
{
    int age = 1;
    public int Age
    {
        set
        {
            if (value < 1 || value > 120)
                Console.WriteLine("Возраст должен быть в диапазоне от 1 до 120");
            else
                age = value;
        }
        get { return age; }
    }
}
```

В данном случае переменная age хранит возраст пользователя. Напрямую мы не можем обратиться к этой переменной - только через свойство Age. Причем в блоке **set** мы устанавливаем значение, если оно соответствует некоторому разумному диапазону. Поэтому при передаче свойству Age значения, которое не входит в этот диапазон, значение переменной не будет изменяться:

```Csharp
person.Age = -23;
```

Консольный вывод программы:

```
1
37
Возраст должен быть в диапазоне от 1 до 120
37
```

Таким образом, свойство позволяет опосредовать и контролировать доступ к данным объекта.


## Свойства только для чтения и записи

Блоки set и get не обязательно одновременно должны присутствовать в свойстве. Если свойство определяет только блок ***get**, то такое свойство доступно только **для чтения** - мы можем получить его значение, но не установить.

И, наоборот, если свойство имеет только блок **set**, тогда это свойство доступно только для записи - можно только установить значение, но нельзя получить:

```Csharp
Person person = new Person();
 
// свойство для чтения - можно получить значение
Console.WriteLine(person.Name);  // Tom
// но нельзя установить
// person.Name = "Bob";    // ! Ошибка
 
// свойство для записи - можно устновить значение
person.Age = 37;
// но нелзя получить
// Console.WriteLine(person.Age);  // ! Ошибка
 
person.Print();
 
class Person
{
    string name = "Tom";
    int age = 1;
    // свойство только для записи
    public int Age
    {
        set { age = value; }
    }
    // свойство только для чтения
    public string Name
    {
        get { return name; }
    }
 
    public void Print()=> Console.WriteLine($"Name: {name}  Age: {age}");
}
```

Здесь свойство Name доступно только для чтения, поскольку оно имеет только блок **get**:

```Csharp
public string Name
{
    get { return name; }
}
```

Мы можем получить его значение, но НЕ можем установить:

```Csharp
Console.WriteLine(person.Name);  // получить можно
person.Name = "Bob";    // ! Ошибка - установить нельзя
```

А свойство Age, наоборот, доступно только для записи, поскольку оно имеет только блок **set**:

```Csharp
public int Age
{
    set { age = value; }
}
```
Можно установить его значение, но нельзя получить:

 ```Csharp
person.Age = 37; // установить можно
Console.WriteLine(person.Age);  // ! Ошибка - получить значение нельзя
 ```

 ## Вычисляемые свойства

 Свойства необзательно связаны с определенной переменной. Они могут вычисляться на основе различных выражений

 ```Csharp
Person tom = new("Tom", "Smith");
Console.WriteLine(tom.Name);    // Tom Smith
class Person
{
    string firstName;
    string lastName;
    public string Name
    {
        get { return  $"{firstName} {lastName}"; }
    }
    public Person(string firstName, string lastName)
    {
        this.firstName = firstName; 
        this.lastName = lastName;
    }
}
 ```

 В данном случае класс Person имеет свойство Name, которое доступно только для чтения и которое возвращает общее значение на основе значений переменных firstName и lastName.

 ## Модификаторы доступа

 Мы можем применять модификаторы доступа не только ко всему свойству, но и к отдельным блокам get и set:

 ```Csharp
Person tom = new("Tom");
 
// Ошибка - set объявлен с модификатором private
//tom.Name = "Bob";
Console.WriteLine(tom.Name);    // Tom
class Person
{
    string name = "";
    public string Name
    {
        get { return name; }
 
        private set { name = value; }
    }
    public Person(string name) => Name = name;
}
 ```

Теперь закрытый блок set мы сможем использовать только в данном классе - в его методах, свойствах, конструкторе, но никак не в другом классе:

При использовании модификаторов в свойствах следует учитывать ряд ограничений:

- Модификатор для блока set или get можно установить, если свойство имеет оба блока (и set, и get)

- Только один блок set или get может иметь модификатор доступа, но не оба сразу

- Модификатор доступа блока set или get должен быть более ограничивающим, чем модификатор доступа свойства. Например, если свойство имеет модификатор public, то блок set/get может иметь только модификаторы protected internal, internal, protected, private protected и private

## Автоматические свойства

Свойства управляют доступом к полям класса. Однако что, если у нас с десяток и более полей, то определять каждое поле и писать для него однотипное свойство было бы утомительно. Поэтому в .NET были добавлены автоматические свойства. Они имеют сокращенное объявление:

```Csharp
class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
         
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
```

На самом деле тут также создаются поля для свойств, только их создает не программист в коде, а компилятор автоматически генерирует при компиляции.

В чем преимущество автосвойств, если по сути они просто обращаются к автоматически создаваемой переменной, почему бы напрямую не обратиться к переменной без автосвойств? Дело в том, что в любой момент времени при необходимости мы можем развернуть автосвойство в обычное свойство, добавить в него какую-то определенную логику.

Стоит учитывать, что нельзя создать автоматическое свойство только для записи, как в случае со стандартными свойствами.

Автосвойствам можно присвоить значения по умолчанию (инициализация автосвойств):

```Csharp
Person tom = new();
 
Console.WriteLine(tom.Name);    // Tom
Console.WriteLine(tom.Age);    // 37
 
class Person
{
    public string Name { get; set; } = "Tom";
    public int Age { get; set; } = 37;
}
```
И если мы не укажем для объекта Person значения свойств Name и Age, то будут действовать значения по умолчанию.

Автосвойства также могут иметь модификаторы доступа:

```Csharp
class Person
{
    public string Name { private set; get;}
    public Person(string name) => Name = name;
}
```
Мы можем убрать блок set и сделать автосвойство доступным только для чтения. В этом случае для хранения значения этого свойства для него неявно будет создаваться поле с модификатором readonly, поэтому следует учитывать, что подобные get-свойства можно установить либо из конструктора класса, как в примере выше, либо при инициализации свойства:

```Csharp
class Person
{
    // через инициализацию свойства
    public string Name { get; } = "Tom";
    // через конструктор
    public Person(string name) => Name = name;
}
```

## Блок init

Начиная с версии C# 9.0 сеттеры в свойствах могут определяться с помощью оператора **init** (от слова "инициализация" - это есть блок **init** призван инициализировать свойство). Для установки значений свойств с init можно использовать только инициализатор, либо конструктор, либо при объявлении указать для него значение. После инициализации значений подобных свойств их значения изменить нельзя - они доступны только для чтения. В этом плане init-свойства сближаются со свойствами для чтения. Разница состоит в том, что init-свойства мы также можем установить в инициализаторе (свойства для чтения установить в инициализаторе нельзя). Например:

```Csharp
Person person = new();
//person.Name = "Bob";    //! Ошибка - после инициализации изменить значение нельзя
 
Console.WriteLine(person.Name); // Undefined
public class Person
{
    public string Name { get; init; } = "Undefined";
}
```

В данном случае класс Person для свойства Name вместо сеттера использует оператор **init**. В итоге на строке

```Csharp
Person person = new();
```

предполагается создание объекта с инициализацией всех его свойств. В данном случае свойство Name получит в качестве значения строку "Undefined". Однако поскольку инициализация свойства уже произошла, то на строке

```Csharp
person.Name = "Bob";    // Ошибка
```

мы получим ошибку.

Как можно установить подобное свойство? Выше продемонстрирован один из способов - установка значения при определении свойства. Второй способ - через конструктор:

```Csharp
Person person = new("Tom");
Console.WriteLine(person.Name); // Tom
public class Person
{
    public Person(string name) => Name = name;
    public string Name { get; init; }
}
```

Третий способ - через инициализатор:

```Csharp
Person person = new() { Name = "Bob"};
Console.WriteLine(person.Name); // Bob
 
public class Person
{
    public string Name { get; init; } = "";
}
```

В принцпе есть еще четверый способ - установка через другое свойство с модификатором **init**:

```Csharp
var person = new Person() { Name = "Sam" };
Console.WriteLine(person.Name);     // Sam
Console.WriteLine(person.Email);    // Sam@gmail.com
public class Person
{
    string name = "";
    public string Name
    {
        get { return name; }
        init
        {
            name = value;
            Email = $"{value}@gmail.com";
        }
    }
    public string Email { get; init; } = "";
}
```

В данном случае в init-свойстве Name разворачивается в полное свойство, которое управляет полем для чтения name. Благодаря этому перед установкой значения свойства мы можем произвести некоторую предобработку. Кроме того, в выражении init установливается другое init-свойство - Email, которое для установки значения использует значение свойства Name - из имени получаем значение для электронного адреса.

Причем если если при объявлении свойства указано значение, то в конструкторе мы можем его изменить. Значение, установленное в конструкторе, можно изменить в инициализаторе. Однако дальше процесс инициализации заканчивается. И значение не может быть изменено.

## Сокращенная запись свойств

Как и методы, мы можем сокращать определения свойств. Поскольку блоки **get** и **set** представляют специальные методы, то как и обычные методы, если они содержат одну инструкцию, то мы их можем сократить с помощью оператора =>:

```Csharp
class Person
{
    string name;
    public string Name 
    { 
        get => name;
        set => name = value; 
    }
}
```
Также можно сокращать все свойство в целом:

```Csharp
class Person
{
    string name;
     
    // эквивалентно public string Name { get { return name; } }
    public string Name => name;
}
```

# Перегрузка методов

Иногда возникает необходимость создать один и тот же метод, но с разным набором параметров. И в зависимости от имеющихся параметров применять определенную версию метода. Такая возможность еще называется **перегрузкой методов** (method overloading).

И в языке C# мы можем создавать в классе несколько методов с одним и тем же именем, но разной сигнатурой. Что такое сигнатура? **Сигнатура** складывается из следующих аспектов:

- Имя метода

- Количество параметров

- Типы параметров

- Порядок параметров

- Модификаторы параметров

Но названия параметров в сигнатуру НЕ входят. Например, возьмем следующий метод:

```Csharp
public int Sum(int x, int y) 
{ 
    return x + y;
}
```

У данного метода сигнатура будет выглядеть так: Sum(int, int)

И перегрузка метода как раз заключается в том, что методы имеют разную сигнатуру, в которой совпадает только название метода. То есть методы должны отличаться по:

- Количеству параметров

- Типу параметров

- Порядку параметров

- Модификаторам параметров

Например, пусть у нас есть следующий класс:

```Csharp
class Calculator
{
    public void Add(int a, int b)
    {
        int result = a + b;
        Console.WriteLine($"Result is {result}");
    }
    public void Add(int a, int b, int c)
    {
        int result = a + b + c;
        Console.WriteLine($"Result is {result}");
    }
    public int Add(int a, int b, int c, int d)
    {
        int result = a + b + c + d;
        Console.WriteLine($"Result is {result}");
        return result;
    }
    public void Add(double a, double b)
    {
        double result = a + b;
        Console.WriteLine($"Result is {result}");
    }
}
```

Здесь представлены четыре разных версии метода Add, то есть определены четыре перегрузки данного метода.

Первые три версии метода отличаются по количеству параметров. Четвертая версия совпадает с первой по количеству параметров, но отличается по их типу. При этом достаточно, чтобы хотя бы один параметр отличался по типу. Поэтому это тоже допустимая перегрузка метода Add.

То есть мы можем представить сигнатуры данных методов следующим образом:

```Csharp
Add(int, int)
Add(int, int, int)
Add(int, int, int, int)
Add(double, double)
```

После определения перегруженных версий мы можем использовать их в программе:

```Csharp
Calculator calc = new Calculator();
calc.Add(1, 2); // 3
calc.Add(1, 2, 3); // 6
calc.Add(1, 2, 3, 4); // 10
calc.Add(1.4, 2.5); // 3.9
```

Консольный вывод:

```Csharp
Result is 3
Result is 6
Result is 10
Result is 3.9
```
Также перегружаемые методы могут отличаться по используемым модификаторам. Например:

```Csharp
void Increment(ref int val)
{
    val++;
    Console.WriteLine(val);
}
 
void Increment(int val)
{
    val++;
    Console.WriteLine(val);
}
```

В данном случае обе версии метода Increment имеют одинаковый набор параметров одинакового типа, однако в первом случае параметр имеет модификатор ref. Поэтому обе версии метода будут корректными перегрузками метода Increment.

А отличие методов по возвращаемому типу или по имени параметров не является основанием для перегрузки. Например, возьмем следующий набор методов:

```Csharp
int Sum(int x, int y)
{
    return x + y;
}
int Sum(int number1, int number2)
{
    return number1 + number2;
}
void Sum(int x, int y)
{
    Console.WriteLine(x + y);
}
```

Сигнатура у всех этих методов будет совпадать:

```Csharp
Sum(int, int)
```

Поэтому данный набор методов не представляет корректные перегрузки метода Sum и **работать не будет**.

# Статические члены и модификатор static

Кроме обычных полей, методов, свойств классы и структуры могут иметь статические поля, методы, свойства. Статические поля, методы, свойства относятся ко всему классу/всей структуре и для обращения к подобным членам необязательно создавать экземпляр класса / структуры.

## Статические поля

Статические поля хранят состояние всего класса / структуры. Статическое поле определяется как и обычное, только перед типом поля указывается ключевое слово **static**. Например, рассмотрим класс Person, который представляет человека:

```Csharp
Person bob = new(68);
bob.СheckAge();     // Уже на пенсии
 
Person tom = new(37);
tom.СheckAge();     // Сколько лет осталось до пенсии: 28
 
// получение статического поля
Console.WriteLine(Person.retirementAge); // 65
// изменение статического поля
Person.retirementAge = 67;
 
class Person
{
    int age;
    public static int retirementAge = 65;
    public Person(int age)
    {
        this.age = age;
    }
    public void СheckAge()
    {
        if (age >= retirementAge)
            Console.WriteLine("Уже на пенсии");
        else
            Console.WriteLine($"Сколько лет осталось до пенсии: {retirementAge - age}");
    }
}
```
В данном случае класс Person имеет два поля: age (хранит возраст человека) и retirementAge (хранит пенсионный возраст). Однако поле retirementAge является статическим. Оно относится не к конкретному человеку, а ко всем людям. (В данном случае для упрощения пренебрежем тем фактом, что в зависимости от пола и профессии пенсионный возраст может отличаться.) Таким образом, поле retirementAge относится не к отдельную объекту и хранит значение НЕ отдельного объекта класса Person, а относится ко всему классу Person и хранит общее значение для всего класса.

Причем в самом классе мы можем использовать это поле как и любые другие. Так, в методе СheckAge(), который поверяет пенсионный статус человека, для проверки используем это поле:

```Csharp
if (age >= retirementAge)
```

Но если мы хотим обратиться к этому полю вне своего класса, то мы можем обращаться к этому полю по имени класса:

```Csharp
Console.WriteLine(Person.retirementAge);
Person.retirementAge = 67;
```

На уровне памяти для статических полей будет создаваться участок в памяти, который будет общим для всех объектов класса.

![](https://metanit.com/sharp/tutorial/pics/static.png)

При этом память для статических переменных выделяется даже в том случае, если не создано ни одного объекта этого класса.

## Статические свойства

Подобным образом мы можем создавать и использовать статические свойства:

```Csharp
Person bob = new(68);
bob.СheckAge();
 
Console.WriteLine(Person.RetirementAge); // 65
 
class Person
{
    int age;
    static int retirementAge = 65;
    public static int RetirementAge
    {
        get { return retirementAge; }
        set { if (value > 1 && value < 100) retirementAge = value; }
    }
    public Person(int age)
    {
        this.age = age;
    }
    public void СheckAge()
    {
        if (age >= retirementAge)
            Console.WriteLine("Уже на пенсии");
        else
            Console.WriteLine($"Сколько лет осталось до пенсии: {retirementAge - age}") ;
    }
}
```

В данном случае доступ к статической переменной retirementAge опосредуется с помощью статического свойства RetirementAge.

Таким образом, переменные и свойства, которые хранят состояние, общее для всех объектов класса / структуры, следует определять как статические.

Нередко статические поля и свойства применяются для хранения счетчиков. Например, мы хотим иметь счетчик, который позволял бы узнать, сколько объектов Person создано:

```Csharp
var tom = new Person();
var bob = new Person();
var sam = new Person();
Console.WriteLine(Person.Counter);  // 3
 
class Person
{
    static int counter = 0;
    public static int Counter => counter;
    public Person()
    {
        counter++;
    }
}
```

В данном случае в классе Person счетчик хранится в приватной переменной counter, значение которой увеличивается на единицу при создании объекта в конструкторе. А с помощью статического свойства Counter, которое доступно только для чтения, мы можем получить значение счетчика.

## Статические методы

Статические методы определяют общее для всех объектов поведение, которое не зависит от конкретного объекта. Для обращения к статическим методам также применяется имя класса / структуры:

```Csharp
Person bob = new(68);
Person.CheckRetirementStatus(bob);
 
class Person
{
    public int Age { get; set; }
    static int retirementAge = 65;
    public Person(int age) => Age = age;
    public static void CheckRetirementStatus(Person person)
    {
        if (person.Age >= retirementAge)
            Console.WriteLine("Уже на пенсии");
        else
            Console.WriteLine($"Сколько лет осталось до пенсии: {retirementAge - person.Age}") ;
    }
}
```

В данном случае в классе Person определен статический метод CheckRetirementStatus(), который в качестве параметра принимает объект Person и проверяет его пенсионный статус.

Следует учитывать, что статические методы могут обращаться только к статическим членам класса. Обращаться к нестатическим методам, полям, свойствам внутри статического метода мы не можем.

## Статический конструктор

Кроме обычных конструкторов у класса также могут быть статические конструкторы. Статические конструкторы имеют следующие отличительные черты:

- Статические конструкторы не должны иметь модификатор доступа и не принимают параметров

- Как и в статических методах, в статических конструкторах нельзя использовать ключевое слово this для ссылки на текущий объект класса и можно обращаться только к статическим членам класса

- Статические конструкторы нельзя вызвать в программе вручную. Они выполняются автоматически при самом первом создании объекта данного класса или при первом обращении к его статическим членам (если таковые имеются)

Статические конструкторы обычно используются для инициализации статических данных, либо же выполняют действия, которые требуется выполнить только один раз

Определим статический конструктор:

```Csharp
Console.WriteLine(Person.RetirementAge);
 
class Person
{
    static int retirementAge;
    public static int RetirementAge => retirementAge;
    static Person()
    {
        if (DateTime.Now.Year == 2022)
            retirementAge = 65;
        else
            retirementAge = 67;
    }
}
```

В данном случае с помощью встроенной структуры DateTime получаем текущий год. Для этого используется свойство DateTime.Now.Year. если он равен 2022, устанавливаем один пенсионный возраст. При другом значении текущего года устанавливается другое значение пенсионного возраста.

## Статические классы

Статические классы объявляются с модификатором static и могут содержать только статические поля, свойства и методы. Например, определим класс, который выполняет ряд арифметических операций:

```Csharp
Console.WriteLine(Operations.Add(5, 4));         // 9
Console.WriteLine(Operations.Subtract(5, 4));    // 1
Console.WriteLine(Operations.Multiply(5, 4));    // 20
 
static class Operations
{
    public static int Add(int x, int y) => x + y;
    public static int Subtract(int x, int y) => x - y;
    public static int Multiply(int x, int y) => x * y;
}
```

# Поля и структуры для чтения

## Поля для чтения и модификатор readonly

**Поля для чтения** представляют такие поля класса или структуры, значение которых нельзя изменить. Таким полям можно присвоить значение либо при непосредственно при их объявлении, либо в конструкторе. В других местах программы присваивать значение таким полям нельзя, можно только считывать их значение.

Поле для чтения объявляется с ключевым словом **readonly**:

```Csharp
Person tom = new Person("Tom");
Console.WriteLine(tom.name);
 
//tom.name = "Sam"; // !Ошибка: нельзя изменить
class Person
{
    public readonly string name = "Undefined"; // можно так инициализировать
    public Person(string name)
    {
        this.name = name; // в конструкторе также можно присвоить значение полю для чтения
    }
    public void ChangeName(string otherName)
    {
        //this.name = otherName;    // так нельзя 
    }
}
```

Здесь поле name хранит имя пользователя и представляет поле для чтения. Ему можно присвоить значение непосредственно при объявлении:

```Csharp
public readonly string name = "Undefined";
```

Либо можно присвоить значение в конструкторе

```Csharp
public Person(string name)
{
    this.name = name;
}
```
В остальных местах программы, в том числе в самом классе Person присвоить значение полю для чтения нельзя.

## Сравнение констант

- Константы должны быть определены во время компиляции, а поля для чтения могут быть определены во время выполнения программы.
Соответственно значение константы можно установить только при ее определении.
Поле для чтения можно инициализировать либо при его определении, либо в конструкторе класса.

- Константы не могут использовать модификатор static, так как уже неявно являются статическими. Поля для чтения могут быть как статическими, так и не статическими.

# Структуры для чтения

Кроме полей для чтения в C# можно определять структуры для чтения. Для этого они предваряются модификатором **readonly**:

```Csharp
readonly struct Person { }
```
Особенностью таких структур является то, что все их поля должны быть также полями для чтения:


```Csharp
readonly struct Person
{
    public readonly string name;
    public Person(string name)
    {
        this.name = name;
    }
}
```

То же самое касается и свойств, которые должны быть доступны только для чтения:

```Csharp
readonly struct Person
{
    public readonly string Name { get; } // указывать readonly необязательно
    public int Age { get; } // свойство только для чтения
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
    }
}
```

# Null и ссылочные типы

Кроме стандартных значений типа чисел, строк, язык C# имеет специальное значение - **null**, которое фактически указывает на отсутствие значения как такового, отсутствие данных. До сих пор значение **null** выступает как значение по умолчанию для ссылочных типов.

До версии C# 8.0 всем ссылочным типам спокойно можно было присваивать значение **null**:

```Csharp
string? name = null;
Console.WriteLine(name);    // ничего не выведет
```

К примеру встроенный метод Console.ReadLine(). который считывает с консоли строку, возвращает именно значение string?, а не просто string:

```Csharp
string? name = Console.ReadLine();
```
Зачем нужно это значение null? В различных ситуациях бывает удобно, чтобы объекты могли принимать значение null, то есть были бы не определены. Стандартный пример - работа с базой данных, которая может содержать значения null. И мы можем заранее не знать, что мы получим из базы данных - какое-то определенное значение или же null.

При этом подобные ссылочные типы, которые допускают присвоение значения null, доступно только в nullable-контексте. Для nullable-контекста характерны следующие особенности:

- Переменную ссылочного типа следует инициализировать конкретным значением, ей не следует присваивать значение **null**
- Переменной ссылочного nullable-типа можно присвоить значение **null**, но перед использование необходимо проверять ее на значение **null**.

Начиная с .NET 6 и C# 10 nullable-контекст по умолчанию распространяется на все файлы кода в проекта. Например, если мы наберем в Visual Studio 2022 для проекта .NET 6 предыдущий пример, то мы столкнемся с предупреждением:

![](https://metanit.com/sharp/tutorial/pics/2.17.png)

Хотя nullable-контекст - это опция, которой мы можем управлять. Так, откроем файл проекта. Для этого либо двойным кликом левой кнопкой мыши нажмем на проект, либо нажмем на проект правой кнопкой мыши и в появившемся меню выберем пункт **Edit Project File**

![](https://metanit.com/sharp/tutorial/pics/2.18.png)

После этого Visual Studio откроет нам файл проекта, который будет выглядеть примерно следующим образом:

```xml
<Project Sdk="Microsoft.NET.Sdk">
 
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
  </PropertyGroup>
 
</Project>
```

Здесь строка

```xml
<Nullable>enable</Nullable>
```

точнее элемент <Nullable> со значением **enable** указывает, что эта nullable-контекст будет распространяться на весь проект.

Чем так плох **null?** Дело в том, что это значение означает, отсутствие данных. Но, допустим, у нас есть ситуация, когда мы получаем извне некоторую строку и пытаемся обратиться к ее функциональности. Например, в примере ниже у строки вызывается метод ToUpper(), который переводит все символы строки в верхний регистр:

```Csharp
string name = null;
PrintUpper(name);  // ! NullReferenceException
 
void PrintUpper(string text)
{
    Console.WriteLine(text.ToUpper());
}
```

Здесь при выполнении вызова PrintUpper(name) мы столкнемся с исключением **NullReferenceException**, и программа аварийно завершит свою работу. Кто-то может сказать, что ситуация искуственная - мы же явно знаем, что в функцию передается null. Однако в реальности данные могут приходить извне, например, из базы данных, откуда-то из сети и т.д. И мы можем явно не знать, есть ли в реальности данные или нет. И использование ссылочных nullable-типов позволяет частично решить эту ситуацию. Частично - поскольку предупреждения все равно не мешают нам скомпилировать и запустить программу выше. Однако nullable-контекст позволяет воспользоваться возможностями статического анализа, благодаря которому можно увидеть потентиально опасные куски кода, где мы можем столкнуться с NullReferenceException.

Кроме того, есть вероятность, что Microsoft изменит отношение в отношении null и NullReferenceException, и подобные предупреждения превратятся в будущих версиях в ошибки, поэтому лучше уже сейчас быть к этому готовым

Например, изменим предыдущий пример следующим образом:

```Csharp
string? name = null;
PrintUpper(name);  // 
 
void PrintUpper(string? text)
{
    Console.WriteLine(text.ToUpper());
}
```

Здесь статический анализ подскажет, что в методе PrintUpper потенциально опасная ситуация, поскольку параметр text может быть равен **null**.


![](https://metanit.com/sharp/tutorial/pics/2.19.png)

## Отключение nullable-контекста

Для отключения nullable-контекста в файле конфигурации проекта достаточно изменить значение опции Nullable, например, на "disable":

```xml
<Project Sdk="Microsoft.NET.Sdk">
 
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>disable</Nullable>
  </PropertyGroup>
 
</Project>
```

Отключив nullable-контекст, мы больше не сможем использовать в файлах кода в проекте ссылочные nullable-типы и соответственно воспользоваться встроенным статическим анализом потенциально опасных ситуаций, где можно столкнуться с NullReferenceException.

## nullable-контекст на уровне участка кода

Мы также можем включить nullable-контекст на урове отдельных участков кода с помощью директивы **#nullable enable**. Допустим, глобально у нас отключен nullable-контекст:

```xml
<Nullable>disable</Nullable>
```

Определим в файле **Program.cs** следующий код:

```Csharp
#nullable enable // включаем nullable-контекст на уровне файла
 
string? name = null;
 
PrintUpper(name);
 
void PrintUpper(string? text)
{
    Console.WriteLine(text.ToUpper());
}
```
Первая строка позволяет включить на уровне всего файла nullable-контекст.

![](https://metanit.com/sharp/tutorial/pics/2.20.png)

## Оператор ! (null-forgiving operator) 

Оператор ! (null-forgiving operator) позволяет указать, что переменная ссылочного типа не равна **null**:

```Csharp
string? name = null;
 
PrintUpper(name!);
 
void PrintUpper(string text)
{
    if(text == null) Console.WriteLine("null");
    else Console.WriteLine(text.ToUpper());
}
```
Здесь если бы мы не использовали оператор !, а написали бы PrintUpper(name), то компилятор высветил бы нам предупреждение. Но в самом методе мы итак проверяем на null, поэтому даже если в метод передается null, то мы не столкнемся ни с какими проблемами. И чтобы убрать ненужное предупреждение, применяется данный оператор. То есть данный оператор не оказывает никакого влияния во время выполнения кода и предназначен только для статического анализа компилятора. Во время выполнения выражение name! будет аналогично значению name

## Исключение кода из nullable-контекста

С помощью специальной директивы **#nullable disable** можно исключить какой-то определенный кусок кода из nullable-контекста. Например:

```Csharp
#nullable disable
    string text = null; // здесь nullable-контекст не действует
#nullable restore
 
string? name = null;   // здесь nullable-контекст снова действует
```

Любой код между директивами **#nullable disable** и **#nullable restore** будет исключен из nullable-контекста и тем самым не будет подлежать статическому анализу.

# Null и значимые типы


В отличие от ссылочных типов переменным/параметрам значимых типов нельзя напрямую присвоить значение **null**. Тем не менее нередко бывает удобно, чтобы переменная/параметр значимого типа могли принимать значение null, Например, получаем числовое значение из базы данных, которое в бд может отсутствовать. То есть, если значение в базе данных есть - получим число, если нет - то null.

Чтобы присвоения переменной или параметру значимого типа значения **null***, эти переменная/параметр значимого типа должны представлять тип **nullable**. Для этого после названия типа указывается знак вопроса ?

```Csharp
int? val = null;
Console.WriteLine(val);
```

Здесь переменная val представляет не просто тип int, а тип **int?** - тип, переменные/параметры которого могут принимать как значения типа int, так и значение null. В данном случае мы передаем ей значение **null**. Но также можно передать и значение типа int:

```Csharp
int? val = null;
IsNull(val);    // null
val = 22;
IsNull(val);    // 22
 
void IsNull(int? obj)
{
    if (obj == null) Console.WriteLine("null");
    else Console.WriteLine(obj);
}
```
Однако если переменная/параметр представляет значимый не nullable-тип, то присвоить им значение null не получится:

```Csharp
int val = null;  // ! ошибка, переменная val НЕ представляет тип nullable
```

Стоит отметить, что фактически запись ? для значимых типов является упрощенной формой использования структуры **System.Nullable<T>**. Параметр T в угловых скобках представляет универсальный параметр, вместо которого в программе подставляется конкретный тип данных. Следующие виды определения переменных будут эквивалентны:

```Csharp
int? number1 = 5;
Nullable<int> number2 = 5;
```

## Свойства Value и HasValue и метод GetValueOrDefault

Структура **Nullable<T>** имеет два свойства:

- **Value** - значение объекта
- **HasValue**: возвращает true, если объект хранит некоторое значение, и false, если объект равен null.

Мы можем использовать эти свойства для проверки наличия и получения значения:

```Csharp
PrintNullable(5);       // 5
PrintNullable(null);    // параметр равен null
 
void PrintNullable(int? number)
{
    if (number.HasValue)
    {
        Console.WriteLine(number.Value);
        // аналогично
        Console.WriteLine(number);
    }
    else
    {
        Console.WriteLine("параметр равен null");
    }
}
```
Однако если мы попробуем получить через свойство Value значение переменной, которая равна null, то мы столкнемся с ошибкой:

```Csharp
int? number = null;
Console.WriteLine(number.Value);    // ! Ошибка
Console.WriteLine(number);          // Ошибки нет - просто ничего не выведет
```
Также структура **Nullable<T>** имеет метод **GetValueOrDefault()**. Он возвращает значение переменной/параметра, если они не равны **null**. Если они равны **null**, то возвращается значение по умолчанию. Значение по умолчанию можно передать в метод. Если в метод не передается данных, то возвращается значение по умолчанию для данного типа данных (например, для числовых данных это число 0).

```Csharp
int? number = null; // если значения нет, метод возвращает значение по умолчанию
Console.WriteLine(number.GetValueOrDefault());      // 0  - значение по умолчанию для числовых типов
Console.WriteLine(number.GetValueOrDefault(10));    // 10
 
number = 15;    // если значение задано, оно возвращается методом
Console.WriteLine(number.GetValueOrDefault());    // 15
Console.WriteLine(number.GetValueOrDefault(10));  // 15
```

## Преобразование значимых nullable-типов

Рассмотрим возможные преобразования:

- явное преобразование от T? к T
```Csharp
int? x1 = null;
if(x1.HasValue)
{
    int x2 = (int)x1;
    Console.WriteLine(x2);
}
```

- неявное преобразование от T к T?
```Csharp
int x1 = 4;
int? x2 = x1;
Console.WriteLine(x2);
```

- неявные расширяющие преобразования от V к T?
```Csharp
int x1 = 4;
long? x2 = x1;
Console.WriteLine(x2);
```
явные сужающие преобразования от V к T?
```Csharp
long x1 = 4;
int? x2 = (int?)x1; 
```
- Подобным образом работают явные сужающие преобразования от V? к T?

```Csharp
long? x1 = 4;
int? x2 = (int?)x1;
```

- явные сужающие преобразования от V? к T
```Csharp
long? x1 = null;
if (x1.HasValue) 
{ 
    int x2 = (int)x1; 
}
```

## Операции с nullable-типами

nullable-типы поддерживают тот же набор операций, что и их не-nullable двойники. Но следует учитывать, что если в операции участвует nullable-тип, то результатом также будет значение nullable-типа

```Csharp
int? x = 5;
int z = x + 7;          // нельзя
int? w = x + 7;         // можно
int d = x.Value + 7;    // можно
```

В арифметических операциях, если один из операндов равен null, то результатом операции также будет null:

```Csharp
int? x = null;
int? w = x + 7;         // w = null
```
В операциях сравнения, если хотя бы один из операндов равен null, то возвращается false

# Проверка на null, операторы ?. и ??

## Проверка на null. Null guard

Если мы собираемся использовать переменную или параметр, которые допускают значение **null**, то есть представляют nullable-тип (не важно значимый или ссылочный), то, чтобы избежать возникновения NullReferenceException, мы можем проверить на null:

```Csharp
void PrintUpper(string? text)
{
    if (text!=null)
    {
        Console.WriteLine(text.ToUpper());
    }    
}
```

В данном случае если параметр text не равен null, то вызываем у строки метод ToUpper(), который переводит символы строки в верхний регистр.

Кроме того, с помощью оператора **is** мы можем проверить значение объекта:

```Csharp
объект is значение
```

Если объект слева от оператора **is** имеет значение справа от оператора. тогда оператор is возвращает true, иначе возвращается false

Например, проверка параметра/переменной на значение null:

```Csharp
void PrintUpper(string? text)
{
    if (text is  null) return;
    Console.WriteLine(text.ToUpper());
}
```
Или, наоборот, с помощью  **is not** можно проверить отсутствие значения:

```Csharp
void PrintUpper(string? text)
{
    if (text is not null) 
        Console.WriteLine(text.ToUpper());
}
```
Также можно проверить на соответствие типу, значение которого мы собираемся использовать:

```Csharp
void PrintUpper(string? text)
{
    if (text is string)
        Console.WriteLine(text.ToUpper());
    else
        Console.WriteLine("NULL");
}
```

Подобные проверки еще называются **null guard** или условно говоря "защита от null".

## Оператор ??

Оператор ?? называется оператором **null-объединения**. Он применяется для установки значений по умолчанию для типов, которые допускают значение null:

```Csharp
левый_операнд ?? правый_операнд
```
Оператор ?? возвращает левый операнд, если этот операнд не равен null. Иначе возвращается правый операнд. При этом левый операнд должен принимать null. Посмотрим на примере:

```Csharp
string? text = null;
string name = text ?? "Tom";  // равно Tom, так как text равен null
Console.WriteLine(name);    // Tom
 
int? id = 200;
int personid = id ?? 1; // равно 200, так как id не равен null
Console.WriteLine(personid);    // 200
```

Но мы не можем написать следующим образом:

```Csharp
int x = 44;
int y = x ?? 100;
```

Здесь переменная x представляет значимый тип int и не может принимать значение null, поэтому в качестве левого операнда в операции ?? она использоваться не может.

Также можно использовать производный оператора **??=**

```Csharp
string? text = null;
text ??= "Sam";
// аналогично
// text = text ?? "Sam";
Console.WriteLine(text);    // Sam
 
int? id = 100;
id ??= 1;
// аналогично
//id = id ?? 1;
Console.WriteLine(id); // 100
```


## Оператор условного null

Иногда при работе с объектами, которые принимают значение null, мы можем столкнуться с ошибкой: мы пытаемся обратиться к объекту, а этот объект равен null. Например, пусть у нас есть следующая система классов:

```Csharp
class Person
{
    public Company? Company { get; set; }   // место работы
}
class Company
{
    public string? WebSite { get; set; }    // веб-сайт компании
}
```
Объект Person представляет человека. Его свойство Company представляет компанию, где человек работает. Но человек может не работать, поэтому свойство Company имеет тип Company?, то есть может иметь значение null.

Класс Company в свою очередь содержит свойство WebSite, которое представляет веб-сайт компании. Но у компании может и не быть собственного веб-сайта. Поэтому это свойство имеет тип string?, то есть также допускает значение null.

Допустим, нам надо вывести на консоль заглавными буквами веб-сайт компании, где работает человек (если он, конечно, работает и если у компании, где он работает, есть сайт). На первый взгляд мы можем написать следующую конструкцию:

```Csharp
void PrintWebSite(Person? person)
{
    if (person != null)
    {
        if(person.Company != null)
        {
            if(person.Company.WebSite != null)
            {
                Console.WriteLine(person.Company.WebSite.ToUpper());
            }
        }
    }
}
class Person
{
    public Company? Company { get; set; }   // место работы
}
class Company
{
```

В методе PrintWebSite() принимаем объект Person? и, чтобы избежать исключения NullReferenceException, последовательно проверяем все используемые значения на null, чтобы в конце с помощью метода ToUpper() вывести заглавными буквами название сайта.

Хоть это и рабочий способ, но для простого вывода строки получается многоэтажная конструкция, но на самом деле ее можно сократить:

```Csharp
void PrintWebSite(Person? person)
{
    if (person != null && person.Company != null && person.Company.WebSite != null)
    {
        Console.WriteLine(person.Company.WebSite.ToUpper());
    }
}
```

Конструкция намного проще, но все равно получается довольно большой. И чтобы ее упростить, в C# есть оператор условного null (Null-Conditional Operator) - оператор **?.**:

```Csharp
объект?.компонент
```

Если объект не равен **null**, то происходит обращение к компоненту объекта - полю, свойству, методу. Если объект представляет значение null, обращение к компаненту метода не происходит.

Применим данный оператор, изменив предыдущий пример:

```Csharp
void PrintWebSite(Person? person)
{
    Console.WriteLine(person?.Company?.WebSite?.ToUpper());
}
```

Таким образом, если person не равен null, то происходит обращение к его свойству Company. Если свойство Company не равно null, то идет обрашение к свойству WebSite объекта Company. Если свойство WebSite не равно null, то идет обращение к методу ToUpper().

# Псевдонимы типов и статический импорт

## Псевдонимы

Для различных классов и структур мы можем использовать псевдонимы. Затем в программе вместо названия типа используется его псевдоним. Например, для вывода строки на экран применяется метод Console.WriteLine(). Но теперь зададим для класса **Console** псевдоним:

```Csharp
using printer = System.Console;
 
printer.WriteLine("Laudate omnes gentes laudate");
printer.WriteLine("Magnificat in secula");
```

С помощью выражения using printer = System.Console указываем, что псевдонимом для класса System.Console будет имя printer. Это выражение не имеет ничего общего с подключением пространств имен в начале файла, хотя и использует оператор using. При этом используется полное имя класса с учетом пространства имен, в котором класс определен. И далее, чтобы вывести строку, применяется выражение printer.WriteLine("Laudate omnes gentes laudate").

Данная возможность может применяться, когда имена классов и структур довольно длинные, и мы хотим их сократить для большей лаконичности кода, либо когда мы хотим иметь более выразительные на наш субъективный взгляд имена типов.

И еще пример. Определим класс и для него псевдоним:

```Csharp
using printer = System.Console;
using User = Person;
 
User tom = new User("Tom");
printer.WriteLine(tom.Name);    // Tom
 
class Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
```
Класс называется Person, но в программе для него используется псевдоним User.

## Статический импорт

Также в C# имеется возможность импорта статической функциональности классов. Например, импортируем возможности класса Console:

```Csharp
using static System.Console;
 
WriteLine("Hello from C# 8.0");
```

Выражение **using static** подключает в программу все статические методы и свойства, а также константы. И после этого мы можем не указывать название класса при вызове метода.

Подобным образом можно определять свои классы и импортировать их:

```Csharp
using static System.Console;
using static Operation;
 
WriteLine(Sum(5, 4));       // 9
WriteLine(Subtract(5, 4));  // 1
WriteLine(Multiply(5, 4)); // 20
 
static class Operation
{
    public static int Sum(int a, int b) => a + b;
    public static int Subtract(int a, int b) => a - b;
    public static int Multiply(int a, int b) => a * b;
}
```