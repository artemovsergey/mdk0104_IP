# Делегаты, события и лямбды

## Делегаты

Делегаты представляют такие объекты, которые указывают на методы. То есть делегаты - это указатели на методы и с помощью делегатов мы можем вызвать данные методы.

### Определение делегатов

Для объявления делегата используется ключевое слово delegate, после которого идет возвращаемый тип, название и параметры. Например:

```Csharp
delegate void Message();
```

Делегат Message в качестве возвращаемого типа имеет тип void (то есть ничего не возвращает) и не принимает никаких параметров. Это значит, что этот делегат может указывать на любой метод, который не принимает никаких параметров и ничего не возвращает.

Рассмотрим примение этого делегата:

```Csharp
Message mes;            // 2. Создаем переменную делегата
mes = Hello;            // 3. Присваиваем этой переменной адрес метода
mes();                  // 4. Вызываем метод
 
void Hello() => Console.WriteLine("Hello METANIT.COM");
 
delegate void Message(); // 1. Объявляем делегат
```

Прежде всего сначала необходимо определить сам делегат:

```Csharp
delegate void Message(); // 1. Объявляем делегат
```

Для использования делегата объявляется переменная этого делегата:

```Csharp
Message mes; // 2. Создаем переменную делегата
```
Далее в делегат передается адрес определенного метода (в нашем случае метода Hello). Обратите внимание, что данный метод имеет тот же возвращаемый тип и тот же набор параметров (в данном случае отсутствие параметров), что и делегат.

```Csharp
mes = Hello; // 3. Присваиваем этой переменной адрес метода
```

Затем через делегат вызываем метод, на который ссылается данный делегат:

```Csharp
mes(); // 4. Вызываем метод
```

Вызов делегата производится подобно вызову метода.

При этом делегаты необязательно могут указывать только на методы, которые определены в том же классе, где определена переменная делегата. Это могут быть также методы из других классов и структур.

```Csharp
Message message1 = Welcome.Print;
Message message2 = new Hello().Display;
 
message1(); // Welcome
message2(); // Привет
 
delegate void Message();
 
class Welcome
{
    public static void Print() => Console.WriteLine("Welcome");
}
class Hello
{
    public void Display() => Console.WriteLine("Привет");
}
```

## Место определения делегата

Если мы определяем делегат в прогаммах верхнего уровня (top-level program), которую по умолчанию представляет файл Program.cs начиная с версии C# 10, как в примере выше, то, как и другие типы, делегат определяется в конце кода. Но в принцие делегат можно определять внутри класса:

```Csharp
class Program
{
    delegate void Message(); // 1. Объявляем делегат
    static void Main()
    {
        Message mes;            // 2. Создаем переменную делегата
        mes = Hello;            // 3. Присваиваем этой переменной адрес метода
        mes();                  // 4. Вызываем метод
 
        void Hello() => Console.WriteLine("Hello METANIT.COM");
    }
}
```

Либо вне класса:

```Csharp
delegate void Message(); // 1. Объявляем делегат
class Program
{
    static void Main()
    {
        Message mes;            // 2. Создаем переменную делегата
        mes = Hello;            // 3. Присваиваем этой переменной адрес метода
        mes();                  // 4. Вызываем метод
 
        void Hello() => Console.WriteLine("Hello METANIT.COM");
    }
}
```

## Параметры и результат делегата

Рассмотрим определение и применение делегата, который принимает параметры и возвращает результат:

```Csharp
Operation operation = Add;      // делегат указывает на метод Add
int result = operation(4, 5);   // фактически Add(4, 5)
Console.WriteLine(result);      // 9
     
operation = Multiply;           // теперь делегат указывает на метод Multiply
result = operation(4, 5);       // фактически Multiply(4, 5)
Console.WriteLine(result);      // 20
 
int Add(int x, int y) => x + y;
 
int Multiply(int x, int y) => x * y;
 
delegate int Operation(int x, int y);
```
В данном случае делегат Operation возвращает значение типа int и имеет два параметра типа int. Поэтому этому делегату соответствует любой метод, который возвращает значение типа int и принимает два параметра типа int. В данном случае это методы Add и Multiply. То есть мы можем присвоить переменной делегата любой из этих методов и вызывать.

Поскольку делегат принимает два параметра типа int, то при его вызове необходимо передать значения для этих параметров: operation(4,5).

## Присвоение ссылки на метод

Выше переменной делегата напрямую присваивался метод. Есть еще один способ - создание объекта делегата с помощью конструктора, в который передается нужный метод:

```Csharp
Operation operation1 = Add;
Operation operation2 = new Operation(Add);
 
int Add(int x, int y) => x + y;
 
delegate int Operation(int x, int y);
```
Оба способа равноценны.

## Соответствие методов делегату

Как было написано выше, методы соответствуют делегату, если они имеют один и тот же возвращаемый тип и один и тот же набор параметров. Но надо учитывать, что во внимание также принимаются модификаторы ref, in и out. Например, пусть у нас есть делегат:

```Csharp
delegate void SomeDel(int a, double b);
```
Этому делегату соответствует, например, следующий метод:

```Csharp
void SomeMethod1(int g, double n) { }
```

А следующие методы НЕ соответствуют:

```Csharp
double SomeMethod2(int g, double n) { return g + n; }
void SomeMethod3(double n, int g) { }
void SomeMethod4(ref int g, double n) { }
void SomeMethod5(out int g, double n) { g = 6; }
```

Здесь метод SomeMethod2 имеет другой возвращаемый тип, отличный от типа делегата. SomeMethod3 имеет другой набор параметров. Параметры SomeMethod4 и SomeMethod5 также отличаются от параметров делегата, поскольку имеют модификаторы ref и out.

## Добавление методов в делегат

В примерах выше переменная делегата указывала на один метод. В реальности же делегат может указывать на множество методов, которые имеют ту же сигнатуру и возвращаемые тип. Все методы в делегате попадают в специальный список - список вызова или invocation list. И при вызове делегата все методы из этого списка последовательно вызываются. И мы можем добавлять в этот список не один, а несколько методов. Для добавления методов в делегат применяется операция +=:

```Csharp
Message message = Hello;
message += HowAreYou;  // теперь message указывает на два метода
message();              // вызываются оба метода - Hello и HowAreYou
 
void Hello() => Console.WriteLine("Hello");
void HowAreYou() => Console.WriteLine("How are you?");
 
delegate void Message();
```

В данном случае в список вызова делегата message добавляются два метода - Hello и HowAreYou. И при вызове message вызываются сразу оба этих метода.

Однако стоит отметить, что в реальности будет происходить создание нового объекта делегата, который получит методы старой копии делегата и новый метод, и новый созданный объект делегата будет присвоен переменной message.

При добавлении делегатов следует учитывать, что мы можем добавить ссылку на один и тот же метод несколько раз, и в списке вызова делегата тогда будет несколько ссылок на один и то же метод. Соответственно при вызове делегата добавленный метод будет вызываться столько раз, сколько он был добавлен:

```Csharp
Message message = Hello;
message += HowAreYou;
message += Hello;
message += Hello;
 
message();
```

Консольный вывод:

```
Hello
How are you?
Hello
Hello
```

Подобным образом мы можем удалять методы из делегата с помощью операций -=:

```Csharp
Message? message = Hello; 
message += HowAreYou;
message();  // вызываются все методы из message
message -= HowAreYou;   // удаляем метод HowAreYou
if (message != null) message(); // вызывается метод Hello
```

При удалении методов из делегата фактически будет создаваться новый делегат, который в списке вызова методов будет содержать на один метод меньше.

Стоит отметить, что при удалении метода может сложиться ситуация, что в делегате не будет методов, и тогда переменная будет иметь значение null. Поэтому в данном случае переменная определена не просто как переменная типа Message, а именно Message?, то есть типа, который может представлять как делегат Message, так и значение null.

Кроме того, перед вторым вызовом мы проверяем переменную на значение null.

При удалении следует учитывать, что если делегат содержит несколько ссылок на один и тот же метод, то операция -= начинает поиск с конца списка вызова делегата и удаляет только первое найденное вхождение. Если подобного метода в списке вызова делегата нет, то операция -= не имеет никакого эффекта.

## Объединение делегатов

Делегаты можно объединять в другие делегаты. Например:

```Csharp
Message mes1 = Hello;
Message mes2 = HowAreYou;
Message mes3 = mes1 + mes2; // объединяем делегаты
mes3(); // вызываются все методы из mes1 и mes2
 
void Hello() => Console.WriteLine("Hello");
void HowAreYou() => Console.WriteLine("How are you?");
 
delegate void Message();
```

В данном случае объект mes3 представляет объединение делегатов mes1 и mes2. Объединение делегатов значит, что в список вызова делегата mes3 попадут все методы из делегатов mes1 и mes2. И при вызове делегата mes3 все эти методы одновременно будут вызваны.

## Вызов делегата

В примерах выше делегат вызывался как обычный метод. Если делегат принимал параметры, то при его вызове для параметров передавались необходимые значения:

```Csharp
Message mes = Hello;
mes();
Operation op = Add;
int n = op(3, 4);
Console.WriteLine(n);
 
void Hello() => Console.WriteLine("Hello");
int Add(int x, int y) => x + y;
 
delegate int Operation(int x, int y);
delegate void Message();
```

Другой способ вызова делегата представляет метод Invoke():

```Csharp
Message mes = Hello;
mes.Invoke(); // Hello
Operation op = Add;
int n = op.Invoke(3, 4);
Console.WriteLine(n);   // 7
 
void Hello() => Console.WriteLine("Hello");
int Add(int x, int y) => x + y;
 
delegate int Operation(int x, int y);
delegate void Message();
```

Если делегат принимает параметры, то в метод Invoke передаются значения для этих параметров.

Следует учитывать, что если делегат пуст, то есть в его списке вызова нет ссылок ни на один из методов (то есть делегат равен Null), то при вызове такого делегата мы получим исключение, как, например, в следующем случае:

```Csharp
Message? mes;
//mes();        // ! Ошибка: делегат равен null
 
Operation? op = Add;
op -= Add;      // делегат op пуст
int n = op(3, 4);       // !Ошибка: делегат равен null
```

Поэтому при вызове делегата всегда лучше проверять, не равен ли он null. Либо можно использовать метод Invoke и оператор условного null:

```Csharp
Message? mes = null;
mes?.Invoke();        // ошибки нет, делегат просто не вызывается
 
Operation? op = Add;
op -= Add;          // делегат op пуст
int? n = op?.Invoke(3, 4);   // ошибки нет, делегат просто не вызывается, а n = null

```

Если делегат возвращает некоторое значение, то возвращается значение последнего метода из списка вызова (если в списке вызова несколько методов). Например:

```Csharp
Operation op = Subtract;
op += Multiply;
op += Add;
Console.WriteLine(op(7, 2));    // Add(7,2) = 9
 
int Add(int x, int y) => x + y;
int Subtract(int x, int y) => x - y;
int Multiply(int x, int y) => x * y;
 
delegate int Operation(int x, int y);
```

## Обобщенные делегаты

Делегаты, как и другие типы, могут быть обобщенными, например:

```Csharp
Operation<decimal, int> squareOperation = Square;
decimal result1 = squareOperation(5);
Console.WriteLine(result1);  // 25
 
Operation<int, int> doubleOperation = Double;
int result2 = doubleOperation(5);
Console.WriteLine(result2);  // 10
 
decimal Square(int n) => n * n;
int Double(int n) => n + n;
 
delegate T Operation<T, K>(K val);
```

Здесь делегат Operation типизируется двумя параметрами типов. Параметр T представляет тип возвращаемого значения. А параметр K представляет тип передаваемого в делегат параметра. Таким образом, этому делегату соответствует метод, который принимает параметр любого типа и возвращает значение любого типа.

В прогамме мы можем определить переменные делегата под определенный метод. Например, делегату Operation<decimal, int> соответствует метод, который принимает число int и возвращает число типа decimal. А делегату Operation<int, int> соответствует метод, который принимает и возвращает число типа int.

## Делегаты как параметры методов

Также делегаты могут быть параметрами методов. Благодаря этому один метод в качестве параметров может получать действия - другие методы. Например:

```Csharp
DoOperation(5, 4, Add);         // 9
DoOperation(5, 4, Subtract);    // 1
DoOperation(5, 4, Multiply);    // 20
 
void DoOperation(int a, int b, Operation op)
{
    Console.WriteLine(op(a,b));
}
int Add(int x, int y) => x + y;
int Subtract(int x, int y) => x - y;
int Multiply(int x, int y) => x * y;
 
delegate int Operation(int x, int y);
```

Здесь метод DoOperation в качестве параметров принимает два числа и некоторое действие в виде делегата Operation. В внутри метода вызываем делегат Operation, передавая ему числа из первых двух параметров.

При вызове метода DoOperation мы можем передать в него в качестве третьего параметра метод, который соответствует делегату Operation.

## Возвращение делегатов из метода

Также делегаты можно возвращать из методов. То есть мы можем возвращать из метода какое-то действие в виде другого метода. Например:

```Csharp
Operation operation = SelectOperation(OperationType.Add);
Console.WriteLine(operation(10, 4));    // 14
 
operation = SelectOperation(OperationType.Subtract);
Console.WriteLine(operation(10, 4));    // 6
 
operation = SelectOperation(OperationType.Multiply);
Console.WriteLine(operation(10, 4));    // 40
 
Operation SelectOperation(OperationType opType)
{
    switch (opType)
    {
        case OperationType.Add: return Add;
        case OperationType.Subtract: return Subtract;
        default: return Multiply;
    }
}
 
int Add(int x, int y) => x + y;
int Subtract(int x, int y) => x - y;
int Multiply(int x, int y) => x * y;
 
enum OperationType
{
    Add, Subtract, Multiply
}
delegate int Operation(int x, int y);
```

В данном случае метод SelectOperation() в качестве параметра принимает перечисление типа OperationType. Это перечисление хранит три константы, каждая из которых соответствует определенной арифметической операции. И в самом методе в зависимости от значения параметра возвращаем определенный метод. Причем поскольку возвращаемый тип метода - делегат Operation, то метод должен возвратить метод, который соответствует этому делегату - в нашем случае это методы Add, Subtract, Multiply. То есть если параметр метода SelectOperation равен OperationType.Add, то возвращается метод Add, который выолняет сложение двух чисел:

```Csharp
case OperationType.Add: return Add;
```
При вызове метода SelectOperation мы можем получить из него нужное действие в переменную operation:

```Csharp
Operation operation = SelectOperation(OperationType.Add);
```

И при вызове переменной operation фактически будет вызываться полученный из SelectOperation метод:

```Csharp
Operation operation = SelectOperation(OperationType.Add);   // Здесь operation = Add
Console.WriteLine(operation(10, 4));    // 14
```

# Применение делегатов

В прошлой теме подробно были рассмотрены делегаты. Однако данные примеры, возможно, не показывают истинной силы делегатов, так как нужные нам методы в данном случае мы можем вызвать и напрямую без всяких делегатов. Однако наиболее сильная сторона делегатов состоит в том, что они позволяют делегировать выполнение некоторому коду извне. И на момент написания программы мы можем не знать, что за код будет выполняться. Мы просто вызываем делегат. А какой метод будет непосредственно выполняться при вызове делегата, будет решаться потом.

Рассмотрим подробный пример. Пусть у нас есть класс, описывающий счет в банке:

```Csharp
public class Account
{
    int sum; // Переменная для хранения суммы
    // через конструктор устанавливается начальная сумма на счете
    public Account(int sum) => this.sum = sum;
    // добавить средства на счет
    public void Add(int sum) => this.sum += sum;
    // взять деньги с счета
    public void Take(int sum)
    {
        // берем деньги, если на счете достаточно средств
        if (this.sum >=sum) this.sum -= sum;
    }
}
```

В переменной sum хранится сумма на счете. С помощью конструктора устанавливается начальная сумма на счете. Метод Add() служит для добавления на счет, а метод Take - для снятия денег со счета.

Допустим, в случае вывода денег с помощью метода Take нам надо как-то уведомлять об этом самого владельца счета и, может быть, другие объекты. Если речь идет о консольной программе, и класс будет применяться в том же проекте, где он создан, то мы можем написать просто:

```Csharp
public class Account
{
    int sum;
    public Account(int sum) => this.sum = sum;
    public void Add(int sum) => this.sum += sum;
    public void Take(int sum)
    {
        if (this.sum >= sum)
        {
            this.sum -= sum;
            Console.WriteLine($"Со счета списано {sum} у.е.");
        }
    }
}
```

Но что если наш класс планируется использовать в других проектах, например, в графическом приложении на Windows Forms или WPF, в мобильном приложении, в веб-приложении. Там строка уведомления

```Csharp
Console.WriteLine($"Со счета списано {sum} у.е.");
```

не будет иметь большого смысла.

Более того, наш класс Account будет использоваться другими разработчиками в виде отдельной библиотеки классов. И эти разработчики захотят уведомлять о снятии средств каким-то другим образом, о которых мы даже можем не догадываться на момент написания класса. Поэтому примитивое уведомление в виде строки кода

```Csharp
Console.WriteLine($"Со счета списано {sum} у.е.");
```

не самое лучшее решение в данном случае. И делегаты позволяют делегировать определение действия из класса во внешний код, который будет использовать этот класс.

Изменим класс, применив делегаты:

```Csharp
// Объявляем делегат
public delegate void AccountHandler(string message);
public class Account
{
    int sum;
    // Создаем переменную делегата
    AccountHandler? taken;
    public Account(int sum) => this.sum = sum;
    // Регистрируем делегат
    public void RegisterHandler(AccountHandler del)
    {
        taken = del;
    }
    public void Add(int sum) => this.sum += sum;
    public void Take(int sum)
    {
        if (this.sum >= sum)
        {
            this.sum -= sum;
            // вызываем делегат, передавая ему сообщение
            taken?.Invoke($"Со счета списано {sum} у.е.");
        }
        else
        {
            taken?.Invoke($"Недостаточно средств. Баланс: {this.sum} у.е.");
        }
    }
}
```

Для делегирования действия здесь определен делегат AccountHandler. Этот делегат соответствует любым методам, которые имеют тип void и принимают параметр типа string.

```Csharp
public delegate void AccountHandler(string message);
```

В классе Account определяем переменную taken, которая представляет этот делегат:

```Csharp
AccountHandler? taken;
```

Теперь надо связать эту переменную с конкретным действием, которое будет выполняться. Мы можем использовать разные способы для передачи делегата в класс. В данном случае определяется специальный метод RegisterHandler, который передается в переменную taken реальное действие:

```Csharp
public void RegisterHandler(AccountHandler del)
{
    taken = del;
}
```

Таким образом, делегат установлен, и теперь его можно вызывать. Вызов делегата производится в методе Take:

```Csharp
public void Take(int sum)
{
    if (this.sum >= sum)
    {
        this.sum -= sum;
        // вызываем делегат, передавая ему сообщение
        taken?.Invoke($"Со счета списано {sum} у.е.");
    }
    else
    {
        taken?.Invoke($"Недостаточно средств. Баланс: {this.sum} у.е.");
    }
}
```

Поскольку делегат AccountHandler в качестве параметра принимает строку, то при вызове переменной taken() мы можем передать в этот вызов конкретное сообщение. В зависимости от того, произошло снятие денег или нет, в вызов делегата передаются разные сообщения.

То есть фактически вместо делегата будут выполняться действия, которые переданы делегату в методе RegisterHandler. Причем опять же подчеркну, при вызове делегата мы не значем, что это будут действия. Здесь мы только передаем в эти действия сообщение об успешно или неудачном снятии.

Теперь протестируем класс в основной программе:

```Csharp
// создаем банковский счет
Account account = new Account(200);
// Добавляем в делегат ссылку на метод PrintSimpleMessage
account.RegisterHandler(PrintSimpleMessage);
// Два раза подряд пытаемся снять деньги
account.Take(100);
account.Take(150);
 
void PrintSimpleMessage(string message) => Console.WriteLine(message);
```

Здесь через метод RegisterHandler переменной taken в классе Account передается ссылка на метод PrintSimpleMessage. Этот метод соответствует делегату AccountHandler. Соответственно там, где вызывается делегат taken в методе Account, в реальности будет выполняться метод PrintSimpleMessage.

Через параметр message метод PrintSimpleMessage получит переданное из делегата сообщение и выведет его на консоль:

```
Со счета списано 100 у.е.
Недостаточно средств. Баланс: 100 у.е.
```

Таким образом, мы создали механизм обратного вызова для класса Account, который срабатывает в случае снятия денег. Здесь мы выводим сообщение на консоль. Да, мы могли бы просто выводить сообщение на консоль и без делегатов. Однако с делегатом для класса Account не важно, как это сообщение выводится. Классу Account даже не известно, что вообще будет делаться в результате списания денег. Он просто посылает уведомление об этом через делегат.

В результате, если мы создаем консольное приложение, мы можем через делегат выводить сообщение на консоль. Если мы создаем графическое приложение Windows Forms или WPF, то можно выводить сообщение в виде графического окна. А можно не просто выводить сообщение. А, например, записать при списании информацию об этом действии в файл или отправить уведомление на электронную почту. В общем любыми способами обработать вызов делегата. И способ обработки не будет зависеть от класса Account.

## Добавление и удаление методов в делегате

Хотя в примере наш делегат принимал адрес на один метод, в действительности он может указывать сразу на несколько методов. Кроме того, при необходимости мы можем удалить ссылки на адреса определенных методов, чтобы они не вызывались при вызове делегата. Итак, изменим в классе Account метод RegisterHandler и добавим новый метод UnregisterHandler, который будет удалять методы из списка методов делегата:

```Csharp
public delegate void AccountHandler(string message);
public class Account
{
    int sum;
    AccountHandler? taken;
    public Account(int sum) => this.sum = sum;
    // Регистрируем делегат
    public void RegisterHandler(AccountHandler del)
    {
        taken += del;
    }
    // Отмена регистрации делегата
    public void UnregisterHandler(AccountHandler del)
    {
        taken -= del; // удаляем делегат
    }
    public void Add(int sum) => this.sum += sum;
    public void Take(int sum)
    {
        if (this.sum >= sum)
        {
            this.sum -= sum;
            taken?.Invoke($"Со счета списано {sum} у.е.");
        }
        else
            taken?.Invoke($"Недостаточно средств. Баланс: {this.sum} у.е.");
    }
}
```

В первом методе объединяет делегаты taken и del в один, который потом присваивается переменной taken. Во втором методе из переменной taken удаляется делегат del.

Применим новые методы:

```Csharp
Account account = new Account(200);
// Добавляем в делегат ссылку на методы
account.RegisterHandler(PrintSimpleMessage);
account.RegisterHandler(PrintColorMessage);
// Два раза подряд пытаемся снять деньги
account.Take(100);
account.Take(150);
 
// Удаляем делегат
account.UnregisterHandler(PrintColorMessage);
// снова пытаемся снять деньги
account.Take(50);
 
void PrintSimpleMessage(string message) => Console.WriteLine(message);
void PrintColorMessage(string message)
{
    // Устанавливаем красный цвет символов
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine(message);
    // Сбрасываем настройки цвета
    Console.ResetColor();
}
```

В целях тестирования мы создали еще один метод - PrintColorMessage, который выводит то же самое сообщение только красным цветом. Ссылка на этот метод также передается в метод RegisterHandler, и таким образом ее получит переменная taken.

В строке account.UnregisterHandler(PrintColorMessage); этот метод удаляется из списка вызовов делегата, поэтому этот метод больше не будет срабатывать. Консольный вывод будет иметь следующую форму:

```
Со счета списано 100 у.е.
Со счета списано 100 у.е.
Недостаточно средств. Баланс: 100 у.е.
Недостаточно средств. Баланс: 100 у.е.
Со счета списано 50 у.е.
```

## Анонимные методы

С делегатами тесно связаны анонимные методы. Анонимные методы используются для создания экземпляров делегатов.

Определение анонимных методов начинается с ключевого слова delegate, после которого идет в скобках список параметров и тело метода в фигурных скобках:

```Csharp
delegate(параметры)
{
    // инструкции
}
```

Например:

```Csharp
MessageHandler handler = delegate (string mes)
{
    Console.WriteLine(mes);
};
handler("hello world!");
 
delegate void MessageHandler(string message);
```

Анонимный метод не может существовать сам по себе, он используется для инициализации экземпляра делегата, как в данном случае переменная handler представляет анонимный метод. И через эту переменную делегата можно вызвать данный анонимный метод.

Другой пример анонимных методов - передача в качестве аргумента для параметра, который представляет делегат:

```Csharp
ShowMessage("hello!", delegate (string mes)
{
    Console.WriteLine(mes);
});
 
static void ShowMessage(string message, MessageHandler handler)
{
    handler(message);
}
 
delegate void MessageHandler(string message);
```

Если анонимный метод использует параметры, то они должны соответствовать параметрам делегата. Если для анонимного метода не требуется параметров, то скобки с параметрами опускаются. При этом даже если делегат принимает несколько параметров, то в анонимном методе можно вовсе опустить параметры:

```Csharp
MessageHandler handler = delegate
{
    Console.WriteLine("анонимный метод");
};
handler("hello world!");    // анонимный метод
 
delegate void MessageHandler(string message);
```

То есть если анонимный метод содержит параметры, они обязательно должны соответствовать параметрам делегата. Либо анонимный метод вообще может не содержать никаких параметров, тогда он соответствует любому делегату, который имеет тот же тип возвращаемого значения.

При этом параметры анонимного метода не могут быть опущены, если один или несколько параметров определены с модификатором out.

Также, как и обычные методы, анонимные могут возвращать результат:

```Csharp
Operation operation = delegate (int x, int y)
{
    return x + y;
};
int result = operation(4, 5);
Console.WriteLine(result);       // 9
 
delegate int Operation(int x, int y);
```

При этом анонимный метод имеет доступ ко всем переменным, определенным во внешнем коде:

```Csharp
int z = 8;
Operation operation = delegate (int x, int y)
{
    return x + y + z;
};
int result = operation(4, 5);
Console.WriteLine(result);       // 17
 
delegate int Operation(int x, int y);
```

В каких ситуациях используются анонимные методы? Когда нам надо определить однократное действие, которое не имеет много инструкций и нигде больше не используется. В частности, их можно использовать для обработки событий, которые будут рассмотрены далее.

# Лямбды

Лямбда-выражения представляют упрощенную запись анонимных методов. Лямбда-выражения позволяют создать емкие лаконичные методы, которые могут возвращать некоторое значение и которые можно передать в качестве параметров в другие методы.

Ламбда-выражения имеют следующий синтаксис: слева от лямбда-оператора => определяется список параметров, а справа блок выражений, использующий эти параметры:

```
(список_параметров) => выражение
```

С точки зрения типа данных лямбда-выражение представляет делегат. Например, определим простейшее лямбда-выражение:

```Csharp
Message hello = () => Console.WriteLine("Hello");
hello();       // Hello
hello();       // Hello
hello();       // Hello
 
delegate void Message();
```

В данном случае переменная hello представляет делегат Message - то есть некоторое действие, которое ничего не возвращает и не принимает никаких параметров. В качестве значения этой переменной присваивается лямбда-выражение. Это лямбда-выражение должно соответствовать делегату Message - оно тоже не принимает никаких параметров, поэтому слева от лямбда-оператора идут пустые скобки. А справа от лямбда-оператора идет выполняемое выражение - Console.WriteLine("Hello")

Затем в программе можно вызывать эту переменную как метод.

Если лямбда-выражение содержит несколько действий, то они помещаются в фигурные скобки:

```Csharp
Message hello = () =>
{
    Console.Write("Hello ");
    Console.WriteLine("World");
};
hello();       // Hello World
```

Выше мы определили переменную hello, которая представляет делегат Message. Но начиная с версии C# 10 мы можем применять неявную типизацию (определение переменной с помощью оператора var) при определении лямбда-выражения:

```Csharp
var hello = () => Console.WriteLine("Hello");
hello();       // Hello
hello();       // Hello
hello();       // Hello
```

Но какой тип в данном случае представляет переменная hello? При неявной типизации компилятор сам пытается сопоставить лямбда-выражение на основе его опеределения с каким-нибудь делегатом. Например, выше определенное лямбда-выражение hello по умолчанию компилятор будет рассматривать как переменную встроенного делегата Action, который не принимает никаких параметров и ничего не возвращает.

## Параметры лямбды

При определении списка параметров мы можем не указывать для них тип данных:

```Csharp
Operation sum = (x, y) => Console.WriteLine($"{x} + {y} = {x + y}");
sum(1, 2);       // 1 + 2 = 3
sum(22, 14);    // 22 + 14 = 36
 
delegate void Operation(int x, int y);
```

В данном случае компилятор видит, что лямбда-выражение sum представляет тип Operation, а значит оба параметра лямбды представляют тип int. Поэтому никак проблем не возникнет.

Однако если мы применяем неявную типизацию, то у компилятора могут возникнуть трудности, чтобы вывести тип делегата для лямбда-выражения, например, в следующем случае

```Csharp
var sum = (x, y) => Console.WriteLine($"{x} + {y} = {x + y}");   // ! Ошибка
```

В этом случае можно указать тип параметров

```Csharp
var sum = (int x, int y) => Console.WriteLine($"{x} + {y} = {x + y}");
sum(1, 2);       // 1 + 2 = 3
sum(22, 14);    // 22 + 14 = 36
```

Если лямбда имеет один параметр, для которого не требуется указывать тип данных, то скобки можно опустить:

```Csharp
PrintHandler print = message => Console.WriteLine(message);
print("Hello");         // Hello
print("Welcome");       // Welcome
 
delegate void PrintHandler(string message);
```

## Возвращение результата

Лямбда-выражение может возвращать результат. Возвращаемый результат можно указать после лямбда-оператора:

```Csharp
var sum = (int x, int y) => x + y;
int sumResult = sum(4, 5);                  // 9
Console.WriteLine(sumResult);               // 9
 
Operation multiply = (x, y) => x * y;
int multiplyResult = multiply(4, 5);        // 20
Console.WriteLine(multiplyResult);          // 20
 
delegate int Operation(int x, int y);
```

Если лямбда-выражение содержит несколько выражение, тогда нужно использовать оператор return, как в обычных методах:

```Csharp
var subtract = (int x, int y) =>
{
    if (x > y) return x - y;
    else return y - x;
};
int result1 = subtract(10, 6);  // 4 
Console.WriteLine(result1);     // 4
 
int result2 = subtract(-10, 6);  // 16
Console.WriteLine(result2);      // 16
```

## Добавление и удаление действий в лямбда-выражении

Поскольку лямбда-выражение представляет делегат, тот как и в делегат, в переменную, которая представляет лямбда-выражение можно добавлять методы и другие лямбды:

```Csharp
var hello = () => Console.WriteLine("METANIT.COM");
 
var message = () => Console.Write("Hello ");
message += () => Console.WriteLine("World"); // добавляем анонимное лямбда-выражение
message += hello;   // добавляем лямбда-выражение из переменной hello
message += Print;   // добавляем метод
 
message();
Console.WriteLine("--------------"); // для разделения вывода
 
message -= Print;   // удаляем метод
message -= hello;   // удаляем лямбда-выражение из переменной hello
 
message?.Invoke();  // на случай, если в message больше нет действий
 
void Print() => Console.WriteLine("Welcome to C#");
```

```
Hello World
METANIT.COM
Welcome to C#
--------------
Hello World
```

## Лямбда-выражение как аргумент метода

Как и делегаты, лямбда-выражения можно передавать параметрам метода, которые представляют делегат:

```Csharp
int[] integers = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
 
// найдем сумму чисел больше 5
int result1 = Sum(integers, x => x > 5);
Console.WriteLine(result1); // 30
 
// найдем сумму четных чисел
int result2 = Sum(integers, x => x % 2 == 0);
Console.WriteLine(result2);  //20
 
int Sum(int[] numbers, IsEqual func)
{
    int result = 0;
    foreach (int i in numbers)
    {
        if (func(i))
            result += i;
    }
    return result;
}
 
delegate bool IsEqual(int x);
```

Метод Sum принимает в качестве параметра массив чисел и делегат IsEqual и возвращает сумму чисел массива в виде объекта int. В цикле проходим по всем числам и складываем их. Причем складываем только те числа, для которых делегат IsEqual func возвращает true. То есть делегат IsEqual здесь фактически задает условие, которому должны соответствовать значения массива. Но на момент написания метода Sum нам неизвестно, что это за условие.

При вызове метода Sum ему передается массив и лямбда-выражение:

```Csharp
int result1 = Sum(integers, x => x > 5);
```

То есть параметр x здесь будет представлять число, которое передается в делегат:

```Csharp
if (func(i))
```

А выражение x > 5 представляет условие, которому должно соответствовать число. Если число соответствует этому условию, то лямбда-выражение возвращает true, а переданное число складывается с другими числами.

Подобным образом работает второй вызов метода Sum, только здесь уже идет проверка числа на четность, то есть если остаток от деления на 2 равен нулю:

```Csharp
int result2 = Sum(integers, x => x % 2 == 0);
```

## Лямбда-выражение как результат метода

Метод также может возвращать лямбда-выражение. В этом случае возвращаемым типом метода выступает делегат, которому соответствует возвращаемое лямбда-выражение. Например:

```Csharp
Operation operation = SelectOperation(OperationType.Add);
Console.WriteLine(operation(10, 4));    // 14
 
operation = SelectOperation(OperationType.Subtract);
Console.WriteLine(operation(10, 4));    // 6
 
operation = SelectOperation(OperationType.Multiply);
Console.WriteLine(operation(10, 4));    // 40
 
Operation SelectOperation(OperationType opType)
{
    switch (opType)
    {
        case OperationType.Add: return (x, y) => x + y;
        case OperationType.Subtract: return (x, y) => x - y;
        default: return (x, y) => x * y;
    }
}
enum OperationType
{
    Add, Subtract, Multiply
}
delegate int Operation(int x, int y);
```

В данном случае метод SelectOperation() в качестве параметра принимает перечисление типа OperationType. Это перечисление хранит три константы, каждая из которых соответствует определенной арифметической операции. И в самом методе в зависимости от значения параметра возвращаем определенное лямбда-выражение.

# События

События сигнализируют системе о том, что произошло определенное действие. И если нам надо отследить эти действия, то как раз мы можем применять события.

Например, возьмем следующий класс, который описывает банковский счет:

```Csharp
class Account
{
    // сумма на счете
    public int Sum { get; private set; }
    // в конструкторе устанавливаем начальную сумму на счете
    public Account(int sum) => Sum = sum;
    // добавление средств на счет
    public void Put(int sum) => Sum += sum;
    // списание средств со счета
    public void Take(int sum)
    {
        if (Sum >= sum)
        {
            Sum -= sum;
        }
    }
}
```

В конструкторе устанавливаем начальную сумму, которая хранится в свойстве Sum. С помощью метода Put мы можем добавить средства на счет, а с помощью метода Take, наоборот, снять деньги со счета. Попробуем использовать класс в программе - создать счет, положить и снять с него деньги:

```Csharp
Account account = new Account(100);
account.Put(20);    // добавляем на счет 20
Console.WriteLine($"Сумма на счете: {account.Sum}");
account.Take(70);   // пытаемся снять со счета 70
Console.WriteLine($"Сумма на счете: {account.Sum}");
account.Take(180);  // пытаемся снять со счета 180
Console.WriteLine($"Сумма на счете: {account.Sum}");
```

Консольный вывод:

```
Сумма на счете: 120
Сумма на счете: 50
Сумма на счете: 50
```

Все операции работают как и положено. Но что если мы хотим уведомлять пользователя о результатах его операций. Мы могли бы, например, для этого изменить метод Put следующим образом:

```Csharp
public void Put(int sum)    
{
    Sum += sum;
    Console.WriteLine($"На счет поступило: {sum}");
}
```

Казалось, теперь мы будем извещены об операции, увидев соответствующее сообщение на консоли. Но тут есть ряд замечаний. На момент определения класса мы можем точно не знать, какое действие мы хотим произвести в методе Put в ответ на добавление денег. Это может вывод на консоль, а может быть мы захотим уведомить пользователя по email или sms. Более того мы можем создать отдельную библиотеку классов, которая будет содержать этот класс, и добавлять ее в другие проекты. И уже из этих проектов решать, какое действие должно выполняться. Возможно, мы захотим использовать класс Account в графическом приложении и выводить при добавлении на счет в графическом сообщении, а не консоль. Или нашу библиотеку классов будет использовать другой разработчик, у которого свое мнение, что именно делать при добавлении на счет. И все эти вопросы мы можем решить, используя события.

## Определение и вызов событий

События объявляются в классе с помощью ключевого слова event, после которого указывается тип делегата, который представляет событие:

```Csharp
delegate void AccountHandler(string message);
event AccountHandler Notify;
```

В данном случае вначале определяется делегат AccountHandler, который принимает один параметр типа string. Затем с помощью ключевого слова event определяется событие с именем Notify, которое представляет делегат AccountHandler. Название для события может быть произвольным, но в любом случае оно должно представлять некоторый делегат.

Определив событие, мы можем его вызвать в программе как метод, используя имя события:

```Csharp
Notify("Произошло действие");
```

Поскольку событие Notify представляет делегат AccountHandler, который принимает один параметр типа string - строку, то при вызове события нам надо передать в него строку.

Однако при вызове событий мы можем столкнуться с тем, что событие равно null в случае, если для его не определен обработчик. Поэтому при вызове события лучше его всегда проверять на null. Например, так:

```Csharp
if(Notify !=null) Notify("Произошло действие");
```

Или так:

```Csharp
Notify?.Invoke("Произошло действие");
```

В этом случае поскольку событие представляет делегат, то мы можем его вызвать с помощью метода Invoke(), передав в него необходимые значения для параметров.

Объединим все вместе и создадим и вызовем событие:

```Csharp
class Account
{
    public delegate void AccountHandler(string message);
    public event AccountHandler? Notify;              // 1.Определение события
    public Account(int sum) => Sum = sum;
    public int Sum { get; private set; }
    public void Put(int sum)
    {
        Sum += sum;
        Notify?.Invoke($"На счет поступило: {sum}");   // 2.Вызов события 
    }
    public void Take(int sum)
    {
        if (Sum >= sum)
        {
            Sum -= sum;
            Notify?.Invoke($"Со счета снято: {sum}");   // 2.Вызов события
        }
        else
        {
            Notify?.Invoke($"Недостаточно денег на счете. Текущий баланс: {Sum}"); ;
        }
    }
}
```

Теперь с помощью события Notify мы уведомляем систему о том, что были добавлены средства и о том, что средства сняты со счета или на счете недостаточно средств.

## Добавление обработчика события

С событием может быть связан один или несколько обработчиков. Обработчики событий - это именно то, что выполняется при вызове событий. Нередко в качестве обработчиков событий применяются методы. Каждый обработчик событий по списку параметров и возвращаемому типу должен соответствовать делегату, который представляет событие. Для добавления обработчика события применяется операция +=:

```
Notify += обработчик события;
```

Определим обработчики для события Notify, чтобы получить в программе нужные уведомления:

```Csharp
Account account = new Account(100);
account.Notify += DisplayMessage;   // Добавляем обработчик для события Notify
account.Put(20);    // добавляем на счет 20
Console.WriteLine($"Сумма на счете: {account.Sum}");
account.Take(70);   // пытаемся снять со счета 70
Console.WriteLine($"Сумма на счете: {account.Sum}");
account.Take(180);  // пытаемся снять со счета 180
Console.WriteLine($"Сумма на счете: {account.Sum}");
 
void DisplayMessage(string message) => Console.WriteLine(message);
```

В данном случае в качестве обработчика используется метод DisplayMessage, который соответствует по списку параметров и возвращаемому типу делегату AccountHandler. В итоге при вызове события Notify?.Invoke() будет вызываться метод DisplayMessage, которому для параметра message будет передаваться строка, которая передается в Notify?.Invoke(). В DisplayMessage просто выводим полученное от события сообщение, но можно было бы определить любую логику.

Если бы в данном случае обработчик не был бы установлен, то при вызове события Notify?.Invoke() ничего не происходило, так как событие Notify было бы равно null.

Консольный вывод программы:

```
На счет поступило: 20
Сумма на счете: 120
Со счета снято: 70
Сумма на счете: 50
Недостаточно денег на счете. Текущий баланс: 50
Сумма на счете: 50
```

Теперь мы можем выделить класс Account в отдельную библиотеку классов и добавлять в любой проект.

## Добавление и удаление обработчиков

Для одного события можно установить несколько обработчиков и потом в любой момент времени их удалить. Для удаления обработчиков применяется операция -=. Например:

```Csharp
Account account = new Account(100);
account.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
account.Notify += DisplayRedMessage;    // добавляем обработчик DisplayRedMessage
account.Put(20);    // добавляем на счет 20
account.Notify -= DisplayRedMessage;     // удаляем обработчик DisplayRedMessage
account.Put(50);    // добавляем на счет 50
 
void DisplayMessage(string message) => Console.WriteLine(message);
void DisplayRedMessage(string message)
{
    // Устанавливаем красный цвет символов
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine(message);
    // Сбрасываем настройки цвета
    Console.ResetColor();
}
```

Консольный вывод:

```
На счет поступило: 20
На счет поступило: 20
На счет поступило: 50
```

В качестве обработчиков могут использоваться не только обычные методы, но также делегаты, анонимные методы и лямбда-выражения. Использование делегатов и методов:

```Csharp
Account acc = new Account(100);
// установка делегата, который указывает на метод DisplayMessage
acc.Notify += new Account.AccountHandler(DisplayMessage);
// установка в качестве обработчика метода DisplayMessage
acc.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
 
acc.Put(20);    // добавляем на счет 20
 
void DisplayMessage(string message) => Console.WriteLine(message);
```

В данном случае разницы между двумя обработчиками никакой не будет.

Установка в качестве обработчика анонимного метода:

```Csharp
Account acc = new Account(100);
acc.Notify += delegate (string mes)
{
    Console.WriteLine(mes);
};
acc.Put(20);
```

Установка в качестве обработчика лямбда-выражения:

```Csharp
Account account = new Account(100);
account.Notify += message => Console.WriteLine(message);
account.Put(20);
```

## Управление обработчиками

С помощью специальных акссесоров add/remove мы можем управлять добавлением и удалением обработчиков. Как правило, подобная функциональность редко требуется, но тем не менее мы ее можем использовать. Например:

```Csharp
class Account
{
    public delegate void AccountHandler(string message);
    AccountHandler? notify;
    public event AccountHandler Notify
    {
        add
        {
            notify += value;
            Console.WriteLine($"{value.Method.Name} добавлен");
        }
        remove
        {
            notify -= value;
            Console.WriteLine($"{value.Method.Name} удален");
        }
    }
    public Account(int sum) => Sum = sum;
    public int Sum { get; private set; }
    public void Put(int sum)
    {
        Sum += sum;
        notify?.Invoke($"На счет поступило: {sum}");   // 2.Вызов события 
    }
    public void Take(int sum)
    {
        if (Sum >= sum)
        {
            Sum -= sum;
            notify?.Invoke($"Со счета снято: {sum}");   // 2.Вызов события
        }
        else
        {
            notify?.Invoke($"Недостаточно денег на счете. Текущий баланс: {Sum}"); ;
        }
    }
}
```

Теперь опредление события разбивается на две части. Вначале просто определяется переменная делегата, через которую мы можем вызывать связанные обработчики:

```Csharp
AccountHandler notify;
```

Во второй части определяем акссесоры add и remove. Аксессор add вызывается при добавлении обработчика, то есть при операции +=. Добавляемый обработчик доступен через ключевое слово value. Здесь мы можем получить информацию об обработчике (например, имя метода через value.Method.Name) и определить некоторую логику. В данном случае для простоты просто выводится сообщение на консоль:

```Csharp
add
{
    notify += value;
    Console.WriteLine($"{value.Method.Name} добавлен");
}
```

Блок remove вызывается при удалении обработчика. Аналогично здесь можно задать некоторую дополнительную логику:

```Csharp
remove
{
    notify -= value;
    Console.WriteLine($"{value.Method.Name} удален");
}
```

Внутри класса событие вызывается также через переменную notify. Но для добавления и удаления обработчиков в программе используется как раз Notify:

```Csharp
Account acc = new Account(100);
acc.Notify += DisplayMessage;       // добавляем обработчик DisplayMessage
acc.Put(20);    // добавляем на счет 20
acc.Notify -= DisplayMessage;     // удаляем обработчик DisplayMessage
acc.Put(20);    // добавляем на счет 20
 
void DisplayMessage(string message) => Console.WriteLine(message);
```

Консольный вывод программы:

```Csharp
DisplayMessage добавлен
На счет поступило: 20
DisplayMessage удален
```

## Передача данных события

Нередко при возникновении события обработчику события требуется передать некоторую информацию о событии. Например, добавим и в нашу программу новый класс AccountEventArgs со следующим кодом:

```Csharp
class AccountEventArgs
{
    // Сообщение
    public string Message{get;}
    // Сумма, на которую изменился счет
    public int Sum {get;}
    public AccountEventArgs(string message, int sum)
    {
        Message = message;
        Sum = sum;
    }
}
```

Данный класс имеет два свойства: Message - для хранения выводимого сообщения и Sum - для хранения суммы, на которую изменился счет.

Теперь применим класс AccoutEventArgs, изменив класс Account следующим образом:

```Csharp
class Account
{
    public delegate void AccountHandler(Account sender, AccountEventArgs e);
    public event AccountHandler? Notify;
     
    public int Sum { get; private set; }
     
    public Account(int sum) => Sum = sum;
     
    public void Put(int sum)
    {
        Sum += sum;
        Notify?.Invoke(this, new AccountEventArgs($"На счет поступило {sum}", sum));
    }
    public void Take(int sum)
    {
        if (Sum >= sum)
        {
            Sum -= sum;
            Notify?.Invoke(this, new AccountEventArgs($"Сумма {sum} снята со счета", sum));
        }
        else
        {
            Notify?.Invoke(this, new AccountEventArgs("Недостаточно денег на счете", sum));
        }
    }
}
```

По сравнению с предыдущей версией класса Account здесь изменилось только количество параметров у делегата и соответственно количество параметров при вызове события. Теперь делегат AccountHandler в качестве первого параметра принимает объект, который вызвал событие, то есть текущий объект Account. А в качестве второго параметра принимает объект AccountEventArgs, который хранит информацию о событии, получаемую через конструктор.

Теперь изменим основную программу:

```Csharp
Account acc = new Account(100);
acc.Notify += DisplayMessage;
acc.Put(20);
acc.Take(70);
acc.Take(150);
 
void DisplayMessage(Account sender, AccountEventArgs e)
{
    Console.WriteLine($"Сумма транзакции: {e.Sum}");
    Console.WriteLine(e.Message);
    Console.WriteLine($"Текущая сумма на счете: {sender.Sum}");
}
```

По сравнению с предыдущим вариантом здесь мы только изменяем количество параметров и их использования в обработчике DisplayMessage. Благодаря первому параметру в методе можно получить информацию об отправителе события - счете, с которым производится операция. А через второй параметр можно получить инфомацию о состоянии операции.

# Ковариантность и контравариантность делегатов

Делегаты могут быть ковариантными и контравариантными. Ковариантность делегата предполагает, что возвращаемым типом может быть производный тип. Контрвариантность делегата предполагает, что типом параметра может быть более универсальный тип.

Рассмотрим ковариантность и контравариантность на примере следующих классов:

```Csharp
class Message
{
    public string Text { get; }
    public Message(string text) => Text = text;
    public virtual void Print() => Console.WriteLine($"Message: {Text}");
}
class EmailMessage: Message
{
    public EmailMessage(string text): base(text) { }
    public override void Print() => Console.WriteLine($"Email: {Text}");
}
class SmsMessage : Message
{
    public SmsMessage(string text) : base(text) { }
    public override void Print() => Console.WriteLine($"Sms: {Text}");
}
```

В данном случае класс Message представляет некоторое сообщение и определяет свойство Text для хранения текста сообщения, который устанавливается через конструктор. А в методе Print сообщение выводится на консоль. Класс EmailMessage представляет email-сообщение, а SmsMessage - смс-сообщение, и оба класса является производными от Message.

## Ковариантность

Ковариантность позволяет передать делегату метод, возвращаемый тип которого является производный от возвращаемого типа делегат. То есть если возвращаемый тип делегата Message, то у метод может иметь в качестве возвращаемого типа класс EmailMessage:

```Csharp
// делегату с базовым типом передаем метод с производным типом
MessageBuilder messageBuilder = WriteEmailMessage; // ковариантность
Message message = messageBuilder("Hello");
message.Print();    // Email: Hello
 
EmailMessage WriteEmailMessage(string text) => new EmailMessage(text);
 
delegate Message MessageBuilder(string text);
```

Здесь делегат MessageBuilder возвращает объект Message. Однако благодаря ковариантности данный делегат может указывать на метод, который возвращает объект производного типа, например, на метод WriteEmailMessage.

## Контрвариантность

Контрвариантность позволяет присваить делегату метод, тип параметра которого является более универсальным по отношению к типу параметра делегата. Например, возьмем выше определенные классы Message и EmailMessage и используем их в следующем примере:

```Csharp
// делегату с производным типом передаем метод с базовым типом
EmailReceiver emailBox = ReceiveMessage; // контравариантность
emailBox(new EmailMessage("Welcome"));  // Email: Welcome
 
void ReceiveMessage(Message message) => message.Print();
 
delegate void EmailReceiver(EmailMessage message);
```

Несмотря на то, что делегат в качестве параметра принимает объект EmailMessage, ему можно присвоить метод, у которого параметр представляет базовый тип Message. Может показаться на первый взгляд, что здесь есть некоторое противоречие, то есть использование более универсального тип вместо более производного. Однако в реальности в делегат при его вызове мы все равно можем передать только объекты типа EmailMessage, а любой объект типа EmailMessage является объектом типа Message, который используется в методе.

## Ковариантность и контравариантность в обобщенных делегатах

Обобщенные делегаты также могут быть ковариантными и контравариантными, что дает нам больше гибкости в их использовании.

Ковариантность
Например, объявим и используем ковариантный обобщенный делегат:

```Csharp
// возвращает EmailMessage - более конкретный тип
MessageBuilder<EmailMessage> EmailMessageWriter = (string text) => new EmailMessage(text);
// возвращает более общий тип Message
MessageBuilder<Message> messageBuilder = EmailMessageWriter;     // ковариантность
Message message = messageBuilder("hello Tom"); // вызов делегата
message.Print(); // Email: hello Tom
 
delegate T MessageBuilder<out T>(string text);
```

Благодаря использованию out мы можем присвоить делегату типа MessageBuilder<Message> (более общий тип) делегат типа MessageBuilder<EmailMessage> (более конкретный тип).

Контравариантность
Рассмотрим контравариантный обобщенный делегат:

```Csharp
// принимает объект более общего типа
MessageReceiver<Message> messageReceiver = (Message message) => message.Print();
// принимает объект более конкретного типа
MessageReceiver<EmailMessage> emailMessageReceiver = messageReceiver; // контравариантность
 
messageReceiver(new Message("Hello World!"));       // Message: Hello World!
messageReceiver(new EmailMessage("Hello World!"));  // Email: Hello World!
 
delegate void MessageReceiver<in T>(T message);
```

Использование ключевого слова in позволяет присвоить делегату с производным типом (MessageReceiver<EmailMessage>) делегат с базовым типом (MessageReceiver<Message>).

Как и в случае с обобщенными интерфейсами параметр ковариантного типа применяется только к типу значения, которые возвращается делегатом. А параметр контравариантного типа применяется только к параметрам делегата.

То есть, если грубо обобщить, ковариантность - это от более производного к более общему типу (EmailMessage -> Message), а контрвариантность - от более общего к более производному типу (Message -> EmailMessage).

Совмещение ковариантности и контрвариантности
Причем делегат может одновеменно использовать оба оператора: in и out. Например:

```Csharp
MessageConverter<Message, EmailMessage> toEmailConverter = (Message message) => new EmailMessage(message.Text);
 
MessageConverter<SmsMessage, Message> converter = toEmailConverter;
Message message = converter(new SmsMessage("Hello work"));
message.Print();    // Email: Hello work
 
delegate E MessageConverter<in M, out E>(M message);
```

Здесь делегат MessageConverter представляет условное действие, которое конвертирует объект типа M в тип E.

В программе определена переменная converter, которая представляет тип MessageConverter<SmsMessage, Message> - то есть конвертер из типа SmsMessage в любой тип Message, грубо говоря преобразует смс в любой другой тип сообщения.

Этой переменной можно передать действие - toEmailConverter, которое из сообщений любого типа создает объект Email-сообщения. Здесь применяется контравариантность: для параметра вместо производного типа SmsMessage применяется базовый тип Message. И также есть ковариантность: вместо возвращаемого типа Message используется производный тип EmailMessage.

# Делегаты Action, Predicate и Func

В .NET есть несколько встроенных делегатов, которые используются в различных ситуациях. И наиболее используемыми, с которыми часто приходится сталкиваться, являются Action, Predicate и Func.

### Action

Делегат Action представляет некоторое действие, которое ничего не возвращает, то есть в качестве возвращаемого типа имеет тип void:s

```Csharp
public delegate void Action()
public delegate void Action<in T>(T obj)
```

Данный делегат имеет ряд перегруженных версий. Каждая версия принимает разное число параметров: от Action<in T1> до Action<in T1, in T2,....in T16>. Таким образом можно передать до 16 значений в метод.

Как правило, этот делегат передается в качестве параметра метода и предусматривает вызов определенных действий в ответ на произошедшие действия. Например:

```Csharp
DoOperation(10, 6, Add);        // 10 + 6 = 16
DoOperation(10, 6, Multiply);   // 10 * 6 = 60
 
void DoOperation(int a, int b, Action<int, int> op) => op(a, b);
 
void Add(int x, int y) => Console.WriteLine($"{x} + {y} = {x + y}");
void Multiply(int x, int y) => Console.WriteLine($"{x} * {y} = {x * y}");
```

### Predicate

Делегат Predicate<T> принимает один параметр и возвращает значение типа bool:

```Csharp
delegate bool Predicate<in T>(T obj);
```

Как правило, используется для сравнения, сопоставления некоторого объекта T определенному условию. В качестве выходного результата возвращается значение true, если условие соблюдено, и false, если не соблюдено:

```Csharp
Predicate<int> isPositive = (int x) => x > 0;
 
Console.WriteLine(isPositive(20));
Console.WriteLine(isPositive(-20));
```

В данном случае возвращается true или false в зависимости от того, больше нуля число или нет.

### Func

Еще одним распространенным делегатом является Func. Он возвращает результат действия и может принимать параметры. Он также имеет различные формы: от Func<out T>(), где T - тип возвращаемого значения, до Func<in T1, in T2,...in T16, out TResult>(), то есть может принимать до 16 параметров.

```Csharp
TResult Func<out TResult>()
TResult Func<in T, out TResult>(T arg)
TResult Func<in T1, in T2, out TResult>(T1 arg1, T2 arg2)
TResult Func<in T1, in T2, in T3, out TResult>(T1 arg1, T2 arg2, T3 arg3)
TResult Func<in T1, in T2, in T3, in T4, out TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)
//...........................................
```

Данный делегат также часто используется в качестве параметра в методах:

```Csharp
int result1 = DoOperation(6, DoubleNumber); // 12
Console.WriteLine(result1);
 
int result2 = DoOperation(6, SquareNumber); // 36
Console.WriteLine(result2);
 
int DoOperation(int n, Func<int, int> operation) => operation(n);
int DoubleNumber(int n) => 2 * n;
int SquareNumber(int n) => n * n;
```

Метод DoOperation() в качестве параметра принимает делегат Func<int, int>, то есть ссылку на метод, который принимает число int и возвращает также значение int.

При первом вызове метода DoOperation() ему передается ссылка на метод DoubleNumber, который увеличивает число в два раза. Во втором случае передается метод SquareNumber - опять же метод, который принимает параметр типа int и возвращает результат в виде значения int.

Другой пример:

```Csharp
Func<int, int, string> createString = (a, b) => $"{a}{b}";
Console.WriteLine(createString(1, 5));  // 15
Console.WriteLine(createString(3, 5));  // 35
```

Здесь переменная createString представляет лямбда-выражение, которое принимает два числа int и возвращает строку, то есть представляет делегат Func<int, int, string>.

# Замыкания

**Замыкание** (closure) представляет объект функции, который запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.

Технически замыкание включает три компонента:

внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение

переменные и параметры (лексическое окружение), которые определены во внешней функции

вложенная функция, которая использует переменные и параметры внешней функции

В языке C# реализовать замыкания можно разными способами - с помощью локальных функций и лямбда-выражений.

Рассмотрим создание замыканий через локальные функции:

```Csharp
var fn = Outer();   // fn = Inner, так как метод Outer возвращает функцию Inner
// вызываем внутреннюю функцию Inner
fn();   // 6
fn();   // 7
fn();   // 8
 
Action Outer()  // метод или внешняя функция
{
    int x = 5;  // лексическое окружение - локальная переменная
    void Inner()    // локальная функция
    {
        x++;        // операции с лексическим окружением
        Console.WriteLine(x);
    }
    return Inner;   // возвращаем локальную функцию
}
```

Здесь метод Outer в качестве возвращаемого типа имеет тип Action, то есть метод возвратить функцию, которая не принимает параметров и имеет тип void.

```Csharp
Action Outer()
```

Внутри метода Outer определена переменная x - это и есть лексическое окружение для внутренней функции:

```Csharp
int x = 5;
```

Также внутри метода Outer определена внутренняя функция - локальная функция Inner, которая обращается к своему лексическому окружению - переменной x - увеличивает ее значение на единицу и выводит на консоль:

```Csharp
void Inner()
{
    x++;
    Console.WriteLine(x);
}
```
Эта локальная функция возвращается методом Outer:

```Csharp
return Inner;
```

В программе вызываем метод Outer и получаем в переменную fn локальную функцию Inner:

```Csharp
var fn = Outer();
```

Переменная fn и представляет собой замыкание, то есть объединяет две вещи: функцию и окружение, в котором функция была создана. И несмотря на то, что мы получили локальную функцию и можем ее вызывать вне ее метода, в котором она определена, тем не менее она запомнила свое лексическое окружение и может к нему обращаться и изменять, что мы увидим по консольному выводу:

```Csharp
fn();   // 6
fn();   // 7
fn();   // 8
```

## Реализация с помощью лямбда-выражений

С помощью лямбд можно сократить определение замыкания:

```Csharp
var outerFn = () =>
{
    int x = 10;
    var innerFn = () => Console.WriteLine(++x);
    return innerFn;
};
 
var fn = outerFn();   // fn = innerFn, так как outerFn возвращает innerFn
// вызываем innerFn
fn();   // 11
fn();   // 12
fn();   // 13
```

## Применение параметров

Кроме внешних переменных к лексическому окружению также относятся параметры окружающего метода. Рассмотрим использование параметров:

```Csharp
var fn = Multiply(5);  
 
Console.WriteLine(fn(5));   // 25
Console.WriteLine(fn(6));   // 30
Console.WriteLine(fn(7));   // 35
 
Operation Multiply(int n)
{
    int Inner(int m)
    {
        return n * m;
    }
    return Inner;
}
delegate int Operation(int n);
```

Здесь внешняя функция - метод Multiply возвращает функцию, которая принимает число int и возвращает число int. Для этого определен делегат Operation, который будет представлять возвращаемый тип:

```Csharp
delegate int Operation(int n);
```

Хотя также можно было бы использовать встроенный делегат Func<int, int>.

Вызов метода Multiply() возвращает локальную функцию, которая соответствует сигнатуре делегата Operation:

```Csharp
int Inner(int m)
{
    return n * m;
}
```

Эта функция запоминает окружение, в котором она была создана, в частности, значение параметра n. Кроме того, сама принимает параметр и возвращает произведение параметров n и m.

В итоге при вызове метода Multiply определяется переменная fn, которая получает локальную функцию Inner и ее лексическое окружение - значение параметра n:

```Csharp
var fn = Multiply(5);
```

В данном случае параметр n равен 5.

При вызове локальной функции, например, в случае:

```Csharp
Console.WriteLine(fn(6));   // 30
```

Число 6 передается для параметра m локальной функции, которая возвращает произведение n и m, то есть 5 * 6 = 30.

Также можно было бы сократить весь этот код с помощью лямбд:

```Csharp
var multiply = (int n) => (int m) => n * m; 
 
var fn = multiply(5);  
 
Console.WriteLine(fn(5));   // 25
Console.WriteLine(fn(6));   // 30
Console.WriteLine(fn(7));   // 35
```

