# Дополнительные возможности ООП в C#

## Определение операторов

Наряду с методами в классах и структурах мы можем также определять операторы. Например, пусть у нас есть следующий класс Counter:

```Csharp
class Counter
{
    public int Value { get; set; }
}
```

Данный класс представляет некоторый счетчик, значение которого хранится в свойстве Value.

И допустим, у нас есть два объекта класса Counter - два счетчика, которые мы хотим сравнивать или складывать на основании их свойства Value, используя стандартные операции сравнения и сложения:

```Csharp
Counter counter1 = new Counter { Value = 23 };
Counter counter2 = new Counter { Value = 45 };
 
bool result = counter1 > counter2;
Counter c3 = counter1 + counter2;
```

Стоит отметить, что так как по сути определение оператора представляет собой метод, то этот метод мы также можем перегрузить, то есть создать для него еще одну версию. Например, добавим в класс Counter еще один оператор:

```Csharp
public static int operator +(Counter counter1, int val)
{
    return counter1.Value + val;
}
```

Данный метод складывает значение свойства Value и некоторое число, возвращая их сумму. И также мы можем применить этот оператор:

```Csharp
Counter counter1 = new Counter { Value = 23 };
int result = counter1 + 27; // 50
Console.WriteLine(result);
```

Следует учитывать, что не все операторы можно определить. В частности, мы можем определить логику для следующих операторов:

- унарные операторы +x, -x, !x, ~x, ++, --, true, false

- бинарные операторы +, -, *, /, %

- операции сравнения ==, !=, <, >, <=, >=

- поразрядные операторы &, |, ^, <<, >>

- логические операторы &&, ||

Кроме того, есть несколько операторов, которые надо определять парами:

- == и !=

- < и >

- <= и >=

И есть ряд операторов, которые нельзя перегрузить, например, операцию равенства = или тернарный оператор ?:, а также ряд других. Полный список перегружаемых операторов можно найти в документации msdn

## Определение инкремента и декремента

Следует учитывать, что в коде оператора не должны изменяться те объекты, которые передаются в оператор через параметры. Например, мы можем определить для класса Counter оператор инкремента:

```Csharp
public static Counter operator ++(Counter counter1)
{
    counter1.Value += 10;
    return counter1;
}
```

Поскольку оператор унарный, он принимает только один параметр - объект того класса, в котором данный оператор определен. Но это неправильное определение инкремента, так как оператор не должен менять значения своих параметров.

И более корректное определение оператора инкремента будет выглядеть так:

```Csharp
public static Counter operator ++(Counter counter1)
{
    return new Counter { Value = counter1.Value + 10 };
}
```

То есть возвращается новый объект, который содержит в свойстве Value инкрементированное значение. При этом нам не надо определять отдельно операторы для префиксного и для постфиксного инкремента (а также декремента), так как одна реализация будет работать в обоих случаях.

```Csharp
Counter counter1 = new Counter() { Value = 10 };
Counter counter2 = counter1++;
Console.WriteLine(counter1.Value);      // 20
Console.WriteLine(counter2.Value);      // 10
 
Counter counter3 = ++counter1;
Console.WriteLine(counter1.Value);      // 30
Console.WriteLine(counter3.Value);      // 30
```

При операции постфиксного инкремента (counter1++) компилятор сначала создает временную переменную, в которую сохраняет текущий объект. Затем текущий объект замещает значением, полученным из функции оператора. В качестве результата операции возвращается значение временной переменной. При префиксном инкременте (++counter1) компилятор возвращает новое значение, полученное из функции оператора.

## Определение операций true и false

Отдельно стоит отметить определение операторов true и false. Эти операторы определяются, когда мы хотим использовать объект типа в качестве условия. Например, определим данные операторы в классе Counter:

```Csharp
class Counter
{
    public int Value { get; set; }
     
    public static bool operator true(Counter counter1)
    {
        return counter1.Value != 0;
    }
    public static bool operator false(Counter counter1)
    {
        return counter1.Value == 0;
    }
}
```

Например:

```Csharp
Counter counter = new Counter() { Value = 0 };
if (counter)
    Console.WriteLine(true);
else
    Console.WriteLine(false);
```

Также стоит отметить, что если мы хотим использовать операцию отрицания, типа if (!counter), то нам также необходимо определить для типа операцию !:

```Csharp
Counter counter = new Counter() { Value = 2 };
if (!counter)
    Console.WriteLine(true);
else
    Console.WriteLine(false);
 
class Counter
{
    public int Value { get; set; }
 
    public static bool operator !(Counter counter1)
    {
        return counter1.Value == 0;
    }
 
    public static bool operator true(Counter counter1)
    {
        return counter1.Value != 0;
    }
    public static bool operator false(Counter counter1)
    {
        return counter1.Value == 0;
    }
}
```

Операция отрицания фактически синонимична операции false, поэтому содержит аналогичное условие.

## Перегрузка операций преобразования типов

В прошлой теме была рассмотрена тема перегрузки операторов. И с этой темой тесно связана тема перегрузки операторов преобразования типов.

Ранее мы рассматривали явные и неявные преобразования примитивных типов. Например:

```Csharp
int x = 50;
byte y = (byte)x; // явное преобразование от int к byte
int z = y;  // неявное преобразование от byte к int
```

И было бы не плохо иметь возможность определять логику преобразования одних типов в другие. И с помощью перегрузки операторов мы можем это делать. Для этого в классе определяется метод следующей формы:

```Csharp
public static implicit|explicit operator Тип_в_который_надо_преобразовать(исходный_тип param)
{
    // логика преобразования
}
```

После модификаторов public static идет ключевое слово explicit (если преобразование явное, то есть нужна операция приведения типов) или implicit (если преобразование неявное). Затем идет ключевое слово operator и далее возвращаемый тип, в который надо преобразовать объект. В скобках в качестве параметра передается объект, который надо преобразовать.

Например, пусть у нас есть следующий класс Counter, который представляет счетчик-секундомер и который хранит количество секунд в свойстве Seconds:

```Csharp
class Counter
{
    public int Seconds { get; set; }
 
    public static implicit operator Counter(int x)
    {
        return new Counter { Seconds = x };
    }
    public static explicit operator int(Counter counter)
    {
        return counter.Seconds;
    }
}
```

Первый оператор преобразует число - объект типа int к типу Counter. Его логика проста - создается новый объект Counter, у которого устанавливается свойство Seconds.

Второй оператор преобразует объект Counter к типу int, то есть получает из Counter число.

Примение операторов преобразования в программе:

```Csharp
Counter counter1 = new Counter { Seconds = 23 };
 
int x = (int)counter1;
Console.WriteLine(x);   // 23
 
Counter counter2 = x;
Console.WriteLine(counter2.Seconds);  // 23
```

Поскольку операция преобразования из Counter в int определена с ключевым словом explicit, то есть как явное преобразование, то в этом случае необходимо применить операцию приведения типов:

```Csharp
int x = (int)counter1;
```

В случае с операцией преобразования от int к Counter ничего подобного делать не надо, поскольку данная операция определена с ключевым словом implicit, то есть как неявная. Какие операции преобразования делать явными, а какие неявные, в данном случае не столь важно, это решает разработчик по своему усмотрению.

Следует учитывать, что оператор преобразования типов должен преобразовывать из типа или в тип, в котором этот оператор определен. То есть оператор преобразования, определенный в типе Counter, должен либо принимать в качестве параметра объект типа Counter, либо возвращать объект типа Counter.

Рассмотрим также более сложные преобразования, к примеру, из одного составного типа в другой составной тип. Допустим, у нас есть еще класс Timer:

```Csharp
class Timer
{
    public int Hours { get; set; }
    public int Minutes { get; set; }    
    public int Seconds { get; set; }
}
class Counter
{
    public int Seconds { get; set; }
 
    public static implicit operator Counter(int x)
    {
        return new Counter { Seconds = x };
    }
    public static explicit operator int(Counter counter)
    {
        return counter.Seconds;
    }
    public static explicit operator Counter(Timer timer)
    {
        int h = timer.Hours * 3600;
        int m = timer.Minutes * 60;
        return new Counter { Seconds = h + m + timer.Seconds };
    }
    public static implicit operator Timer(Counter counter)
    {
        int h = counter.Seconds / 3600;
        int m = (counter.Seconds % 3600) / 60;
        int s = counter.Seconds % 60;
        return new Timer { Hours = h, Minutes = m, Seconds = s };
    }
}
```

Класс Timer представляет условный таймер, который хранит часы, минуты и секунды. Класс Counter представляет условный счетчик-секундомер, который хранит количество секунд. Исходя из этого мы можем определить некоторую логику преобразования из одного типа к другому, то есть получение из секунд в объекте Counter часов, минут и секунд в объекте Timer. Например, 3675 секунд по сути это 1 час, 1 минута и 15 секунд

Применение операций преобразования:

```Csharp
Counter counter1 = new Counter { Seconds = 115 };
 
Timer timer = counter1;
Console.WriteLine($"{timer.Hours}:{timer.Minutes}:{timer.Seconds}"); // 0:1:55
 
Counter counter2 = (Counter)timer;
Console.WriteLine(counter2.Seconds);  //115
```

## Индексаторы

Индексаторы позволяют индексировать объекты и обращаться к данным по индексу. Фактически с помощью индексаторов мы можем работать с объектами как с массивами. По форме они напоминают свойства со стандартными блоками get и set, которые возвращают и присваивают значение.

Формальное определение индексатора:

```Csharp
возвращаемый_тип this [Тип параметр1, ...]
{
    get { ... }
    set { ... }
}
```

В отличие от свойств индексатор не имеет названия. Вместо него указывается ключевое слово this, после которого в квадратных скобках идут параметры. Индексатор должен иметь как минимум один параметр.

Посмотрим на примере. Допустим, у нас есть класс Person, который представляет человека, и класс Company, который представляет некоторую компанию, где работают люди. Используем индексаторы для определения класса Company:

```Csharp
class Person
{
    public string Name { get;}
    public Person(string name) => Name=name;
}
class Company
{
    Person[] personal;
    public Company(Person[] people) => personal = people;
    // индексатор
    public Person this[int index]
    {
        get => personal[index];
        set => personal[index] = value;
    }
}
```

Для хранения персонала компании в классе определен массив personal, который состоит из объектов Person. Для доступа к этим объектам определен индексатор:

```Csharp
public Person this[int index]
```

Индексатор в принципе подобен стандартному свойству. Во-первых, для индексатора определяется тип в данном случае тип Person. Тип индексатора определяет, какие объекты будет получать и возвращать индексатор.

Во-вторых, для индексатора определен параметр int index, через который обращаемся к элементам внутри объекта Company.

Для возвращения объекта в индексаторе определен блок get:

```Csharp
get => personal[index];
```

Поскольку индексатор имеет тип Person, то в блоке get нам надо возвратить объект этого типа с помощью оператора return. Здесь мы можем определить разнообразную логику. В данном случае просто возвращаем объект из массива personal.

В блоке set, как и в обычном свойстве, получаем через параметр value переданный объект Person и сохраняем его в массив по индексу.

```Csharp
set => personal[index] = value;
```

После этого мы можем работать с объектом Company как с набором объектов Person:

```Csharp
var microsoft = new Company(new[]
{
    new Person("Tom"), new Person("Bob"), new Person("Sam"), new Person("Alice")
});
// получаем объект из индексатора
Person firstPerson = microsoft[0];
Console.WriteLine(firstPerson.Name);  // Tom
// переустанавливаем объект
microsoft[0] = new Person("Mike");
Console.WriteLine(microsoft[0].Name);  // Mike
```

Стоит отметить, что если индексатору будет передан некорректный индекс, который отсутствует в массиве person, то мы получим исключение, как и в случае обращения напрямую к элементам массива. В этом случае можно предусмотреть какую-то дополнительную логику. Например, проверять переданный индекс:

```Csharp
class Company
{
    Person[] personal;
    public Company(Person[] people) => personal = people;
    // индексатор
    public Person this[int index]
    {
        get
        {
            // если индекс имеется в массиве
            if (index >= 0 && index < personal.Length)
                return personal[index]; // то возвращаем объект Person по индексу
            else
                throw new ArgumentOutOfRangeException(); // иначе генерируем исключение
        }
        set
        {
            // если индекс есть в массиве
            if (index >= 0 && index < personal.Length)
                personal[index] = value;    // переустанавливаем значение по индексу
        }
    }
}
```

Здесь в блоке get если переданный индекс имеется в массиве, то возвращаем объект по индексу. Если индекса нет в массиве, то генерируем исключение. Аналогично в блоке set устанавливаем значение по индексу, если индекс есть в массиве.

## Индексы

Индексатор получает набор индексов в виде параметров. Однако индексы необязательно должны представлять тип int, устанавливаемые/возвращаемые значения необязательно хранить в массиве. Например, мы можем рассматривать объект как хранилище атрибутов/свойств и передавать имя атрибута в виде строки:

```Csharp
User tom = new User();
// устанавливаем значения
tom["name"] = "Tom";
tom["email"] = "tom@gmail.ru";
tom["phone"] = "+1234556767";
 
// получаем значение
Console.WriteLine(tom["name"]); // Tom
 
class User
{
    string name = "";
    string email = "";
    string phone = "";
    public string this[string propname]
    {
        get
        {
            switch (propname)
            {
                case "name": return name;
                case "email": return email;
                case "phone": return phone;
                default: throw new Exception("Unknown Property Name");
            }
        }
        set
        {
            switch (propname)
            {
                case "name":
                    name = value;
                    break;
                case "email":
                    email = value;
                    break;
                case "phone":
                    phone = value;
                    break;
            }
        }
    }
}
```

В данном случае индексатор в классе User в качестве индекса получает строку, которая хранит название атрибута (в данном случае название поля класса).

В блоке get в зависимости от значения строкового индекса возвращается значение того или иного поля класса. Если передано неизвестное название, то генерируется исключение. В блоке set похожая логика - по индексу узнаем, для какого поля надо установить значение.

## Применение нескольких параметров

Также индексатор может принимать несколько параметров. Допустим, у нас есть класс, в котором хранилище определено в виде двухмерного массива или матрицы:

```Csharp
class Matrix
{
    int[,] numbers = new int[,] { { 1, 2, 4 }, { 2, 3, 6 }, { 3, 4, 8 } };
    public int this[int i, int j]
    {
        get => numbers[i, j];
        set => numbers[i, j] = value;
    }
}
```

Теперь для определения индексатора используются два индекса - i и j. И в программе мы уже должны обращаться к объекту, используя два индекса:

```Csharp
Matrix matrix = new Matrix();
Console.WriteLine(matrix[0, 0]);
matrix[0, 0] = 111;
Console.WriteLine(matrix[0, 0]);
```

Следует учитывать, что индексатор не может быть статическим и применяется только к экземпляру класса. Но при этом индексаторы могут быть виртуальными и абстрактными и могут переопределяться в произодных классах.

## Блоки get и set

Как и в свойствах, в индексаторах можно опускать блок get или set, если в них нет необходимости. Например, удалим блок set и сделаем индексатор доступным только для чтения:

```Csharp
class Matrix
{
    int[,] numbers = new int[,] { { 1, 2, 4 }, { 2, 3, 6 }, { 3, 4, 8 } };
    public int this[int i, int j]
    {
        get => numbers[i, j];
    }
}
```

Также мы можем ограничивать доступ к блокам get и set, используя модификаторы доступа. Например, сделаем блок set приватным:

```Csharp
class Matrix
{
    int[,] numbers = new int[,] { { 1, 2, 4 }, { 2, 3, 6 }, { 3, 4, 8 } };
    public int this[int i, int j]
    {
        get => numbers[i, j];
        private set => numbers[i, j] = value;
    }
}
```

## Перегрузка индексаторов

Подобно методам индексаторы можно перегружать. В этом случае также индексаторы должны отличаться по количеству, типу или порядку используемых параметров. Например:

```Csharp
var microsoft = new Company(new Person[] { new("Tom"), new("Bob"), new("Sam") });
 
Console.WriteLine(microsoft[0].Name);      // Tom
Console.WriteLine(microsoft["Bob"].Name);  // Bob
class Person
{
    public string Name { get;}
    public Person(string name) => Name=name;
}
class Company
{
    Person[] personal;
    public Company(Person[] people) => personal = people;
    // индексатор
    public Person this[int index]
    {
        get => personal[index];
        set => personal[index] = value;
    }
 
    public Person this[string name]
    {
        get
        {
            foreach (var person in personal)
            {
                if (person.Name == name) return person;
            }
            throw new Exception("Unknown name");
        }
    }
}
```

В данном случае класс Company содержит две версии индексатора. Первая версия получает и устанавливает объект Person по индексу, а вторая - только получае объект Person по его имени.

## Переменные-ссылки и возвращение ссылки

Кроме параметров метода, которые с помощью модификатора ref позволяют передавать значение по ссылке, C# также позволяет с помощью ключевого слова ref возвращать ссылку из метода и определять переменную, которая будет хранить ссылку.

### Переменная-ссылка

Для определения локальной переменной-ссылки (ref local) перед ее типом ставится ключевое слово ref:

```Csharp
int x = 5;
ref int xRef = ref x;
```

Здесь переменная xRef указывает не просто на значение переменной x, а на область в памяти, где располагается эта переменная. Для этого перед x также указывается ref.

При этом мы не можем просто определить переменную-ссылку, нам обязательно надо присвоить ей некоторое значение. Так, следующий код вызовет ошибку:

```Csharp
ref int xRef;   // ошибка
```

Получив ссылку, мы можем манипулировать значением по этой ссылке. Например:

```Csharp
int x = 5;
ref int xRef = ref x;
Console.WriteLine(x); // 5
xRef = 125;
Console.WriteLine(x); // 125
x = 625;
Console.WriteLine(xRef); // 625
```

## Ссылка как результат функции

Для возвращения из функции ссылки в сигнатуре функции перед возвращаемым типом, а также после оператора return следует указать ключевое слово ref:

```Csharp
int[] numbers = { 1, 2, 3, 4, 5, 6, 7 };
ref int numberRef = ref Find(4, numbers); // ищем число 4 в массиве
numberRef = 9; // заменяем 4 на 9
Console.WriteLine(numbers[3]); // 9
 
ref int Find(int number, int[] numbers)
{
    for (int i = 0; i < numbers.Length; i++)
    {
        if (numbers[i] == number)
        {
            return ref numbers[i]; // возвращаем ссылку на адрес, а не само значение
        }
    }
    throw new IndexOutOfRangeException("число не найдено");
}
```

В методе Find ищем число в массиве, но вместо самого значения числа возвращаем ссылку на него в памяти. Для этого в сигнатуре метода в качестве типа результата функции указывается не просто int, а ref int.

Кроме того, в самом методе после слова return также ставится ref:

```Csharp
return ref numbers[i];
```

Тем самым мы получаем не просто значение, а ссылку на объект в памяти.

В методе Main для определения переменной, которая будет содержать ссылку, используется ключевое слово ref. При вызове метода также указывается слово ref:

```Csharp
ref int numberRef = ref Find(7, numbers);
```

В итоге переменная numberRef будет содержать ссылку на объект int, и через данную переменную в последствиии мы можем изменить объект по этой ссылке.

Другой пример - возвращение ссылки на максимальное число из двух:

```Csharp
int a = 5;
int b = 8;
ref int pointer = ref Max(ref a, ref b);
pointer = 34;   // меняем значением максимального числа
Console.WriteLine($"a: {a}  b: {b}"); // a: 5   b: 34
 
ref int Max(ref int n1, ref int n2)
{
    if (n1 > n2)
        return ref n1;
 
    else
        return ref n2;
}
```

Стоит обратить внимание, что параметры метода в этом случае определены с ключевым словом ref.

При определении метода, который возвращает ссылку, следует учитывать, что такой метод естественно не может иметь тип void. Кроме того, такой метод не может возвращать:

- Значение null

- Константу

- Значение перечисления enum

- Свойство класса или структуры

- Поле для чтения (которое имеет модификатор read-only)

## Методы расширения

Методы расширения (extension methods) позволяют добавлять новые методы в уже существующие типы без создания нового производного класса. Эта функциональность бывает особенно полезна, когда нам хочется добавить в некоторый тип новый метод, но сам тип (класс или структуру) мы изменить не можем, поскольку у нас нет доступа к исходному коду. Либо если мы не можем использовать стандартный механизм наследования, например, если классы определенны с модификатором sealed.

Например, нам надо добавить для типа string новый метод:

```Csharp
string s = "Привет мир";
char c = 'и';
int i = s.CharCount(c);
Console.WriteLine(i); 
 
public static class StringExtension
{
    public static int CharCount(this string str, char c)
    {
        int counter = 0;
        for (int i = 0; i < str.Length; i++)
        {
            if (str[i] == c)
                counter++;
        }
        return counter;
    }
}
```

Для того, чтобы создать метод расширения, вначале надо создать статический класс, который и будет содержать этот метод. В данном случае это класс StringExtension. Затем объявляем статический метод. Суть нашего метода расширения - подсчет количества определенных символов в строке.

Собственно метод расширения - это обычный статический метод, который в качестве первого параметра всегда принимает такую конструкцию: this имя_типа название_параметра, то есть в нашем случае this string str. Так как наш метод будет относиться к типу string, то мы и используем данный тип.

Затем у всех строк мы можем вызвать данный метод:

```Csharp
int i = s.CharCount(c);
```

Причем нам уже не надо указывать первый параметр. Значения для остальных параметров передаются в обычном порядке.

Применение методов расширения очень удобно, но при этом надо помнить, что метод расширения никогда не будет вызван, если он имеет ту же сигнатуру, что и метод, изначально определенный в типе.

Также следует учитывать, что методы расширения действуют на уровне пространства имен. То есть, если добавить в проект другое пространство имен, то метод не будет применяться к строкам, и в этом случае надо будет подключить пространство имен метода через директиву using.

## Частичные классы и методы

Классы могут быть частичными. То есть мы можем иметь несколько файлов с определением одного и того же класса, и при компиляции все эти определения будут скомпилированы в одно.

Например, определим в проекте два файла с кодом. Не столь важно как эти файлы будут называться. Например, PersonBase.cs и PersonAdditional.cs. В одном из этих файлов (без разницы в каком именно) определим следующий класс:

```Csharp
public partial class Person
{
    public void Move()
    {
        Console.WriteLine("I am moving");
    }
}
```

А в другом файле определим следующий класс:

```Csharp
public partial class Person
{
    public void Eat()
    {
        Console.WriteLine("I am eating");
    }
}
```

Таким образом, два файла в проекте содержит определение одного и того же класса Person, которые содержат два разных метода. И оба определенных здесь класса являются частичными. Для этого они определяются с ключевым словом partial.

![](https://metanit.com/sharp/tutorial/pics/3.14.png)

Затем мы можем использовать все методы класса Person:

```Csharp
class Program
{
    static void Main(string[] args)
    {
        Person tom = new Person();
        tom.Move();
        tom.Eat();
 
        Console.ReadKey();
    }
}
```

## Частичные методы

Частичные классы могут содержать частичные методы. Такие методы также опреляются с ключевым словом partial. Причем определение частичного метода без тела метода находится в одном частичном классе, а реализация этого же метода - в другом частичном классе.

Например, изменим выше определенные классы Person. Первый класс:

```Csharp
public partial class Person
{
    partial void Read();
    public void DoSomething()
    {
        Read();
    }
}
```

Второй класс:

```Csharp
public partial class Person
{
    partial void Read()
    {
        Console.WriteLine("I am reading a book");
    }
}
```

В первом классе определен метод Read(). Причем на момент определения первого класса неизвестно, что представляет собой этот метод, какие действия он будет выполнять. Тем не менее мы знаем список его параметров и можем вызвать в первом классе.

Второй класс уже непосредственно определяет тело метода Read().

```Csharp
class Program
{
    static void Main(string[] args)
    {
        Person tom = new Person();
        tom.DoSomething();
    } 
}
```

Стоит отметить, что по умолчанию к частичным методам применяется ряд ограничений:

- Они не могут иметь модификаторы доступа

- Они имеют тип void

- Они не могут иметь out-параметры

- Они не могут иметь модификаторы virtual, override, sealed, new или extern

Если же они не соответствуют какому-то из этих ограничений, то для них должна быть предоставлена реализация. Как, например, в следующем примере частичные методы применяют модификатор public:

```Csharp
// первая реализация класса и его методов
public partial class Person
{
    public partial void Read();
    public void DoSomething()
    {
        Read();
    }
}
 
// вторая реализация класса и его методов
public partial class Person
{
    public partial void Read()
    {
        Console.WriteLine("I am reading a book");
    }
}
```

## Анонимные типы

Анонимные типы позволяют создать объект с некоторым набором свойств без определения класса. Анонимный тип определяется с помощью ключевого слова var и инициализатора объектов:

```Csharp
var user = new { Name = "Tom", Age = 34 };
Console.WriteLine(user.Name);
```

В данном случае user - это объект анонимного типа, у которого определены два свойства Name и Age. И мы также можем использовать его свойства, как и у обычных объектов классов. Однако тут есть ограничение - свойства анонимных типов доступны только для чтения.

При этом во время компиляции компилятор сам будет создавать для него имя типа и использовать это имя при обращении к объекту. Нередко анонимные типы имеют имя наподобие "<>f__AnonymousType0'2".

Для исполняющей среды CLR анонимные типы будут также, как и классы, представлять ссылочный тип.

Если в программе используются несколько объектов анонимных типов с одинаковым набором свойств, то для них компилятор создаст одно определение анонимного типа:

```Csharp
var user = new { Name = "Tom", Age = 34 };
var student = new { Name = "Alice", Age = 21 };
var manager = new { Name = "Bob", Age = 26, Company = "Microsoft" };
 
Console.WriteLine(user.GetType().Name); // <>f__AnonymousType0'2
Console.WriteLine(student.GetType().Name); // <>f__AnonymousType0'2
Console.WriteLine(manager.GetType().Name); // <>f__AnonymousType1'3
```

Здесь user и student будут иметь одно и то же определение анонимного типа. Однако подобные объекты нельзя преобразовать к какому-нибудь другому типу, например, классу, даже если он имеет подобный набор свойств.

Следует учитывать, что свойства анонимного объекта доступны для установки только в инициализаторе. Вне инициализатора присвоить им значение мы не можем. Поэтому, например, в следующем случае мы столкнемся с ошибкой:

```Csharp
var student = new { Name = "Alice", Age = 21 };
student.Age = 32;   // ! Ошибка
```

Кроме использованной выше формы инициализации, когда мы присваиваем свойствам некоторые значения, также можно использовать инициализаторы с проекцией (projection initializers), когда мы можем передать в инициализатор некоторые идиентификаторы, имена которых будут использоваться как названия свойств:

```Csharp
Person tom = new Person("Tom"); 
int age = 34;
var student = new { tom.Name, age }; // инициализатор с проекцией
Console.WriteLine(student.Name);
Console.WriteLine(student.age);
 
class Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
```

В данном случае определение анонимного объекта фактически будет идентично следующему:

```Csharp
var student = new { Name = tom.Name, age = age};
```

Названия свойств и переменных (Name и age) будут использоваться в качесте названий свойств объекта.

Также можно определять массивы объектов анонимных типов:

```Csharp
var people = new[]
{
    new {Name="Tom"},
    new {Name="Bob"}
};
foreach(var p in people)
{
    Console.WriteLine(p.Name);
}
```

Зачем нужны анонимные типы? Иногда возникает задача использовать один тип в одном узком контексте или даже один раз. Создание класса для подобного типа может быть избыточным. Если нам захочется добавить свойство, то мы сразу же на месте анонимного объекта это можем сделать. В случае с классом придется изменять еще и класс, который может больше нигде не использоваться. Типичная ситуация - получение результата выборки из базы данных: объекты используются только для получения выборки, часто больше нигде не используются, и классы для них создавать было бы излишне. А вот анонимный объект прекрасно подходит для временного хранения выборки.

## Кортежи

Кортежи предоставляют удобный способ для работы с набором значений, который был добавлен в версии C# 7.0.

Кортеж представляет набор значений, заключенных в круглые скобки:

```Csharp
var tuple = (5, 10);
```

В данном случае определен кортеж tuple, который имеет два значения: 5 и 10. В дальнейшем мы можем обращаться к каждому из этих значений через поля с названиями:

```Csharp
Item[порядковый_номер_поля_в_кортеже]
```

Например:

```Csharp
var tuple = (5, 10);
Console.WriteLine(tuple.Item1); // 5
Console.WriteLine(tuple.Item2); // 10
tuple.Item1 += 26;
Console.WriteLine(tuple.Item1); // 31
```

В данном случае тип определяется неявно. Но мы также можем явным образом указать для переменной кортежа тип:

```Csharp
(int, int) tuple = (5, 10);
```

Так как кортеж содержит два числа, то в определении типа нам надо указать два числовых типа. Или другой пример определения кортежа:

```Csharp
(string, int, double) person = ("Tom", 25, 81.23);
```

Первый элемент кортежа в данном случае представляет строку, второй элемент - тип int, а третий - тип double.

Мы также можем дать названия полям кортежа:

```Csharp
var tuple = (count:5, sum:10);
Console.WriteLine(tuple.count); // 5
Console.WriteLine(tuple.sum); // 10
```

Теперь чтобы обратиться к полям кортежа используются их имена, а не названия Item1 и Item2.

Мы даже можем выполнить декомпозицию кортежа на отдельные переменные:

```Csharp
var (name, age) = ("Tom", 23);
Console.WriteLine(name);    // Tom
Console.WriteLine(age);     // 23
```

Одной из задач, которую позволяет элегантно решить кортеж - это обмен значениями:

```Csharp
string main = "Java";
string second = "C#";
(main, second) = (second, main);
Console.WriteLine(main);    // C#
Console.WriteLine(second);  // Java
```

Что можно использовать, например, при простейшей сортировке массива:

```Csharp
int[] nums = { 54, 7, -41, 2, 4, 2, 89, 33, -5, 12 };
 
// сортировка
for (int i = 0; i < nums.Length - 1; i++)
{
    for (int j = i + 1; j < nums.Length; j++)
    {
        if (nums[i] > nums[j])
            (nums[i], nums[j]) =(nums[j], nums[i]);
    }
}
 
// вывод
Console.WriteLine("Вывод отсортированного массива");
for (int i = 0; i < nums.Length; i++)
{
    Console.WriteLine(nums[i]);
}
```

## Кортеж как результат метода

Кортежи могут выступать в качестве результата функции. Например, одной из распространенных ситуаций является возвращение из функции двух и более значений, в то время как функция может возвращать только одно значение. И кортежи представляют оптимальный способ для решения этой задачи:

```Csharp
var tuple = GetValues();
Console.WriteLine(tuple.Item1); // 1
Console.WriteLine(tuple.Item2); // 3
 
(int, int) GetValues()
{
    var result = (1, 3);
    return result;
}
```

Здесь определен метод GetValues(), который возвращает кортеж. Кортеж определяется как набор значений, помещенных в круглые скобки. И в данном случае мы возвращаем кортеж из двух элементов типа int, то есть два числа.

Другой пример:

```Csharp
var tuple = GetValuesData(new int[] { 1, 2, 3, 4, 5, 6, 7 });
Console.WriteLine(tuple.count);
Console.WriteLine(tuple.sum);
 
(int sum, int count) GetValuesData(int[] numbers)
{
    var result = (sum: 0, count: numbers.Length);
    foreach(var n in numbers)
    {
        result.sum += n;
    }
    return result;
}
```

## Кортеж как параметр метода

И также кортеж может передаваться в качестве параметра в метод:

```Csharp
PrintPerson(("Tom", 37));   // Tom - 37
PrintPerson(("Bob", 41));   // Bob - 41
 
 
void PrintPerson((string name, int age) person)
{
    Console.WriteLine($"{person.name} - {person.age}");
}
```

Здесь в метод PrintPerson передается кортеж из двух элементов, первый из которых предоставляет строку, а второй - значение типа int.

## ## Records

Records представляют новый ссылочный тип, который появился в C#9. Ключевая особенность records состоит в том, что они могут представлять неизменяемый (immutable) тип, который по умолчанию обладает рядом дополнительных возможностей по сравнению с классами и структурами. Зачем нам нужны неизменяемые типы? Такие типы более безопасны в тех ситуациях, когда нам надо гарантировать, что данные объекта не будут изменяться. В .NET в принципе уже есть неизменяемые типы, например, String.

Стоит отметить, что начиная с версии C# 10 добавлена поддержка структур record, соответственно мы можем создавать record-классы и record-структуры.

Для определения records используется ключевое слово record. Если определяется класс record, то ключевое слово class можно неиспользовать при определении типа:

```Csharp
public record Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
```

или так

```Csharp
public record class Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
```

При определении структуры record при объявлении типа надо использовать ключевое слово struct:

```Csharp
public record struct Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
```

Хотя типы record предназначены для создания неизменяемых типов, однако одно только применение ключевого слова record не гарантирует неизменяесть объектов record. Они являются неизменяемыми (immutable) только при определенных условиях. Например, мы можем написать так:

```Csharp
var person = new Person("Tom");
person.Name = "Bob";
Console.WriteLine(person.Name); // Bob - данные изменились
 
public record Person
{
    public string Name { get; set; }
    public Person(string name) => Name = name;
}
```

При выполнении этого кода не возникнет никакой ошибки, мы спокойно сможем изменять значения свойств объекта Person. Чтобы сделать его действительно неизменяемым, для свойств вместо обычных сеттеров надо использовать модификатор init.

```Csharp
var person = new Person("Tom");
person.Name = "Bob";    // ! ошибка - свойство изменить нельзя
 
public record Person
{
    public string Name { get; init; }
    public Person(string name) => Name = name;
}
```

В данном случае мы получим ошибку при попытке изменить значение свойств объекта Person.

Во многим records похожи на обычные классы и структуры, например, они могут абстрактными, их также можно наследовать либо запрещать наследование с помощью оператора sealed. Тем не менее есть и ряд отличий. Рассмотрим некоторые основные отличия records от стандартных классов и структур.

## Сравнение на равенство

При определении record компилятор генерирует метод Equals() для сравнения с другим объектом. При этом сравнение двух records производится на основе их значений. Например, рассмотрим следующий пример:

```Csharp
var person1 = new Person("Tom");
var person2 = new Person("Tom");
Console.WriteLine(person1.Equals(person2)); // true
 
var user1 = new User("Tom");
var user2 = new User("Tom");
Console.WriteLine(user1.Equals(user2));     // false
 
public record Person
{
    public string Name { get; init; }
 
    public Person(string name) => Name = name;
}
public class User
{
    public string Name { get; init; }
    public User(string name) => Name = name;
}
```

В данном случае при сравнении двух объектов record Person мы увидим, что они равны, так как их значения (значения свойств Name) равны. Однако в случае с объектами класса User, которые имеют те же одинаковые значения мы увидим, что они не равны. Так как сравнение records производится по значению.

Кроме того, для record уже по умолчанию реализованы операторы == и !=, которые также сравнивают две record по значению:

```Csharp
var person1 = new Person("Tom");
var person2 = new Person("Tom");
Console.WriteLine(person1 == person2); // true
 
var user1 = new User("Tom");
var user2 = new User("Tom");
Console.WriteLine(user1 == user2);     // false
```

## Оператор with

В отличие от классов records поддерживают инициализацию с помощью оператора with. Он позволяет создать одну record на основе другой record:

```Csharp
var tom = new Person("Tom", 37);
var sam = tom with { Name = "Sam" };
Console.WriteLine($"{sam.Name} - {sam.Age}"); // Sam - 37
 
public record Person
{
    public string Name { get; init; }
    public int Age { get; init; }
    public Person(string name, int age)
    {
        Name = name; Age = age;
    }
}
```

После record, значения которой мы хотим скопировать, указывается оператор with, после которого в фигурных скобках указываются значения для тех свойств, которые мы хотим изменить. Так, в данном случае переменная sam получает для свойства Age значение из tom, а свойство Name изменяется.

Эта возможность может быть особенно актуальна, если в record, которую мы хотим скопировать, множество свойств, из которых мы хотим поменять одно-два.

Если надо скопировать значения всех свойств, то можно оставить пустые фигурные скобки:

```Csharp
var person1 = new Person("Tom", 37);
var person2 = person1 with { };
```

## Позиционные records

Records могут принимать данные для свойств через конструктор, и в этом случае мы можем сократить их определение. Например, пусть у нас есть следующая record Person:

```Csharp
public record struct Person
{
    public string Name { get; init; }
    public int Age { get; init; }
    public Person(string name, int age)
    {
        Name = name; Age = age;
    }
    public void Deconstruct(out string name, out int age) => (name, age) = (Name, Age);
}
```

Кроме конструктора здесь реализован деконструктор, который позволяет разложить объект Person на кортеж значений. И мы могли бы применить ее, например, следующим образом:

```Csharp
var person = new Person ("Tom", 37);
Console.WriteLine(person.Name); // Tom
 
var (personName, personAge) = person;
 
Console.WriteLine(personAge);     // 37
Console.WriteLine(personName);    // Tom
```

Выше определенную record Person можно сократить до позиционной record:

```Csharp
public record Person(string Name, int Age);
```

Это все определение типа. То есть мы говорим, что для типа Person будет создаваться конструктор, который принимает два параметра и присваивает их значения соответственно свойствам Name и Age, и что также автоматически будет создаваться деконструктор. Ее использование будет аналогично:

```Csharp
var person = new Person("Tom", 37);
Console.WriteLine(person); // Tom
 
var (personName, personAge) = person;
 
Console.WriteLine(personAge);     // 37
Console.WriteLine(personName);    // Tom
 
public record Person(string Name, int Age);
```

При необходимости также можно совмещать стандартное определение свойств и определение свойств через конструктор:

```Csharp
var person = new Person("Tom", 37) { Company = "Google"};
Console.WriteLine(person.Company); // Google
person.Company = "Microsoft";
Console.WriteLine(person.Company); // Microsoft
 
public record Person(string Name, int Age)
{
    public string Company { get; set; } = "";
}
```

## Позиционные структуры для чтения

Следует отметить различие между позиционными классами и структурами record. Свойства класса record, которые устанавливаются через параметры конструктора, по умолчанию будут иметь модификатор init. То есть после установки их значений через конструктор, мы больше не сможем их изменить:

```Csharp
var person = new Person("Tom", 37);
person.Name = "Bob";    // ! Ошибка - значение нельзя изменить
 
public record Person(string Name, int Age);
```

Стоит отметить, что это относится только к тем свойствам, которые устанавливаются через конструктор.

Однако для позиционных структур record свойства будут иметь стандартные сеттеры, которые позволят изменять значения свойств:

```Csharp
var person = new Person("Tom", 37);
person.Name = "Bob";
Console.WriteLine(person.Name); // Bob - значение изменилось
// структура record
public record struct Person(string Name, int Age);
```

Чтобы для подобных свойств структуры record использовался модификатор init вместо обычных сеттеров, такую структуру надо определить с ключевым словом readonly:

```Csharp
var person = new Person("Tom", 37);
person.Name = "Bob";    // ! Ошибка - значение свойства нельзя изменить
 
// структура record доступна только для чтения
public readonly record struct Person(string Name, int Age);
```

## ToString

Небольшим преимуществом типов record также является то, что для них уже по умолчанию реализован метод ToString(), который выводит состояние объекта в отформатированном виде:

```Csharp
var person = new Person("Tom", 37);
Console.WriteLine(person); // Person {Name = Tom, Age = 37}
 
public record Person(string Name, int Age);
```

## Наследование

Как и обычные классы record-классы могут наследоваться:

```Csharp
var tom = new Person("Tom", 37);
var bob = new Employee("Bob", 41, "Microsoft");
Console.WriteLine(tom); // Person {Name = Tom, Age = 37}
Console.WriteLine(bob); // Person {Name = Bob, Age = 41, Company = Microsoft}
 
public record Person(string Name, int Age);
public record Employee(string Name, int Age, string Company) : Person(Name, Age);
```

В данном случае класс record Employee наследуется от Person.